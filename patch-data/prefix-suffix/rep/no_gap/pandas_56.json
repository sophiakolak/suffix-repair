{"candidate": "            return self._take(np.array([index]), axis=0)._get_value(\n                col, col, takeable=True\n            )\n", "entropy": 24.614396082892995}
{"candidate": "            series = self._ixs(index, col)  # type: ignore\n        else:", "entropy": 11.81563634395}
{"candidate": "            series = self._data.fast_xs(col, self.index[index])\n        else:", "entropy": 19.031646708754998}
{"candidate": "            series = self._iget_item_cache(col)\n            return series._get_value(index)\n", "entropy": 17.49926850917}
{"candidate": "            series = self._ixs(index, col)\n        else:", "entropy": 8.341263593994999}
{"candidate": "            series = self._take_with_is_copy(self._get_item_cache(col), index)\n            if not self.columns.is_unique:\n                if len(series) != 1:\n                    raise ValueError(\n                        \"cannot label index with a duplicate key: \"\n                        f\"{col}\"\n                    )\n                series = series.iloc[0]\n            return series\n        else:", "entropy": 39.96673988973482}
{"candidate": "            series = self.loc[index, col]\n        else:", "entropy": 15.027104870894}
{"candidate": "            series = self._ixs(col, axis=1)\n        else:", "entropy": 8.373778035831}
{"candidate": "            series = self._ixs(index, col)\n        else:", "entropy": 18.33424814205}
{"candidate": "            series = self._iget_item_cache(col)\n            return series._values[index]\n", "entropy": 11.63501307129}
{"candidate": "            series = self._ixs(index, col)\n        else:", "entropy": 9.791195128518998}
{"candidate": "            series = self._take(self._row_labels, col, axis=1, verify=True)\n        else:", "entropy": 13.464587870567504}
{"candidate": "            series = self._ixs(index, col)\n            return series._values[0]\n\n        series = self._get_item_cache(col)\n        i = self.columns.get_loc(col)\n        return series._values[index, i]\n\n    def get_value(self, index, col, takeable=False):\n        \"\"\"\n        Quickly retrieve single value at passed column and index.\n\n        Parameters\n", "entropy": 15.153182755466403}
{"candidate": "            series = self._data.fast_xs(col)\n            return series[index]\n\n        series = self._get_item_cache(col)\n        engine = self.index._engine\n\n        try:\n            loc = engine.get_loc(index)\n            return series[loc]\n        except TypeError:\n            return self.loc[index, col]\n        except KeyError as e1:\n            try:\n                return", "entropy": 27.723197221046735}
{"candidate": "            series = self._ixs(index, col)\n            return series._values[0]\n\n        series = self._get_item_cache(col)\n        return _maybe_box_datetimelike(series._values[index], series.dtype)\n\n    def _get_item_cache(self, key) -> \"Series\":\n        \"\"\"Return the cached item, item represents a column.\"\"\"\n        cache = self._item", "entropy": 27.350707104136312}
{"candidate": "            return self._take(com.default_indexer(index, self.index), com.default_indexer(col, self.columns))\n        align_copy = self.copy()\n        align_copy.columns = self.columns.copy()\n        align_copy.index = self.index.copy()\n\n        with np.errstate(all=\"ignore\"):\n            arr = self.values\n            result = arr[", "entropy": 47.83080116259189}
{"candidate": "            series = self._ixs(index, col)\n        else:\n            series = self._get_item_cache(col)\n\n        # return the actual value\n        return _maybe_box_datetimelike(series._values[index])\n\n    def __getitem__(self, key):\n        key = com.apply_if_callable(key, self)\n        return self._getitem_column(key)\n\n", "entropy": 31.20125870165671}
{"candidate": "            series = self._ixs(index, col)\n            if isinstance(series, ABCDataFrame):\n\n                # we have a DataFrame here with one column, so\n                # return its scalar\n                assert len(series.columns) == 1\n                return series.iat[0, 0]\n\n            return series.iat[index.get_loc(col)]\n\n        # kludge\n        if hasattr(col, \"nd", "entropy": 62.49106109070601}
{"candidate": "            series = self._ixs(col, axis=1)\n            return series._values[index]\n\n        series = self._get_item_cache(col)\n        engine = self.index._engine\n        try:\n            return engine.get_value(series._values, index, fastpath=True)\n        except KeyError:\n            # GH 20629\n            if self.index.nlevels > 1:\n                # partial index", "entropy": 13.373550338853002}
{"candidate": "            if self.columns.nlevels > 1 or self.index.nlevels > 1:\n                raise ValueError(\"Cannot use takeable=True with multilevel index\")\n\n            # This is the same as _xs but we have to have this in order\n            # to pass in the takeable=True flag just for xs\n            series = self._xs(col, axis=1, copy=False)\n            return series.iloc", "entropy": 83.43171852861002}
