{"candidate": "        if is_list_like(data) and not isinstance(data, PeriodArray):\n            # GH#19073\n            if isinstance(data, ABCDataFrame):\n                data = data._values\n\n            data = TimedeltaArray._from_sequence(\n                data, freq=freq, unit=unit, dtype=dtype, copy=copy\n            )\n", "entropy": 34.00842206282969}
{"candidate": "        if isinstance(data, ABCIndexClass):\n            data = data._values\n\n        if isinstance(data, cls):\n", "entropy": 11.098774572085798}
{"candidate": "        if isinstance(data, TimedeltaIndex) or is_list_like(data):\n", "entropy": 12.558781569038002}
{"candidate": "        if isinstance(data, TimedeltaIndex):\n            if freq is None:\n                freq = data.freq\n            elif freq != data.freq:\n                # set passed freq\n                data = data.asfreq(freq)\n\n", "entropy": 17.416943796102988}
{"candidate": "        if isinstance(data, ABCIndex):\n            if isinstance(data, cls):\n                if copy:\n                    data = data.copy()\n                return data\n\n        if isinstance(data, TimedeltaArray) and freq is None and name is None:\n", "entropy": 25.314539192797998}
{"candidate": "        if isinstance(data, (ABCTimedeltaIndex, ABCTimedeltaArray)):\n            if dtype is not None and data.dtype != dtype:\n                data = data.astype(dtype)\n\n", "entropy": 23.295519056542993}
{"candidate": "        # For compatibility with Index.astype(str) and Index.astype(object)\n        elif unit is None:\n            unit = \"ns\"\n\n        if is_list_like(data) and getattr(data, \"ndim\", 1) > 1:\n            raise ValueError(\"TimedeltaIndex does not allow \" \"multidimensional data\")\n\n        if isinstance(data, ABCTimedeltaIndex) and freq is None", "entropy": 41.31755088106372}
{"candidate": "        if isinstance(data, ABCIndexClass):\n            if freq is None and hasattr(data, \"freq\"):\n                freq = data.freq\n            if name is None and hasattr(data, \"name\"):\n                name = data.name\n            if copy:\n                data = data.copy()\n                if isinstance(data, ABCPeriodIndex):\n                    data = data.to_timestamp()\n           ", "entropy": 23.33216400731989}
{"candidate": "        if dtype is not None:\n            dtype = pandas_dtype(dtype)\n            if not is_timedelta64_dtype(dtype):\n                raise ValueError(\n                    f\"dtype must be timedelta64[ns], \"\n                    f'was {dtype}; {dtype} is not supported at this time'\n                )\n\n        if isinstance(data, ABCSeries):\n            from pandas import", "entropy": 40.059010646481994}
{"candidate": "        if is_list_like(data) and getattr(data, \"ndim\", 1) > 1:\n            raise ValueError(\"Index data must be 1-dimensional\")\n\n        if isinstance(data, ABCIndexClass):\n            if isinstance(data, PeriodIndex):\n                tdarr = data.to_timedelta(freq=freq, copy=copy)\n                freq = tdarr.freq\n                return cls", "entropy": 29.38325377355856}
{"candidate": "        freq = _validate_freq_with_units(unit, freq)\n\n        if isinstance(data, ABCIndexClass) and not isinstance(data, cls):\n            # GH#22689\n            if copy:\n                data = data.copy()\n            return cls._simple_new(data._data, name=name, freq=freq)\n        elif isinstance(data, (ABCSeries, ABC", "entropy": 42.50810900167578}
{"candidate": "        if isinstance(data, ABCPeriodIndex):\n            # TODO: Remove once PeriodDtype is implemented\n            #  see gh-23131\n            name = getattr(data, \"name\", name)\n            freq = getattr(data, \"freq\", freq)\n            data = np.asarray(data.astype(\"timedelta64[ns]\").tolist())\n\n        if isinstance(data, ABC", "entropy": 52.234712848599195}
{"candidate": "        if isinstance(data, ABCIndexClass):\n            if is_timedelta64_dtype(data):\n                return cls._simple_new(data, name=name)\n\n            if isinstance(data, (ABCDatetimeIndex, ABCTimedeltaIndex)):\n                # return the i8 view\n                return TimedeltaIndex(data.asi8, name=name)\n            elif isinstance(data, ABCPeriod", "entropy": 38.1690614309045}
{"candidate": "        if is_dtype_equal(dtype, _TD_DTYPE):\n            subarr = np.array([], dtype=_TD_DTYPE)\n            dtype = None\n\n        if isinstance(data, ABCIndexClass):\n            if copy:\n                data = data.copy()\n            return cls._simple_new(data._values, name=name, freq=freq)\n\n        if isinstance(data,", "entropy": 28.0239783973006}
{"candidate": "        # GH#22389 Prevent TimedeltaIndex subclassing from\n        #  transforming dtype object array to timedelta64[ns]\n        if isinstance(data, cls) and dtype is None and copy is None:\n            # work around for mixed freq\n            if freq is None or freq == data.freq:\n                if copy is False:\n                    data._reset_identity()\n                return data.view(cl", "entropy": 95.47083391026834}
{"candidate": "        if data is None:\n            name = None\n            data = []\n        elif isinstance(data, TimedeltaIndex):\n            if name is None:\n                name = data.name\n            freq = data.freq\n\n            if dtype is not None and dtype != data.dtype:\n                data = data.astype(dtype)\n            if copy:\n                data = data._values.copy()\n            else", "entropy": 33.656525774506385}
{"candidate": "        if isinstance(data, ABCIndexClass):\n            if isinstance(data, ABCTimedeltaIndex):\n                freq = data.freq\n            if name is None:\n                name = data.name\n            if data._has_complex_internals:\n                data = np.array(data)\n            else:\n                data = data._ndarray_values\n        if isinstance(data, ABCSeries):\n            from pandas", "entropy": 32.0011875955886}
{"candidate": "        if isinstance(data, ABCIndexClass):\n            if dtype is None:\n                dtype = _TD_DTYPE\n            if copy is None:\n                copy = False\n                if dtype != _TD_DTYPE:\n                    # need to coerce to proper dtype\n                    # so set copy to True\n                    copy = True\n            if isinstance(data, TimedeltaIndex):\n                return cls._simple_new(", "entropy": 47.258726594668936}
{"candidate": "        if isinstance(data, ABCIndexClass):\n            data = np.asarray(data)\n\n        if is_integer_dtype(data):\n            data = data.astype(\"i8\")\n\n        if is_datetime64_dtype(data):\n            data = data.view(\"i8\")\n\n        if not is_dtype_equal(data.dtype, _TD_DTYPE):\n            data = data.ast", "entropy": 35.032263389648}
{"candidate": "        if isinstance(data, ABCIndexClass):\n            if freq is not None:\n                raise ValueError(\"cannot specify freq with %s\" % cls.__name__)\n            if copy:\n                data = data.copy()\n            freq = getattr(data, \"freq\", None)\n            name = getattr(data, \"name\", name)\n\n            if dtype is None:\n                dtype = get", "entropy": 38.739993074589336}
