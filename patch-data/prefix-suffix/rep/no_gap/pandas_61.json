{"candidate": "                return self._get_values(key)\n", "entropy": 9.32390505617}
{"candidate": "                return self.reindex(key)\n        elif key_type == \"boolean\":\n            return self._get_values(key)\n        elif is_list_like(key):\n", "entropy": 14.8246793100453}
{"candidate": "                # GH#3083\n                raise TypeError(\n                    f\"cannot do label indexing on {type(self)} with \"\n                    f\"these indexers [{key[:10]}] of {key_type}\"\n                )\n\n        if isinstance(key, ABCSeries) and not key.index.equals(self.index):\n            key = key.reindex(self.index, copy=False)\n", "entropy": 45.219383163559}
{"candidate": "                return self.reindex(key)\n\n        if key_type == \"boolean\":\n            return self.loc[key]\n\n        if is_list_like_indexer(key):\n            if is_categorical_dtype(self.dtype):\n                raise ValueError(\n                    f\"cannot index a CategoricalIndex with {lib.infer_dtype(key)}\"\n                )\n", "entropy": 39.51040182555899}
{"candidate": "                return self._get_values(key)\n        elif key_type == \"boolean\":\n            return self._get_values(key)\n        elif key_type == \"datetime\":\n            return self.at_time(key)", "entropy": 32.651674748661996}
{"candidate": "                return self.reindex(key)\n        elif key_type == \"boolean\":\n            return self.loc[key]\n", "entropy": 10.928557331058101}
{"candidate": "                return self._get_values(key)\n        elif key_type == \"boolean\":\n            self._boolean_indexing_raise_unless_callable(key)\n            return self._get_values(key)\n        elif key_type == \"date\":\n            # GH#2664\n            return self.loc[key]\n        elif key_type == \"empty\":\n            return self.reindex([])", "entropy": 39.62177540243499}
{"candidate": "                return self._get_values(key)\n\n        if is_array_like(key) and not (isinstance(key, tuple) and is_array_like(key[0])):\n            if com.is_bool_indexer(key):\n                key = np.asarray(key)\n                return self[key]\n            else:\n                return self.take(key)\n\n        if isinstance(key, Index):\n", "entropy": 32.36202407414099}
{"candidate": "                if isinstance(key, (np.ndarray, Index, Series)):\n                    if key.is_boolean():\n                        key = np.asarray(key)\n                        if key.all():\n                            key = np.arange(len(self))\n                        else:\n                            key = key.nonzero()[0]\n                    else:\n                        key = com.maybe_cast_indexer(key)\n                        if", "entropy": 29.6536020980252}
{"candidate": "                if is_list_like_indexer(key):\n                    key = np.array(key, dtype=np.int64)\n\n                return self.reindex(key)\n\n        if is_list_like_indexer(key):\n            key = np.asarray(key)\n\n        is_int = lib.is_integer_dtype(key)\n        is_float = lib.is_float_dtype(key", "entropy": 33.06256136622278}
{"candidate": "                if not is_list_like(key):\n                    key = [key]\n                return self.take(key)\n        elif key_type == \"boolean\":\n            mask = key\n            if len(self.index) != len(mask):\n                raise ValueError(\"Item wrong length {} instead of {}.\".format(len(mask), len(self.index)))\n            return self[mask]\n        elif is_list", "entropy": 24.419475762894905}
{"candidate": "                self._invalid_indexer(\"index\", key)\n        elif key_type == \"boolean\":\n            pass\n        elif key_type == \"datetime64\" or key_type == \"timedelta64\":\n            if self.index.is_(DatetimeIndex):\n                return self.loc[key]\n            elif isinstance(self.index, IntervalIndex):\n                indexer = self.index.get", "entropy": 20.529838051392403}
{"candidate": "                return self.reindex(key)\n        elif key_type == \"boolean\":\n            pass\n\n        # dispatch to _get_values\n        return self._get_values(key)\n\n    def _slice(self, slobj, axis=0):\n        # mpl hackaround\n        if isinstance(self.index, MultiIndex):\n            if axis == 0:\n                new_index = self.index.slice_index", "entropy": 36.36066534442229}
{"candidate": "                return self._get_values(key)\n        elif key_type == \"boolean\":\n            return self._get_values(key)\n\n        # try the callable accessor\n        if lib.is_hashable(key) or is_iterator(key):\n\n            try:\n                return self.index.get_value(self, key)\n            except InvalidIndexError:\n                return self._get_values(key)\n", "entropy": 34.599429618682194}
{"candidate": "                return self._get_values(key)\n        elif key_type == \"boolean\":\n            pass\n        elif key_type == \"empty\":\n            pass\n        elif key_type == \"array\":\n            # array of integers\n            if com.is_integer_dtype(key):\n                return self._get_values_for_integer_array(key)\n            # array of booleans / array of arrays", "entropy": 30.080879274790995}
{"candidate": "                return self.reindex(key)\n        elif key_type == \"boolean\":\n            raise KeyError(\n                \"Cannot use a single bool to index into setitem\"\n            )\n\n        # fall thru to straight lookup\n        return self.reindex(key)\n\n    def _get_values_for_slice(self, slice_):\n        # mpl hackaround\n        if isinstance(slice_, slice):\n", "entropy": 36.6071631476833}
{"candidate": "                return self.reindex(key)\n        elif key_type == \"boolean\":\n            return self._get_values(key)\n        elif is_list_like_indexer(key):\n            if com.is_bool_indexer(key):\n                key = np.asarray(key)\n                if self.index.is_bool:\n                    return self._get_values(key)\n                raise ValueError", "entropy": 31.658264309484693}
{"candidate": "                # For IntervalIndex.get_loc() to work correctly we sort the\n                #  indexer.\n                if is_integer_dtype(key):\n                    sort_key = key\n                else:\n                    sort_key = np.argsort(key)\n                indexer = self.index.get_indexer(key[sort_key])\n                indexer = com._ensure_platform_int(indexer)\n               ", "entropy": 61.32990232590901}
{"candidate": "                # We do not want to allow integer indexing here.  In particular\n                # we don't want to allow integer indexing for\n                # PeriodIndex/TimedeltaIndex\n                return self.loc[key]\n\n        elif key_type == \"categorical\":\n            warnings.warn(\n                \"Indexing a Series with CategoricalIndex is not supported.\"\n                \" Use .loc[indexer]\",\n                FutureWarning,", "entropy": 68.66545221470201}
{"candidate": "                return self._get_values(key)\n        elif key_type == \"boolean\":\n            pass\n        elif com.is_list_like(key):\n            if len(key) and not isinstance(key, (np.ndarray, Index)):\n                key = maybe_convert_indices(key, self.index.nlevels)\n        else:\n            key = self._convert_scalar", "entropy": 32.1117225005487}
