{"candidate": "                left_keys = [self.left.index._values]\n\n        left_drop = [x for x in self.left.index.names if x not in join_names]\n        right_drop = [x for x in self.right.index.names if x not in join_names]\n", "entropy": 12.063317441394307}
{"candidate": "                left_keys = [self.left.index._values]\n\n        # drop the keys\n        left_drop = [k for k in self.left.index.names if k in self.left_on]\n        right_drop = [k for k in self.right.index.names if k in self.right_on]\n", "entropy": 20.658208569234496}
{"candidate": "                left_keys = [self.left.index._values]\n\n        if (\n            len(left_keys) == 0\n            and not self.left.index.is_unique\n            and self.on is None\n            and not isinstance(self.left, ABCSeries)\n        ):\n            raise ValueError(\"cannot join with no level specified and no right \"\n                             \"index name\")\n        if (\n            len(right", "entropy": 40.850720981719796}
{"candidate": "                left_keys = [self.left.index._values]\n\n        if self.is_suffixes:\n            lsuffixes, rsuffixes = self.suffixes\n            left_drop = [x for x in self.left.columns if x.endswith(lsuffixes)]\n            right_drop = [x for x in self.right.columns if x.endswith(rsuffixes", "entropy": 23.146536062235224}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            raise MergeError(\"must pass right_on or right_index=True\")\n\n        self.left_join_keys, self.right_join_keys = self._maybe_coerce_merge_keys()\n\n        # may need to take a passed indicator\n        if self.indicator:\n\n            left_drop = []\n            right_drop = []", "entropy": 36.10694321090431}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            assert isinstance(self.left.index, MultiIndex)\n            assert isinstance(self.right.index, MultiIndex)\n            left_keys = [\n                lev._values.take(lev_codes)\n                for lev, lev_codes in zip(\n                    self.left.index.levels, self.left.index.codes\n                )\n", "entropy": 7.337169287702237}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            raise ValueError(\n                \"You are trying to merge on object and int64 columns. If \"\n                \"you wish to proceed you should use pd.concat\"\n            )\n\n        # invert the join keys if needed\n        if self.right_index:\n            left_keys, right_keys = right_keys, left_keys\n\n        #", "entropy": 26.040954544581002}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            raise ValueError(\n                \"You are trying to merge on object and int64 columns. If \"\n                \"you wish to proceed you should use pd.concat\"\n            )\n\n        self.left_join_keys = left_keys\n        self.right_join_keys = right_keys\n        self.join_names = join_names\n\n       ", "entropy": 9.025499343357467}
{"candidate": "                left_keys = [self.left.index._values]\n                join_names = [self.right.index.name]\n\n        # For DataFrame's in both left and right:\n        # if columns overlap, remove overlapping names\n        # from left add suffixes\n        if isinstance(self.left, DataFrame) and isinstance(self.right, DataFrame):\n            overlap = self.left.columns.intersection(self", "entropy": 55.605265604645304}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            left_keys = [self.left.index._values]\n            right_keys = [self.right.index._values]\n\n        # if the index is an Int64Index & we have no\n        # explicit right_index or left_index, then coerce\n        # to an Int64Index to speed-up the merges on the index\n        if", "entropy": 62.91709205624501}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            raise ValueError(\"You are trying to merge on object and int64 columns. \"\n                             \"If you wish to proceed you should use pd.concat\")\n\n        # type check\n        if not _is_dtype_typecompat(left_keys, right_keys):\n            msg = (\"You are trying to merge on object and int64 columns.", "entropy": 31.70016313513922}
{"candidate": "                left_keys = [self.left.index._values]\n\n        self.join_names = join_names\n        self.right_join_keys = right_keys\n        self.left_join_keys = left_keys\n\n        # maybe drop some levels\n        if isinstance(right_drop, (tuple, list, np.ndarray)):\n            right_drop = right_drop[0] if len(right_drop)", "entropy": 36.87085086738149}
{"candidate": "                left_keys = [self.left.index._values]\n        elif _any(self.left_index) or _any(self.right_index):\n            if _any(self.left_index):\n                if isinstance(self.left.index, MultiIndex):\n                    left_keys = [\n                        lev._values.take(lev_codes)\n                        for lev, lev_codes in zip(\n                            self.", "entropy": 9.227582564610897}
{"candidate": "                left_keys = [self.left.index._values]\n\n        # GH17069: Sort DataFrame by its MultiIndex\n        if self.sort and self.left_index and isinstance(left.index, MultiIndex):\n            left_keys, right_keys, join_names = sort_join_keys(\n                left_keys, right_keys, join_names\n            )\n\n        # coerce to multikey types\n", "entropy": 78.60220765679104}
{"candidate": "                left_keys = [self.left.index._values]\n\n        # if we pass 'on'\n        if _any(self.on):\n            if _any(self.left_on):\n                raise SpecificationError(\n                    \"Can only pass argument 'on' OR \"\n                    \"'left_on', 'right_on' OR 'left_index=True', \"\n                    \"'right_index=True'\"\n                )\n           ", "entropy": 44.342673483785305}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            raise MergeError(\n                \"Must pass right_index/left_index or right_on/left_on\"\n                \" or some combination\"\n            )\n\n        # GH#31875 preserve key names\n        join_names = [self._maybe_match_name(x, y) for x, y in zip(join_names, left_keys)]", "entropy": 53.807622485421}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            if is_list_like(self.left_index) or is_list_like(self.right_index):\n                raise AssertionError(\n                    \"suffixes are not supported for multi-indexes\"\n                )\n\n            if not (left.index.is_unique and right.index.is_unique):\n                left_suffix", "entropy": 56.81012907893432}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            raise ValueError(\n                \"You are trying to merge on {left} and {right}, but \"\n                \"they are not identifiable by the index. To identify \"\n                \"by position, use the integer-based `left_index` \"\n                \"and `right_index` parameters.\\n\\n\"\n                \"The left index, however, has", "entropy": 38.514213322224016}
{"candidate": "                left_keys = [self.left.index._values]\n        else:\n            # non-join\n            if isinstance(self.left.index, MultiIndex):\n                left_keys = [\n                    lev._values.take(lev_codes)\n                    for lev, lev_codes in zip(\n                        self.left.index.levels, self.left.index.codes\n                    )\n                ]\n                left_drop = [", "entropy": 18.320778335945235}
{"candidate": "                left_keys = [self.left.index._values]\n\n        self.join_names = join_names\n\n        # do we want to ffill self.right if we have empty right keys\n        if self.left_index and self.right_index and not self.right_on:\n            ffill = self.fill_method == \"ffill\"\n        else:\n            ffill = False\n\n        if is_multi_with_", "entropy": 76.55308863435725}
