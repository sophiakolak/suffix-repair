{"candidate": "        if not has_scheme(self._url):\n", "entropy": 17.131290266}
{"candidate": "        if ':' not in self._url and self._url.startswith('//'):\n            self._url = 'http:' + self._url\n\n        if not urlparse(self._url).scheme:\n", "entropy": 21.558396017690804}
{"candidate": "        if not self._parsed_url.scheme:\n", "entropy": 8.633914222669999}
{"candidate": "        if ':' not in self._url:\n            raise ValueError('Missing scheme in request url: %s' % self._url)\n        parsed = urlparse_cached(self)\n        if parsed.scheme not in ('http', 'https'):\n", "entropy": 21.67495231991604}
{"candidate": "        # FIXME: urlparse chokes on some URLs without a scheme\n        if not self._url.lower().startswith('http') and not self._url.startswith('//'):\n", "entropy": 31.249886586232286}
{"candidate": "        if self.url != s:\n            raise ValueError('Invalid %r request url: %r' % (self.encoding, self._url))\n\n        # set scheme if any\n        scheme, netloc, path, params, query, fragment = parse_url(self._url)\n        if not scheme:\n", "entropy": 40.85825550642249}
{"candidate": "        if not s.startswith('http') and not s.startswith('file'):\n", "entropy": 7.805608226883039}
{"candidate": "        if not self._url:\n            raise ValueError('Cannot parse empty url')\n        elif self._url.startswith(('file:', 'http://.', 'https://.')):\n            self._url = escape_ajax(url, self.encoding)\n\n        if not self._url.startswith('http'):\n", "entropy": 50.379098709659594}
{"candidate": "        parsed = urlparse(self._url)\n        if parsed.scheme not in ('http', 'https'):\n", "entropy": 21.169338448267396}
{"candidate": "        if not is_valid_url(self._url):\n            raise ValueError('Invalid url: %s' % self._url)\n\n        scheme, netloc, path, _, _, _ = urlparse_6(self._url)\n        self.path = path\n        if not scheme:\n", "entropy": 26.819268476045934}
{"candidate": "        if not self._url:\n            raise ValueError('Cannot parse empty url')\n        if self._url.startswith('file://') and not self._url.startswith('file:///'):\n            self._url = 'file:///' + self._url[7:]\n        if not self._url.startswith(('http://', 'https://', 'file://')):\n            # When we add get LogRecord", "entropy": 47.6312614156032}
{"candidate": "        if not self._url:\n            raise ValueError('Cannot handle empty url')\n\n        if self._url.startswith('//'):\n            self._url = '%s:%s' % (self.method.lower(), self._url)\n\n        # remove default port numbers:\n        parsed = urlparse_cached(self)\n        if parsed.scheme == 'http' and parsed.port == 80:\n            self._", "entropy": 33.37937905909171}
{"candidate": "        if self._url != s:\n            from scrapy.utils.url import add_or_replace_parameter\n            self._url = add_or_replace_parameter(self._url, '_escaped_fragment_', '')\n\n        if not self.url:\n            raise ValueError('Missing url in %s' % self)\n\n        if self._url != url:\n            from scrapy.utils.url import safe", "entropy": 21.9002538030692}
{"candidate": "        if not is_valid_url(self._url):\n            raise ValueError('Invalid url: %s' % self._url)\n        elif is_url(self._url):\n            netloc = urlparse_cached(self).netloc\n            if netloc:\n                self._url = urlunparse((self.method, netloc, self.url, self.params,\n                                        self.query, self.fragment", "entropy": 30.221382682068434}
{"candidate": "    def _set_body(self, body):\n        if isinstance(body, six.text_type):\n            raise TypeError('Request body must be str or bytes. If you want to pass unicode, use Request.from_unicode().')\n        self._body = to_bytes(body, encoding=self.encoding)\n\n    @classmethod\n    def from_unicode(cls, url, **kwargs):\n        encoding", "entropy": 27.776891885253796}
{"candidate": "        if not self._parsed_url:\n            # Parse the url only once, we couldn't do it earlier because the\n            # urllib3 magic file:// scheme is not supported before\n            self._parsed_url = parse.urlparse(self._url)\n            if self._parsed_url.scheme == 'data':\n                self._encoding = self._parsed_url.path.split(',", "entropy": 65.19106491963316}
{"candidate": "        if not (self._url.startswith('http://') or self._url.startswith('https://')):\n            raise ValueError('Missing scheme in request url: %s' % self._url)\n\n        # set hostname only if it wasn't set before\n        if not self.headers.get('Host'):\n            parsed = urlparse_cached(self)\n            netloc = parsed.netloc\n\n            # remove credentials", "entropy": 37.19976779498402}
{"candidate": "        if hasattr(self, '_encoding') and not hasattr(self, '_original_url'):\n            self._original_url = self._url\n\n        if self._url != s:\n            from scrapy.utils.url import add_or_replace_parameter, url_query_cleaner\n            self._url = url_query_cleaner(add_or_replace_parameter(self._url, '_enc", "entropy": 23.871835378927265}
{"candidate": "        if self._url != s:\n            log.msg(\"Bad URL %r detected - %r, quotes to be escaped: %s\" % (url, self._url,\n                                                                            self._url.count(\"'\")),\n                    level=log.DEBUG)\n\n        if isinstance(self._url, bytes_type):\n            try:\n                self._url = self._url.decode(self.encoding)\n           ", "entropy": 44.3891512241233}
{"candidate": "        # fix url\n        if ':' not in self._url:\n            self._url = '%s://%s' % (self.url_scheme, self.url)\n\n        if self._url != url:\n            self.headers.setdefault('Referer', url)\n\n        if self._url.startswith('//'):\n            self._url = '%s:%s' % (self.url_scheme,", "entropy": 37.938950608172}
