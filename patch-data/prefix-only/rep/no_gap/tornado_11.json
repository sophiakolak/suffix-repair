{"candidate": "        elif headers.get(\"Transfer-Encoding\") == \"chunked\":\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        body = []\n        while content_length > 0:\n            chunk = self._read_bytes(min(content_length, self", "entropy": 15.907705802940901}
{"candidate": "        elif \"Transfer-Encoding\" in headers:\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        \"\"\"Reads a fixed-length body from the socket.\"\"\"\n        if self.request_timeout:\n            deadline = self.io_loop.time() +", "entropy": 16.567589041875294}
{"candidate": "        elif \"Transfer-Encoding\" in headers:\n            if headers[\"Transfer-Encoding\"].lower() != \"chunked\":\n                raise httputil.HTTPInputError(\n                    \"Unknown Transfer-Encoding: %s\" % headers[\"Transfer-Encoding\"])\n            return self._read_chunked_body(delegate)\n        elif self._method in (\"HEAD\",):\n            return self._read_fixed", "entropy": 20.8948973575354}
{"candidate": "        elif headers.get(\"Transfer-Encoding\") == \"chunked\":\n            return self._read_chunked_body(delegate)\n        else:\n            # Read until close.\n            return self._read_body(delegate, True)\n\n    def _read_fixed_body(self, content_length, delegate):\n        \"\"\"Reads a fixed-length body from the stream.\"\"\"\n        assert isinstance(content", "entropy": 20.9851535879804}
{"candidate": "        elif headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\":\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_until_close(delegate)\n\n    def _read_chunked_body(self, delegate):\n        # RFC 2616 section 4.1\n        #   Chunked-Body   = *chunk last-ch", "entropy": 22.925605995723895}
{"candidate": "        elif self._chunked and \"Transfer-Encoding\" in headers:\n            return self._read_chunked_body(delegate)\n        else:\n            raise httputil.HTTPInputError(\"Content-Length or chunked encoding expected\")\n\n    def _read_fixed_body(self, content_length, delegate):\n        \"\"\"Reads a fixed-length body from the stream.\"\"\"\n        if self._chunked", "entropy": 26.75136059875694}
{"candidate": "        elif self._chunked_body:\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body_until_close()\n\n    def _read_body_until_close(self):\n        while True:\n            try:\n                chunk = self._read_chunk()\n            except iostream.StreamClosedError:\n                break\n            if not chunk:", "entropy": 27.3043856339432}
{"candidate": "        elif (self._chunked or\n              headers.get(\"Transfer-Encoding\") == \"chunked\"):\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        \"\"\"Reads a fixed-length body from the stream.\"\"\"\n        body = []\n", "entropy": 27.340826944877193}
{"candidate": "        elif headers.get(\"Transfer-Encoding\") == \"chunked\":\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        if content_length == 0:\n            delegate(\"\", {})\n        else:\n            self._receive_bytes(content_", "entropy": 28.269001020252404}
{"candidate": "        if httputil.is_chunked(headers):\n            return self._read_chunked_body(delegate)\n        if code in (204, 304):\n            return self._read_no_body(delegate)\n        # No Content-Length header provided, so we read the body until the\n        # connection is closed.\n        return self._read_until_close(delegate)\n\n    def _read_fixed", "entropy": 29.907488670264303}
{"candidate": "        elif headers.get(\"Transfer-Encoding\") == \"chunked\":\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body_until_close(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        from types import GeneratorType\n        assert isinstance(content_length, types.IntType)\n        if content_", "entropy": 31.938463899512403}
{"candidate": "\n        if transfer_encoding:\n            try:\n                return self._read_chunked_body(delegate)\n            except iostream.StreamClosedError:\n                raise httputil.HTTPInputError(\"Connection closed\")\n            except iostream.StreamBufferFullError:\n                raise httputil.HTTPInputError(\"Response too large\")\n            except iostream.UnsatisfiableReadError:\n                raise httput", "entropy": 35.7022493998388}
{"candidate": "        elif \"chunked\" in headers.get(\"Transfer-Encoding\", \"\"):\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body_until_close(\n                delegate, self._max_body_size)\n\n    @gen.coroutine\n    def _read_fixed_body(self, content_length, delegate):\n        # Bytes remaining to read in", "entropy": 34.557192316676996}
{"candidate": "        elif \"Transfer-Encoding\" in headers:\n            return self._read_chunked_body(delegate)\n        elif \"Connection\" in headers and headers[\"Connection\"].lower() == \"close\":\n            # Read until close\n            return self._read_body(delegate)\n        elif use_gzip:\n            # Read until close, but attempt to unzip\n            return self._read_body(delegate", "entropy": 36.0163210082903}
{"candidate": "        elif \"Transfer-Encoding\" in headers:\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body(None, None, delegate)\n\n    @property\n    def _should_log(self):\n        return self._log_request or self._log_response\n\n    def _on_request_body(self, data):\n        # type: (bytes) -> None", "entropy": 36.95649449989771}
{"candidate": "\n        if headers.get(\"Transfer-Encoding\") == \"chunked\":\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body_until_close(delegate)\n\n    def _read_headers(self, delegate):\n        \"\"\"Reads HTTP headers from the socket and calls a delegate callback\n        for each header. Returns an httputil.HTTPHeaders object.\n       ", "entropy": 41.630262634218994}
{"candidate": "        if headers.get(\"Transfer-Encoding\") == \"chunked\":\n            return self._read_chunked_body(delegate)\n        return self._read_body_until_close(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        \"\"\"Reads a body of known length for a request.\n\n        This is the most efficient method for reading the body of a\n        response.", "entropy": 39.4562032488242}
{"candidate": "        else:\n            return self._read_body(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        \"\"\"Reads a fixed-length body.\n\n        Should return the body as a string.\n        \"\"\"\n        if content_length == 0:\n            return \"\"\n        if self.request.connection.no_body:\n            return \"\"\n        return self._read_body(delegate,", "entropy": 43.71358235968998}
{"candidate": "        elif headers.get(\"Transfer-Encoding\") == \"chunked\":\n            return self._read_chunked_body(delegate)\n        else:\n            return self._read_body(delegate)\n\n\nclass HTTP1ServerConnection(object):\n    \"\"\"A full HTTP/1 connection from a server to a server.\n\n    This class implements the `.HTTPConnectionDelegate` interface and is\n    compatible with `.HT", "entropy": 50.92226694444889}
{"candidate": "        elif self._chunks:\n            return self._read_chunked_body(delegate)\n        else:\n            # No Content-Length, Transfer-Encoding, or status code that\n            # prohibits bodies. Assume read-until-closed.\n            return self._read_body(delegate)\n\n    def _read_fixed_body(self, content_length, delegate):\n        # Reads a fixed number of bytes", "entropy": 54.811847159850984}
