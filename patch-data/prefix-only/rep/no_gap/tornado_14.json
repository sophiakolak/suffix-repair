{"candidate": "            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        `IOLoop` will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs", "entropy": 2.8052991633948}
{"candidate": "            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        `IOLoop` will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs", "entropy": 2.8052991633948}
{"candidate": "            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        `IOLoop` will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs", "entropy": 2.808649078866399}
{"candidate": "            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        `IOLoop` will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs", "entropy": 2.8130686518100005}
{"candidate": "            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        `IOLoop` will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs", "entropy": 2.8153373413615}
{"candidate": "            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the", "entropy": 3.5938274438437006}
{"candidate": "            self.make_current()\n\n    @classmethod\n    def instance(cls):\n        \"\"\"Returns a global `IOLoop` instance.\n\n        Most applications have a single, global `IOLoop` running on the\n        main thread.  Use this method to get this instance from\n        another thread.  To get the current thread's `IOLoop`, use `current()`.\n        \"\"\"\n        if not hasattr(cls,", "entropy": 6.577480471774897}
{"candidate": "            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the `IOLoop`\n        itself).\n\n        .. versionchanged:: 4.0\n           Added the ``all_fds", "entropy": 9.313556948918}
{"candidate": "            self.make_current()\n\n    @staticmethod\n    def instance():\n        \"\"\"Returns a global `IOLoop` instance.\n\n        Most applications have a single, global `IOLoop` running on the\n        main thread.  Use this method to get this instance from\n\n        A common pattern for classes that depend on `IOLoop`s is to use\n        a default argument to enable programs with multiple `IOLoop`s\n        but", "entropy": 19.073846262909303}
{"candidate": "            self.make_current()\n        self.handlers = {}\n        self.callbacks = []\n        self.timeouts = []\n        self._running = False\n        self._stopped = False\n        self._blocking_signal_threshold = None\n        self.time_func = time.time\n        self.socket_map = {}\n        self.callback_lock = threading.Lock()\n        self.io_loop", "entropy": 19.5704939363305}
{"candidate": "            self.make_current()\n        self._handlers = {}\n        self._events_pending = defaultdict(int)\n        self._callbacks = []\n        self._timeouts = []\n        self._running = False\n        self._stopped = False\n        self._blocking_signal_threshold = None\n        self._timeout_counter = itertools.count()\n        self._thread_ident = None\n        self", "entropy": 20.760435920325694}
{"candidate": "            self.make_current()\n        self._handlers = {}\n        self._callbacks = []\n        self._timeouts = []\n        self._running = False\n        self._stopped = False\n        self._blocking_signal_threshold = None\n        self._timeout_counter = itertools.count()\n        self._thread_ident = threading.current_thread().ident\n        self._blocking_cb = None\n\n", "entropy": 21.390857504910905}
{"candidate": "            self.make_current()\n\n        if len(self._handlers) == 0:\n            self._handlers[self.ERROR] = collections.deque()\n            self._handlers[self.READ] = collections.deque()\n            self._handlers[self.WRITE] = collections.deque()\n\n        if len(self._callbacks) == 0:\n            self._callbacks = collections.deque()\n\n       ", "entropy": 23.77390861723523}
{"candidate": "            self.make_current()\n        self._handlers = {}\n        self._callbacks = []\n        self._timeouts = []\n        self._blocking_signal_threshold = None\n        self._set_signal_handler()\n        self._waker = GreenletWakeUp()\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n       ", "entropy": 25.7235755786919}
{"candidate": "            self.make_current()\n        self.async_handlers = {}\n        self.handlers = {}\n        self.callbacks = []\n        self.timeouts = []\n\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n        self.waker = self.socket_pipe()\n        self.socket_handlers = {}\n\n        # Create and", "entropy": 27.8754514380125}
{"candidate": "            self.make_current()\n        self.handlers = {}\n        self.timeouts = []\n        self._callbacks = []\n        self._scheduled = []\n        self._stopped_event = None\n        self.__callback_lock = threading.Lock()\n        self.__timeouts_lock = threading.Lock()\n\n    def close(self, all_fds=False):\n        with self.__", "entropy": 29.08700847350793}
{"candidate": "            self.make_current()\n        log_msg = (\"%s starting up\" %\n                   self.__class__.__name__)\n        if self._stopped:\n            log_msg += \" (cleaned up)\"\n        gen_log.info(log_msg)\n\n    _POLL_TIMEOUT = 3600.0\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `I", "entropy": 32.522043933842106}
{"candidate": "            self.make_current()\n        self._handlers = {}\n        self._events = {}\n        self._callbacks = []\n        self._timeouts = []\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n        self._waker = self._impl_init()\n        # Create a socket pair for the *add_callback* thread to wake us up", "entropy": 35.0735575387273}
{"candidate": "            self.make_current()\n\n        # Create a file descriptor for the IOLoop's control socket\n        rfd, wfd = socket.socketpair()\n        rfd.setblocking(False)\n        wfd.setblocking(False)\n        self._waker = _Waker()\n        self._waker.attach(rfd, rfd.fileno())\n\n        # The IOLoop takes ownership of the socket's file descriptor", "entropy": 38.04579070588607}
{"candidate": "            self.make_current()\n\n        old_handler = signal.getsignal(signal.SIGINT)\n        old_handler = dict([(k, signal.getsignal(k))\n                            for k in [signal.SIGTERM, signal.SIGQUIT,\n                                      signal.SIGTSTP]])\n        signal.signal(signal.SIGINT, self._handle_signal", "entropy": 40.57615857481381}
