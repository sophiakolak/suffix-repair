{"candidate": "            for exe in shell.all_executables()]\n    return set(tf_entry_points + tf_alias + bins)\n\n\ndef get_alias():\n    try:\n        with open(os.devnull, 'w') as null:\n            alias = subprocess.check_output(['alias'], stderr=null)\n    except (OSError, subprocess.CalledProcessError):\n        return []\n", "entropy": 30.712270625667006}
{"candidate": "            for exe in pkg_resources.iter_entry_points(group='console_scripts')]\n    aliases = _safe(lambda: shell.get_aliases(), [])\n    functions = _safe(lambda: shell.get_functions(), {})\n    return (set([tf_alias] + tf_entry_points + bins + list(aliases.keys()) +\n                list(functions.keys())))\n\n\ndef", "entropy": 33.90557808115401}
{"candidate": "            for exe in _safe(lambda: shell.get_all_processes(), [])]\n\n    envs = [exe.encode('utf8') if six.PY2 else exe\n            for exe in _safe(lambda: os.environ.get('PATH', '').split(':'),\n                             [])]\n\n    exes = (tf_alias + tf_entry_points + bins + envs +\n", "entropy": 36.364987242648006}
{"candidate": "            for exe in _safe(lambda: shell.get_all_executables(), [])\n            if exe.name != 'thefuck']\n    aliases = _safe(lambda: list(tf_alias.keys()), [])\n\n    return bins + tf_entry_points + aliases\n\n\n@memoize\ndef get_aliases():\n    from thefuck.shells import shell\n    from thefuck.utils import wrap_", "entropy": 37.543354891042}
{"candidate": "            for exe in _safe(lambda: list(pkg_resources.iter_entry_points('console_scripts')), [])\n            if exe.name in tf_entry_points or exe.name.startswith('thefuck_')]\n\n    aliases = _safe(lambda: shell.get_aliases(), [])\n    aliases_py2 = [a.decode('utf8') for a in aliases] if six.", "entropy": 40.775782406102024}
{"candidate": "            for exe in _safe(lambda: list(pkg_resources.iter_entry_points('console_scripts')), [])]\n    shells_bins = _safe(lambda: shell.get_all_executables(), [])\n    paths_bins = _safe(lambda: list(os.listdir(os.environ[\"PATH\"])), [])\n    return (set(bins) | set(tf_entry_", "entropy": 40.90072000098798}
{"candidate": "            for exe in get_executables()]\n    aliases = _safe(tf_alias, [])\n    return list(set(tf_entry_points + bins + aliases))\n\n\n@memoize\ndef get_all_available_rules():\n    \"\"\"Returns a set of all available rules.\"\"\"\n    return set(rule.rule_name for rule in get_all_rules())\n\n\n@memoize\ndef get_", "entropy": 41.566911156198984}
{"candidate": "            for exe in shell.all_shells[shell.get_key()].bin_dirs]\n\n    return set(tf_alias + tf_entry_points +\n               _safe(shell.get_aliases, []) +\n               _safe(lambda: os.environ.get('PATH').split(':'), []) +\n               _safe(lambda: os.environ.get('PATHEXT').strip(';').split", "entropy": 41.61273148506799}
{"candidate": "            for exe in _safe(lambda: shell.which_bin(tf_alias), [])]\n    bins += [path\n             for path in _safe(lambda: shell.get_all_executables(), [])\n             if path.endswith('fuck') or path.endswith('thefuck')]\n    bins += [match for match in _safe(lambda: shell.get_all_cmd_aliases(), [", "entropy": 44.87948538898952}
{"candidate": "            for exe in shell.get_all_executables()]\n    return tf_entry_points + _safe(lambda: tf_alias.keys(), []) + bins\n\n\n@memoize\ndef get_alias():\n    return {alias: _get_alias_target(alias)\n            for alias in _get_all_aliases()}\n\n\ndef _get_all_aliases():\n    return get_all_", "entropy": 44.880918413554994}
{"candidate": "            for exe in shell.get_executables()\n            if tf_alias not in exe.name.lower() and\n               tf_entry_points not in exe.name.lower()]\n\n    return _safe(lambda: bins + tf_entry_points, bins)\n\n\n@memoize\ndef get_all_rules():\n    from thefuck.rules import (\n        rules, no_colon_rules, suffix", "entropy": 47.504115026667016}
{"candidate": "            for exe in _safe(_get_all_executables, [])\n            if exe.name not in tf_entry_points]\n\n    return set(tf_entry_points + tf_alias + bins)\n\n\n@memoize\ndef get_all_installed_packages():\n    from thefuck.shells import shell\n\n    return set(shell.and_('brew list', 'pip list'))\n\n\ndef get", "entropy": 47.85024377961598}
{"candidate": "            for exe in pkg_resources.iter_entry_points('console_scripts')]\n    if tf_alias:\n        tf_entry_points.append(tf_alias)\n    return _safe(shell.get_all_executables, []) + bins + tf_entry_points + [\n        'fuckit', 'tf', 'fc'] + which_app('fuck')\n\n\n@memoize\ndef which_", "entropy": 48.995729157698}
{"candidate": "            for exe in distutils.spawn.find_executable_iter(tf_entry_points)]\n    return (\n        tf_alias +\n        _safe(get_all_paths, []) +\n        _safe(lambda: shell.get_all_commands(), []) +\n        _safe(lambda: shell.get_all_aliases(), []) +\n        bins +\n        ['sudo']\n    )\n\n", "entropy": 50.78941452493479}
{"candidate": "            for exe in iter_entry_points('console_scripts')]\n    bins.extend(tf_alias + tf_entry_points)\n    bins.extend(shell.get_all_executables())\n    bins = list(set(bins))\n\n    # On OSX `/usr/bin` placed after `/usr/local/bin` in $PATH,\n    # so `brew install name` will override system", "entropy": 53.91393600846553}
{"candidate": "            for exe in shell.get_all_executables()\n            if exe.name not in tf_entry_points\n            if ('thefuck' not in exe.path and\n                exe.path not in tf_entry_points and\n                not tf_alias in exe.path and\n                'fuck' not in exe.path)]\n    return list(set(\n        _safe(lambda: subprocess.check", "entropy": 56.77410888936901}
{"candidate": "            for exe in shell.path]\n\n    if tf_alias:\n        bins.append(tf_alias)\n\n    tf_entry_points.extend(_safe(lambda: [ep.name\n                                          for ep in entry_points], []))\n\n    return sorted(set(tf_entry_points + bins))\n\n\ndef get_all_commands():\n    commands = set()\n\n    for entry_point in pkg_", "entropy": 59.107693008139016}
{"candidate": "            for exe in tf_entry_points + tf_alias]\n    paths = shell.get_all_path_dirs() or []\n    exes = set(exe for p in paths for exe in _safe(lambda: os.listdir(p), []))\n    return bins + [x for x in exes if x not in bins]\n\n\ndef escape(cmd):\n    \"\"\"Escapes bash special characters.\"\"\"\n   ", "entropy": 59.37771113100438}
{"candidate": "            for exe in shell.get_app_dirs()\n            if exe.name not in tf_entry_points]\n    bins = _safe(lambda: shell.which_app('py3'), []) + bins\n    if tf_alias:\n        bins = [tf_alias] + bins\n    return sorted(set(bins))\n\n\ndef get_rule_name(rule):\n    \"\"\"Returns name for rule-function", "entropy": 69.14209435987499}
{"candidate": "            for exe in _safe(AvailableBins.get, [])\n            if not exe.name.startswith(get_alias())]\n\n    tf_entry_points = [ep for ep in tf_entry_points\n                       if ep not in bins]\n\n    syms = _safe(Syms.get, [])\n    shells = _safe(Shells.get, [])\n\n    return sorted(bins + shells +", "entropy": 75.33251945796799}
