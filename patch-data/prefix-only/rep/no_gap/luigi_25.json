{"candidate": "        if len(self.columns[0]) == 1:\n            # only names of columns specified, no types\n            self.columns = self.columns_from_desc(self.table)\n        elif len(self.columns[0]) == 2:\n            # if columns is specified as (name, type) tuples\n            pass\n        else:\n            raise Exception(\"columns should be either a list of \"\n                           ", "entropy": 29.50264682136902}
{"candidate": "        if isinstance(self.source_table, BaseOperator):\n            source_table = self.source_table.table\n        else:\n            source_table = self.source_table\n\n        if isinstance(self.target_table, BaseOperator):\n            target_table = self.target_table.table\n        else:\n            target_table = self.target_table\n\n        if not (source_table and target_table):", "entropy": 29.924661550127006}
{"candidate": "        if not (self.columns):\n            raise Exception(\"columns need to be specified\")\n\n        connection = self.output().connect()\n        if not self.table_exists(connection):\n            self.log.info(\"Creating table %s\" % self.table)\n            if not isinstance(self.columns[0], (tuple, list)):\n                raise Exception(\"columns need to be specified as (name, type)", "entropy": 34.53617361509}
{"candidate": "        if not (self.columns):\n            raise Exception(\"columns need to be specified\")\n\n        self.log.info('Extracting data from %s', self.sql)\n\n        if not self.target_table_exists():\n            self.log.info('Creating table %s', self.table)\n            self.create_table()\n\n        self.log.info('Copying data to %s in batches of %s',\n", "entropy": 44.844207035839986}
{"candidate": "        if not self.table_exists(self.table):\n            self.log.info(\"Table %s does not exist, creating it\", self.table)\n            connection = self.output().connect()\n            with connection.cursor() as cursor:\n                self.create_table(cursor)\n                self.output().commit()\n\n        super(PostgresCreateTableOperator, self).run(**self.kwargs)", "entropy": 45.34706238380002}
{"candidate": "        if self.first_run_time:\n            self.first_run()\n\n        if self.table_exists():\n            self.log.info(\"Table {table} already exists.\".format(\n                table=self.table))\n        else:\n            self.log.info(\"Creating table: {table}\".format(\n                table=self.table))\n            self.create_table(self.table)\n\n        self.insert", "entropy": 46.26183557215002}
{"candidate": "        connection = self.output().connect()\n        if not (self.check_table_exists(connection)):\n            self.logger.debug(\"Creating table: %s\", self.table)\n            self.create_table(connection)\n\n        connection.commit()\n        connection.close()\n\n    def insert_query(self, connection, records):\n        pass\n\n    def insert_records(self, connection, records):\n        if", "entropy": 47.70874735005998}
{"candidate": "        self.log.info('PrestoToMySqlOperator: start')\n\n        with create_engine(self.mysql_conn_id).connect() as connection:\n            self.log.info('Checking if destination table exists...')\n\n            if not check_table_exists(self.table, connection):\n                self.log.info(\"Creating destination table...\")\n                try:\n                    self.create_table(connection)", "entropy": 50.39369516430901}
{"candidate": "        connection = self.output().connect()\n        connection.execute('SET search_path TO %s, public', (self.schema, ))\n        if not self.has_table(connection):\n            self.create_table(connection)\n            self.row_count = 0\n        else:\n            self.log.info(\"Output table (%s) already exists\", self.table)\n            self.row_count = self.count_rows", "entropy": 52.35339789818798}
{"candidate": "        cursor = self.connection.cursor()\n\n        if self.create_table_if_not_exist:\n            try:\n                # If a table already exists, it won't raise an error\n                self.create_table(self.connection)\n            except Exception as e:\n                self.log.error(\"Failed to create table %s: %s\",\n                               self.table, str(e))\n                raise e\n\n        if", "entropy": 54.207837779128}
{"candidate": "        connection = self.output().connect()\n        try:\n            with connection.cursor() as cursor:\n                cursor.execute(\"SELECT * FROM {table} LIMIT 1;\".format(\n                    table=self.table))\n        except:\n            self.create_table(connection)\n        connection.close()\n\n\nclass SQLQuery2PostgreSQLTask(SQLQuery2TableTask):\n    \"\"\"\n    This task takes a sql query, executes", "entropy": 57.382442537821}
{"candidate": "        if not self.check_table_exists():\n            self.create_table(self.output().connecti", "entropy": 19.285333014100004}
{"candidate": "        if (not self.table_exists()) and self.create:\n            self.create_table(self.output().connecti", "entropy": 19.4501370827}
{"candidate": "        for i in range(self.num_tries):\n            try:\n                self.log.info(\"5:Checking if table %s exists\", self.table)\n                self.table_exists = self.check_for_table()\n\n                # if the table doesn't exist, create it\n                if not self.table_exists:\n                    self.log.info(\"Creating table %s\", self.table)\n                    self.", "entropy": 62.493889245490976}
{"candidate": "        cursor = self.connection.cursor()\n        if not self.table_exists():\n            self.create_table(self.connection)\n\n        if not self.columns:\n            # If columns are not defined, use all columns from\n            # the source table\n            self.columns = self.get_columns()\n\n        self.transfer_data(cursor)\n        self.connection.commit()\n\n\nclass Dimension(Post", "entropy": 62.536851292282}
{"candidate": "        with get_connection(self.connection) as connection:\n            with closing(connection.cursor()) as cursor:\n                if (not table_exists(cursor, self.table)):\n                    self.create_table(connection)\n                for success, info in super(SqlPlugin, self).run():\n                    yield success, info\n\n    def table_attributes(self):\n        \"\"\"\n        Can be overridden to return table attributes", "entropy": 66.092729093826}
{"candidate": "        connection = self.output().connect()\n        if not self.table_exists(connection):\n            self.create_table(connection)\n\n        rows = self.rows()\n        if hasattr(rows, '__iter__'):\n            # Trick to support both list of rows and SQL query as input\n            try:\n                rows[0][0]\n            except TypeError:\n                pass\n            except IndexError:\n                msg =", "entropy": 70.04546958654002}
{"candidate": "        if 'insert' in self.mode:\n            conn = sqlite3.connect(self.db)\n            if 'insert' in self.mode:\n                if not self.table_exists(conn):\n                    self.create_table(conn)\n\n            with conn:\n                c = conn.cursor()\n                c.execute(\"delete from \" + self.table)\n                c.execute('PRAGMA journal_mode = MEM", "entropy": 70.19088390973397}
{"candidate": "        connection = self.output().connect()\n        if not self.check_table_exists(connection):\n            self.create_table(connection)\n\n        connection.commit()\n        connection.close()\n\n\nclass PostgresToPostgresLoadTask(PostgresIncrementalLoadTask):\n    \"\"\"\n    A task that loads a source 'pg_table' into a target 'pg_table'.\n    \"\"\"\n    host = luigi.Parameter", "entropy": 70.919534717638}
{"candidate": "        if self.connection != 'auto':\n            # Use the provided connection object\n            conn = self.connection\n        else:\n            # Connect to the default database\n            conn = default_db().connect()\n\n        if not self.is_table_exist(conn):\n            # create the table\n            self.create_table(conn)\n\n        return super(InsertTableOperator, self).run(conn)\n\n\nclass HiveOperator(Base", "entropy": 73.88148408299}
