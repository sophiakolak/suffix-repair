{"candidate": "        return rs\n\n    def _agg_by_level(self, name, axis=0, level=0, skipna=True, **kwargs):\n        grouped = self.groupby(level=level, axis=axis)\n        if hasattr(grouped, name) and skipna:\n            return getattr(grouped, name)(**kwargs)\n        axis = self._get_axis_number(axis)\n        method =", "entropy": 7.451705663498999}
{"candidate": "        return rs\n\n    @Substitution(**_shared_doc_kwargs)\n    @Appender(_shared_docs[\"pct_change\"] % _shared_doc_kwargs)\n    def pct_change(self, periods=1, fill_method=\"pad\", limit=None, freq=None, **kwargs):\n        axis = self._get_axis_number(kwargs.pop(\"axis\", self._stat_", "entropy": 9.093081723436502}
{"candidate": "        return self._constructor(rs).__finalize__(self)\n\n    def cumprod(self, axis=None, skipna=True, *args, **kwargs):\n        \"\"\"\n        Return cumulative product over requested axis.\n\n        Parameters\n        ----------\n        axis : {0 or 'index', 1 or 'columns'}, default 0\n            Axis for the function to be applied on.\n        skipna : bool, default True", "entropy": 14.119254005388902}
{"candidate": "        if freq is not None:\n            return rs.shift(periods=1, freq=-freq, axis=axis)\n        else:\n            return rs\n\n    def _flex_comp_method(self, other, func, level=None, fill_value=None, axis=0):\n        # Validate the axis parameter\n        if axis is not None:\n            axis = self._get_axis_number(axis)\n\n", "entropy": 21.68875678567174}
{"candidate": "        rs = rs.iloc[1:]\n\n        if axis == 1:\n            rs.columns = self.columns\n        return rs\n\n    def shift(self, periods=1, freq=None, axis=0, fill_value=None):\n        \"\"\"\n        Shift index by desired number of periods with an optional time freq\n\n        Parameters\n        ----------\n        periods : int\n            Number of periods to move, can be positive", "entropy": 23.51312964278852}
{"candidate": "        if freq is None:\n            mask = isna(rs.iloc[0])\n            if mask.any():\n                rs.iloc[0][mask] = 0\n\n        return self._constructor(rs, **self._construct_axes_dict())\n\n    _shared_docs[\n        \"tshift\"\n    ] = \"\"\"\n        Shift the time index, using the index's frequency if available.\n\n        Parameters\n       ", "entropy": 24.116331300018146}
{"candidate": "        if freq is not None:\n            rs = rs.shift(periods=1, freq=freq, axis=axis)\n        return rs\n\n    def pipe(self, func, *args, **kwargs):\n        \"\"\"\n        Apply func(self, \\*args, \\*\\*kwargs)\n\n        Args:\n            func: function to apply to the Series/DataFrame\n            args: arguments passed into func.", "entropy": 24.547914426388637}
{"candidate": "        if freq:\n            return rs.shift(freq=freq, periods=-periods, axis=axis)\n        else:\n            return rs\n\n    # ----------------------------------------------------------------------\n    # Function application\n\n    @Substitution(klass=\"DataFrame\")\n    @Appender(_shared_docs[\"transform\"])\n    def transform(self, func, axis=0, *args, **kwargs):\n        axis = self._get_", "entropy": 25.500323857510935}
{"candidate": "        if freq is None:\n            mask = notna(self.shift(periods=periods, axis=axis, **kwargs))\n        else:\n            mask = notna(data.shift(periods=periods, freq=freq, axis=axis, **kwargs))\n        return rs.where(mask)\n\n    # ----------------------------------------------------------------------\n    # Rolling statistics\n\n    @Substitution(\n        versionadded=\"\\", "entropy": 26.469153101267942}
{"candidate": "        return self._constructor(rs).__finalize__(self)\n\n    # ----------------------------------------------------------------------\n    # Cumulative Methods\n\n    @Substitution(name=\"DataFrame\", func_name=\"cumsum\")\n    @Appender(_doc_template)\n    def cumsum(self, axis=None, skipna=True, **kwargs):\n        nv.validate_cumsum(tuple(), kwargs)\n", "entropy": 27.09653065919271}
{"candidate": "        return rs\n\n    @Appender(\n        _shared_docs[\"count\"]\n        % dict(\n            axis=_shared_doc_kwargs[\"axis\"],\n            versionadded=\"\",\n            klass=\"DataFrame\",\n            optional_count=\"\",\n        )\n    )\n    def count(self, axis=0, level=None, numeric_only=False):\n        return super().count(axis=axis, level=level", "entropy": 28.397874957968497}
{"candidate": "        if freq is not None:\n            rs = rs.shift(-periods, freq=freq, axis=axis, **kwargs)\n        return rs\n\n    @Substitution(\n        shortname=\"expanding\",\n        desc=\"Returns the expanding mean of a dataframe or series over requested axis.\",\n    )\n    @Appender(_shared_docs[\"expanding\"])\n    def expanding(self, min_periods=", "entropy": 36.41845198869974}
{"candidate": "        rs = rs.replace([np.inf, -np.inf], np.nan)\n        return rs.__finalize__(self)\n\n    def cummax(self, axis=None, *args, **kwargs):\n        nv.validate_cummax(args, kwargs)\n\n        nv.validate_min_periods(kwargs.pop(\"min_periods\", 1))\n        return self.exp", "entropy": 38.30615844114377}
{"candidate": "        if freq is None:\n\n            # Pad periods when freq is not specified\n            rs = rs.fillna(0)\n        return rs\n\n    def shift(self, periods=1, freq=None, axis=0, fill_value=None):\n        \"\"\"\n        Specialized shift which takes an axis argument\n        \"\"\"\n        axis = self._get_axis_number(axis)\n\n        if freq:\n            return self", "entropy": 44.112693534056525}
{"candidate": "\n        if freq is not None:\n            # GH 31264\n            rs.index = rs.index._with_freq(None)\n        return rs\n\n    def cumprod(self, axis=0, skipna=True, *args, **kwargs):\n        \"\"\"\n        Return cumulative product over requested axis as Series.\n\n        Parameters\n        ----------\n        axis: self._stat_axis_number, default 0\n        skipna", "entropy": 49.85134757246363}
{"candidate": "        if freq is not None and not is_timedelta64_dtype(rs):\n            rs.index = shifts(rs.index, freq)\n        return rs\n\n    # ----------------------------------------------------------------------\n    # Function application\n\n    @Substitution(name=\"apply\", versionadded=\"\\n.. versionadded:: 0.20.0\")\n    @Appender(\n        _shared_docs[\"apply\"]\n        % dict(\n            k", "entropy": 47.85301386560244}
{"candidate": "        rs = rs.fillna(value=np.nan)  # GH 11343\n        return rs\n\n    # ----------------------------------------------------------------------\n    # Rolling moments, window functions\n\n    def _create_window(self, window, min_periods=None, center=False, win_type=None, axis=0, closed=None):\n        \"\"\"Create the window for a rolling/expanding calculation\n\n        Returns\n        -------\n        Window or Expanding subclass", "entropy": 49.36714817273852}
{"candidate": "        rs = rs.fillna(0)\n        return self._apply_cleanup_fill(rs, fill_method, limit, axis=axis)\n\n    # ----------------------------------------------------------------------\n    # Rolling Methods\n\n    def _create_window(self, window, axis=0):\n        \"\"\"Create the rolling window.\n\n        Parameters\n        ----------\n        window : int, offset, or BaseIndexer subclass\n            The size of the moving window. This is", "entropy": 52.10104740857799}
{"candidate": "        if freq and not periods:\n            return rs\n        return rs.divide(periods)\n\n    # ----------------------------------------------------------------------\n    # Mapping Methods\n\n    @Appender(generic._shared_docs[\"map\"])\n    def map(\n        self, mapper, na_action=None, subset=None, validate=None, errors=\"raise\"\n    ):\n        return self._apply_series_op(\n            self._constructor", "entropy": 57.12647249091526}
{"candidate": "        if freq is not None:\n            index = self._get_axis(axis)\n            if isinstance(index, (PeriodIndex, DatetimeIndex)):\n                if periods > 0:\n                    first_unused = min(self.shape[axis] - periods, len(index))\n                    first_index = index[first_unused]\n                    index = index[:first_unused]\n                else:\n                    first", "entropy": 60.640431827863445}
