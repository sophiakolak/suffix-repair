{"candidate": "                    except (TypeError, ValueError):\n                        # Cast back failed\n                        pass\n\n                result = make_block(\n                    result, placement=block.mgr_locs, klass=block.__class__\n                )\n                new_blocks.append(result)\n\n        if len(new_blocks) < len(blocks):\n            new_blocks = _extend_blocks(new_blocks, self._blknos, self._", "entropy": 41.594208236453}
{"candidate": "                    except ValueError:\n                        # But it wasn't feasible\n                        pass\n\n                if isinstance(result, np.ndarray) and result.ndim == 1:\n                    result = result.reshape(1, -1)\n\n                assert (\n                    isinstance(result, np.ndarray)\n                    and result.shape == block.shape\n                    or result is no_result\n                    or isinstance(result, ABCIndexClass)\n                   ", "entropy": 43.89893263543299}
{"candidate": "                    except TypeError:\n                        # Can't cast, so just leave it as ndarray[object]\n                        pass\n                if new_items is None:\n                    new_items = locs\n                    new_blocks = [result]\n                else:\n                    new_items = new_items.append(locs)\n                    new_blocks.append(result)\n\n        new_blocks = self._consolidate_blocks(new_items,", "entropy": 46.80819293667001}
{"candidate": "                    except TypeError:\n                        pass\n\n                if isinstance(result, ExtensionArray):\n                    rvalues = ExtensionBlock.make_block(result, ndim=result.ndim)\n                    assert rvalues.shape == block.shape\n                elif isinstance(result, np.ndarray):\n                    assert result.ndim == 1 or result.shape[0] == 1\n                    rvalues = NumpyBlock(result, ndim=result", "entropy": 52.95265227487202}
{"candidate": "                    except ValueError:\n                        # If not, keep as array\n                        pass\n\n                # unbox if needed\n                if (\n                    isinstance(result, np.ndarray)\n                    and not is_extension_array_dtype(result.dtype)\n                    and result.ndim == 2\n                    and result.shape[0] == 1\n                ):\n                    result = result[0]\n\n                # may need to coerce back", "entropy": 55.69369185945441}
{"candidate": "                    except (ValueError, TypeError):\n                        pass\n\n                if not isinstance(result, type(block.values)) and (\n                    result.dtype != block.dtype\n                ):\n                    # if we are different, then need to explicitly\n                    # astype\n                    result = result.astype(block.dtype)\n\n                newb = make_block(result, placement=block.mgr_locs)\n                newblocks", "entropy": 55.86636966558531}
{"candidate": "                    except Exception:\n                        pass\n\n                if isinstance(result, Series):\n                    result = result._values\n\n                if isinstance(result, np.ndarray):\n                    if result.shape == (1, 1):\n                        # Likely a Series or scalar\n                        try:\n                            result = result[0]\n                        except IndexError:  # pragma: no cover\n                            pass\n\n                if isinstance(result, ExtensionBlock):", "entropy": 66.23706206886702}
{"candidate": "                    except TypeError:\n                        pass\n\n        except Exception:\n            # catch any exception, since we want to always continue applying\n            # this function to the rest of the blocks\n            if isinstance(locs, slice):\n                locs = np.arange(s.shape[self.axis])[locs]\n            deleted_items.append(locs)\n\n        return result, split_items, split_frames\n\n    def _apply", "entropy": 67.310647887787}
{"candidate": "                    except (TypeError, ValueError):\n                        # casting failed, use ndarray\n                        pass\n\n                # we have a new item here\n                new_values.append(result)\n                new_locs.append(locs)\n                new_items.append(items)\n\n        if new_values:\n            new_blocks = [make_block(values, nindex, nindex, klass=new_blocks[0].__", "entropy": 70.63738966284902}
{"candidate": "                    except TypeError:\n                        if result.ndim != 1:\n                            # Convert to ndarray[object]\n                            result = np.asarray(result)\n\n                # reshape for consistency\n                if result.ndim == 1:\n                    result = result.reshape(1, len(result))\n\n                assert result.shape[0] == 1\n\n                # 0d results should be returned as scalars\n                if result.", "entropy": 70.70960754521899}
{"candidate": "                    except TypeError:\n                        # Returning ndarray[object] from a block with\n                        #  a different dtype is OK too.\n                        pass\n\n                values.append(result)\n\n            else:\n                # exclude the block\n                deleted_items.append(locs)\n\n        if len(deleted_items) == len(self.blocks):\n            return no_result\n\n        # delete excluded items\n        new_blocks = self", "entropy": 71.414280456707}
{"candidate": "                    except TypeError:\n                        # Cast failed\n                        pass\n\n                # we might have a non-reduction here (e.g. a.sum(axis=1))\n                # we need to re-shape\n                if is_scalar(result):\n                    result = np.atleast_2d(result)\n                    result = result.T\n\n                # Put the result in the correct shape.\n                if result.ndim ==", "entropy": 77.30758925859254}
{"candidate": "                    except (TypeError, ValueError):\n                        # result may be object dtype\n                        # or a string dtype with different length strings\n                        result = result.ravel()\n\n                new_values.append(result)\n\n        # create a new set of blocks\n        new_blocks: List[Block] = []\n        for result, blk in zip(new_values, self.blocks):\n            shape = result.shape\n            if not is", "entropy": 77.51334945718096}
{"candidate": "                    except TypeError:\n                        # Ensure that we return a single block.\n                        # This can happen e.g. if the Categorical has\n                        # a different categories ordering.\n                        result = no_result\n                elif block.is_extension and isinstance(result, ABCSeries):\n                    # e.g. block.values was an IntegerArray\n                    #  and result is a Series\n                    if not isinstance(result, type", "entropy": 83.16795154061401}
{"candidate": "                    except (ValueError, TypeError):\n                        # What can we do? :shrug:\n                        pass\n\n                # we have a non-reduction, so create a new block of an\n                # appropriately sized array.\n                newb = make_block(result, locs)\n                results_blocks.append(newb)\n            else:\n                deleted_items.append(locs)\n\n        if len(results_blocks) ==", "entropy": 89.11698107254303}
{"candidate": "                    except (TypeError, ValueError):\n                        pass  # leave as ndarray[object]\n\n                # we want to try to preserve our subclass\n                # if possible\n                if isinstance(result, partial) and is_array_like(block.values):\n                    result = type(block.values)(result)\n\n                # replace the original values\n                values[tuple(locs)] = result\n\n            if (\n                not block.", "entropy": 89.85538514604603}
{"candidate": "                    except ValueError:\n                        # result contains results that cannot be coerced back\n                        # to the original type, e.g. alt([[True, False],\n                        # [False, False]])\n                        pass\n\n                if result is not no_result:\n                    if result.shape != block.values.shape:\n                        # we maybe have an object type block here\n                        # just create a new block and hope for the best\n                        # as this", "entropy": 98.260747616424}
{"candidate": "                    except TypeError:\n                        # In this case, we're done - we can't cast back to the original\n                        #  type. The input array was an ExtensionArray, and the output\n                        #  array is not compatible with it.\n                        #  Just give up and return np.ndarray[object]\n                        pass\n\n                if isinstance(result, np.ndarray) and result.ndim != 1:\n                    # We're done,", "entropy": 99.63900182179003}
{"candidate": "                    except Exception:\n                        # If that doesn't work, just leave it as-is\n                        pass\n\n            # consolidate duplicates that have the same result\n            # (e.g., share the same \"no_result\" object)\n            duplicated = dedup_locs(results, result)\n            result_keys = results.keys()\n            for k in reversed(duplicated):\n                del results[result_keys[k]]\n\n", "entropy": 104.22523789154}
{"candidate": "                        result = result.values\n                    except ValueError:\n                        # We are probably dealing with a Categorical resulting from\n                        # a numpy aggregation\n                        pass\n\n                if isinstance(result, np.ndarray):\n                    # coerce to single block output\n                    result = result.reshape(1, -1)\n\n                # If we reach here and the result is no_result, then it's a\n                #  no_result with", "entropy": 104.34897602481848}
