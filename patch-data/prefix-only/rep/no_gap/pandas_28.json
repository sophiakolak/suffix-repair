{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[col] for col in others]\n        elif isinstance(others, np.ndarray):\n            if others.ndim > 1:\n                raise TypeError(\"Can only append a Series if ignore_index=True\")\n            return [Series(others, index=idx)]\n", "entropy": 19.265455448315002}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, ABCDataFrame):\n            return [Series(col, index=idx) for col in others]\n        elif isinstance(others, np.ndarray):\n            if others.ndim > 1:\n                raise ValueError(\"Only 1D arrays are allowed here.\")\n            return [Series(others, index=idx)]\n", "entropy": 23.490094634489804}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, ABCDataFrame):\n            return [Series(others.loc[idx], index=idx)]\n        elif isinstance(others, (list, tuple, np.ndarray)):\n            if len(others) == 0:\n                return []\n            elif len(others) != len(idx):\n               ", "entropy": 24.83148192129149}
{"candidate": "            return [Series(others, index=idx)._values]\n        elif isinstance(others, DataFrame):\n            return [others[c]._values for c in others]\n        elif isinstance(others, np.ndarray) and others.ndim == 2:\n            others = [others[:, i] for i in range(others.shape[1])]\n        elif isinstance(", "entropy": 25.871249676795003}
{"candidate": "            return [Series(others, index=idx, name=others.name)]\n        elif isinstance(others, (ABCDataFrame, np.ndarray)):\n            if others.ndim != 2:\n                raise ValueError(\"`others` must be DataFrame or 2-dim ndarray\")\n            return [\n                Series(others.iloc[:, i], index=idx, name=others", "entropy": 26.781052280494205}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, ABCDataFrame):\n            return [others[c] for c in others]\n        elif (\n            is_list_like(others)\n            and not isinstance(others, str)\n            and all(isinstance(other, (str, np.ndarray, ABCDataFrame)) for other in others)\n        ):", "entropy": 29.85108854862399}
{"candidate": "            if others.shape != idx.shape:\n                raise ValueError(\n                    \"All inputs without indexes must match length of self.\"\n                )\n            return [others._to_embed(self._orig.dtype)]\n        elif isinstance(others, (ABCDataFrame, list, tuple, np.ndarray)):\n            if isinstance(others, ABCDataFrame):\n                others = others.columns\n           ", "entropy": 30.449948585809}
{"candidate": "            return [Series(others, index=idx, dtype=idx.dtype)]\n        elif isinstance(others, DataFrame):\n            return [others[c] for c in others]\n        else:\n            if is_scalar(others):\n                others = [others] * len(idx)\n            else:\n                others = list(others)\n            if len(others", "entropy": 32.47314862845149}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, DataFrame):\n            raise TypeError('\"others\" must be a Series, Index or list-like')\n        elif isinstance(others, np.ndarray):\n            if others.ndim == 0:\n                others = others.dtype.type(others)\n            elif others.ndim == 2:\n               ", "entropy": 33.58759077320801}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, (ABCDataFrame, list)):\n            return [\n                Series(others[i], index=idx)\n                for i in range(len(others))\n                if is_list_like(others[i])\n            ]\n        elif isinstance(others, Iterator):\n            it = others\n        else", "entropy": 35.92472564698199}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, ABCDataFrame):\n            return [others.iloc[:, i] for i in range(len(others.columns))]\n        else:\n            if is_list_like(others) and not len(others):\n                # If the input is an empty list-like, raise an empty Series\n                # exception (", "entropy": 47.398476493896204}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, DataFrame):\n            # DataFrame.to_series() always creates a series with an index.\n            return [s.reindex_like(idx) for s in others.to_series()]\n        elif hasattr(others, \"ndim\") and others.ndim == 2:\n            # Must be an ndarray", "entropy": 49.245556488190495}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, np.ndarray):\n            if others.ndim > 1:\n                raise TypeError(\"array should have 1 dimension\")\n            return [Series(list(others), index=idx, copy=False)]\n        elif isinstance(others, list) or is_list_like(others):\n            # The following is n", "entropy": 50.607059878989695}
{"candidate": "            others = Series(others.values, index=others)\n            return [others]\n        elif isinstance(others, ABCDataFrame):\n            return others.T._series_list()\n        elif isinstance(others, (np.ndarray, ABCIndexClass, list)):\n            # ndarray/list-like: no index available\n            others = Series(others, index=idx)", "entropy": 52.416350901503435}
{"candidate": "            return [Series(others, index=idx)]\n        elif isinstance(others, DataFrame):\n            # TODO Should we allow to pass a DataFrame (returning a DataFrame)?\n            raise TypeError(\"'other' should be Series or Index\")\n        elif isinstance(others, (list, tuple)):\n            others = [\n                Series(other, index=idx) if not isinstance(other", "entropy": 56.85987729181501}
{"candidate": "            # Since Index inherits from list, we explicitly test for it first\n            return [others]\n        elif isinstance(others, (ABCDataFrame, ABCSeries, ABCIndexClass)):\n            return others.to_numpy().ravel()\n        else:\n            if isinstance(others, Iterable):\n                if not is_list_like(others):\n                    others = [others]\n\n                others = [", "entropy": 69.2808692350625}
{"candidate": "            return [others.to_series()]\n        elif isinstance(others, (ABCDataFrame, list, tuple)):\n            if isinstance(others, ABCDataFrame) and others.empty:\n                raise ValueError(\"Cannot concatenate with empty DataFrame\")\n            # For DF/list-like, we check the length of each element separately\n            # (they might have different indexes).\n            elif len(", "entropy": 72.3190218741522}
{"candidate": "            # flatten multiindex as we do for lists\n            if isinstance(others, ABCMultiIndex):\n                return others.to_flat_index().map_indexer(\n                    lambda x: tuple(x), uid=id(others)\n                )._values\n            return [others]\n        elif isinstance(others, ABCDataFrame):\n            return [others[col] for col in others]\n       ", "entropy": 79.79802213372798}
{"candidate": "            # This case should really be forbidden\n            return [Series(others, index=idx)]\n        elif isinstance(others, list) and not hasattr(others, \"ndim\"):\n            # If others is a list of objects (e.g. strings) and not a list-like\n            # (e.g. np.ndarray), check that length matches.\n            if len(idx) != len(", "entropy": 82.77442656482066}
{"candidate": "            # Index\n            if isinstance(others, ABCMultiIndex):\n                raise TypeError(\n                    \"Cannot use a MultiIndex for `others` parameter in \"\n                    \"`Series.str.cat`. Use `Series.str.cat` on the component \"\n                    \"levels and join them afterwards, e.g. by using \"\n                    \"`pd.concat`. Or use `Index.str.cat`, if the only purpose", "entropy": 88.87150899038498}
