{"candidate": "            series = self._iget_item_cache(col)\n            return series._values[index]\n        else:\n            series = self._get_item_cache(col)\n            return series.iat[index]\n\n    def _set_value(self, *args, **kwargs):\n        \"\"\"\n        Put single value at passed column and index.\n\n        Parameters\n        ----------\n        index : row label\n        col : column", "entropy": 19.627513021312005}
{"candidate": "            series = self._take(index, axis=0, convert=True, is_copy=False)\n            return series._get_value(col, takeable=True)\n\n        values = self._data.fast_2d_xs(self._item_cache, col, index, True)\n        return values\n\n    def _set_value(self, index, col, value, takeable: bool = False):\n        \"\"\"\n        Put", "entropy": 24.389876115839918}
{"candidate": "            series = self._iget_item_cache(col)\n            return series.iat if is_integer(index) else series.at\n        else:\n            return com.get_value(self, index, col)\n\n    def _set_item(self, key, value):\n        key = com.apply_if_callable(key, self)\n        self._data = self._data.setitem(key, value)\n", "entropy": 27.6943045826326}
{"candidate": "\n            values = self._values\n            if is_scalar(col) and isna(col):\n                col = self.columns.get_loc(col)\n            col_indexer = self.columns.get_indexer_for([col])\n            if is_scalar(index) and isna(index):\n                index = self.index.get_loc(index)\n            index_indexer = self.", "entropy": 34.90896201444551}
{"candidate": "            series = self._take_with_is_copy(self._xs(col, axis=1, copy=False), index)\n        else:\n            series = self._xs(col, axis=1, copy=False)\n            index = maybe_droplevels(index, series.index)\n            try:\n                return _maybe_box(series.loc, index, column=series, raise_missing=False)\n            except", "entropy": 37.52951446991802}
{"candidate": "            series = self._take(\n                self._row_labels_info.convert_indexer(index),\n                axis=0,\n                validate=True,\n                is_copy=False,\n            )\n            return series._get_value(\n                series._column_labels_info.convert_indexer(col),\n                takeable=takeable,\n            )\n\n        if len(self.columns) !=", "entropy": 37.715485251528335}
{"candidate": "            series = self._take(index, convert=True, is_copy=False, **self._kwargs)\n            return _align_method_FRAME(series, self.columns, axis=self._info_axis)[\n                col\n            ]\n        val = self._values[self.columns.get_loc(col)][\n            self.index._engine.get_loc(index)\n        ]\n        return self._", "entropy": 41.7113193666057}
{"candidate": "            series = self._ixs(col, axis=1)\n            return series._get_value(index, takeable=True)\n\n        if self._is_mixed_type:\n            series = self._ixs(col, axis=1)\n            return series._get_value(index)\n        else:\n\n            # try to use the block cache\n            block = self._get_block_at_item(index, col)", "entropy": 43.25271567780838}
{"candidate": "            series = self._take(index, convert=True, is_copy=False, validate=True)\n            return _maybe_box_datetimelike(series._values[col])\n\n        if col is not None:\n            # TODO(EA2D): validate\n            col = self.columns._get_level_values(col)\n            if len(col) > 1:\n                raise ValueError(\"Cannot index with", "entropy": 44.53259988528865}
{"candidate": "            loc = (\n                index.take([col], is_copy=False)\n                if isinstance(index, Index)\n                else index.take([col])\n            )\n            if len(loc) == 1:\n                return self._box_item_values(loc.iloc[0], empty_value=libmissing.NA)\n            raise KeyError\n        else:\n            if isinstance(col, tuple):\n                col", "entropy": 64.66137139860939}
