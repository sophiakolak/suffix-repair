{"candidate": "            result = self._constructor(\n                result, self.index, self.columns, dtype=dtype\n            )\n\n        if result.ndim == 2:\n            result = result.iloc[0, 0]\n\n        return result\n\n    def _reduce(\n        self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds\n    ):\n", "entropy": 31.031183931076068}
{"candidate": "            if isinstance(\n                result, np.ndarray\n            ) and result.ndim == 1 and axis_matters:\n                result = constructor(result, index=labels)\n            else:\n                result = constructor(result)\n\n        return result\n\n    def var(self, axis=None, dtype=None, out=None, ddof=1, **kwargs):\n        \"\"\"\n        Compute variance along the specified axis", "entropy": 35.589644986405524}
{"candidate": "            if self._is_datelike_mixed_type or self._is_datetimelike_mixed_type:\n                result, labels = self._try_coerce_result(result, labels)\n\n            result = constructor(result, index=labels, name=self.name)\n\n        return result\n\n    def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None", "entropy": 37.38922297867643}
{"candidate": "            if axis is not None and is_list_like(axis):\n                axis = axis[0]\n            if axis in [0, \"index\"]:\n                index = self.index[0:1]\n            elif axis in [1, \"columns\"]:\n                index = self.columns[0:1]\n            elif axis is None:\n                index = None\n            else:\n                raise AssertionError(\"", "entropy": 39.22380402065903}
{"candidate": "            result = constructor(result, **dict(axis=labels))\n\n        return result\n\n    # ----------------------------------------------------------------------\n    # Eval-based reduction (min/max also use this)\n\n    def _reduce(\n        self,\n        op,\n        name,\n        axis=0,\n        skipna=True,\n        numeric_only=None,\n        filter_type=None,\n        **kwds,\n    ):\n        \"\"\"", "entropy": 42.61450337791989}
{"candidate": "            result = constructor(result)\n\n        # convert to a Series\n        if axis == 0:\n            index = self.columns[0]\n            result = Series(result, name=index, index=labels)\n        else:\n            index = self.index[0]\n            result = Series(result, name=index, index=labels)\n            if len(result) > 1:\n                result = result.reindex(", "entropy": 45.39848468918172}
{"candidate": "            # work around for series\n            axis = self._get_axis_number(axis)\n            if axis == 1:\n                result = list(result)\n                result = constructor(result, index=labels)\n\n            else:\n                result = constructor(result)\n\n        return result\n\n    def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **", "entropy": 46.16972019220788}
{"candidate": "\n            # convert to a builder if we don't have one\n            if \"BlockManager\" not in result.__class__.__name__:\n                result = constructor(result, index=labels, fastpath=True)\n\n        return result\n\n    def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds):\n        \"\"\"\n        perform a reduction", "entropy": 48.59333525923554}
{"candidate": "            result = constructor(result, labels=labels)\n\n        return result\n\n    @doc(klass=_shared_docs[\"reduce_raw\"])\n    def _reduce_raw(self, name, **kwargs):\n        return getattr(self, name)(**kwargs)\n\n    def first(self, offset):\n        \"\"\"\n        Convenience method for subsetting initial periods of time series data\n        based on a date", "entropy": 47.89372233547561}
{"candidate": "            result = constructor(result)\n\n        return result, labels\n\n    def _get_data(self, axis_matters=True):\n        \"\"\"\n        Get type-specific data\n        \"\"\"\n        raise NotImplementedError\n\n    def _get_agg_axis(self, axis_num=0):\n        \"\"\"\n        Get the aggreagation axis.\n        \"\"\"\n        raise NotImplementedError\n\n    def count(self", "entropy": 47.95644391853411}
{"candidate": "            if numeric_only:\n                if numeric_dtypes(result).size != len(result):\n                    raise TypeError(\"reduction operation '{0}' not allowed for \"\n                                    \"this dtype\".format(name))\n            cls = constructor(result, copy=False)\n            cls.name = name\n            cls._set_axis(labels, axis=axis)\n            return cls\n\n        return result\n\n", "entropy": 51.80045081212804}
{"candidate": "            if not isinstance(result, constructor) and notna(result).all():\n                try:\n                    result = constructor(result)\n                except (ValueError, TypeError):\n                    pass\n\n            elif (\n                isinstance(constructor, ABCMultiIndex)\n                and isinstance(result, (ABCIndex, list))\n                and not isinstance(result, constructor)\n            ):\n                # GH#23560\n                result =", "entropy": 54.24443544413702}
{"candidate": "            if isinstance(labels, MultiIndex):\n                # TODO: figure out how to handle this case\n                raise NotImplementedError(\"Multi-index not yet implemented\")\n            else:\n                if isinstance(result, np.ndarray) and result.ndim == 1:\n                    # single block case\n                    result = Series(result, index=labels, name=self.columns[0])\n                else:\n                   ", "entropy": 55.54624498719058}
{"candidate": "            if axis == 0:\n                # try to coerce to the original dtypes\n                result = coerce_to_dtypes(result, self.dtypes)\n\n                flat_result = result.flatten()\n                if not isinstance(flat_result, np.ndarray):\n                    flat_result = np.array(flat_result)\n                result = constructor(flat_result)\n            else:\n                # TODO(ext", "entropy": 56.40793612421851}
{"candidate": "            result = constructor(result)\n\n        if len(values) != len(result):\n            raise ValueError(\n                \"Function does not reduce\",\n                f,\n                values,\n                result,\n                name_map,\n                filter_type,\n                dtype_map,\n                numeric_only,\n            )\n        if result.ndim == self.ndim - 1:\n            is_reduction = True\n            if", "entropy": 63.484799541998996}
{"candidate": "            # GH#20814\n            if numeric_only:\n                if not numeric_dtypes(result):\n                    raise TypeError(\n                        \"Data must be numeric to perform this operation: %s\" % result\n                    )\n                result = constructor(result, axis=axis)\n            else:\n                result = constructor(result, axis=axis)\n\n        if isinstance(labels, ABCMultiIndex):\n            levels = labels.levels\n", "entropy": 72.00539810133752}
{"candidate": "\n            # GH#24162 constructor is not np.ndarray\n            if isinstance(result, list):\n                result = np.array(result)\n            if constructor is list:\n                result = list(result)\n            else:\n                result = constructor(result)\n\n        if len(result) == 0:\n            # we have an empty list here\n            dtype, constructor = _maybe_promote(self.dtype)\n           ", "entropy": 77.9387655430859}
{"candidate": "\n            # if we are not passed a Series, we will try to construct a Series\n            result = constructor(result, index=labels, name=self.name)\n            result = result._convert(datetime=True)\n\n            # we might have a non-scalar of all None's\n            if isinstance(result, (ABCSeries, ABCDataFrame)) and result.empty:\n                result = result._constructor(dtype=", "entropy": 78.73625969254174}
{"candidate": "            result = constructor(result)\n            if result.ndim == 2:\n\n                # TODO: this should be more general\n                # but for now this is a special case for functions like\n                # cumsum & cumprod to get the correct ndim\n                result = result.iloc[-1]\n\n        if labels is not None:\n            if result.ndim == 0:\n\n                # result is a scalar\n                name", "entropy": 91.04576173688586}
{"candidate": "            # Create the array first, then wrap it in the constructor\n            result = constructor(result)\n        else:\n            # If we have an actual numeric dtype, then coerce to that\n            # otherwise coerce to whatever type the result is\n            dtype = None\n            if filter_type == \"numeric\":\n                dtype = self.dtypes.apply(np.find_common_type, [])\n                # Compute the", "entropy": 102.97250041009116}
