{"candidate": "        \"\"\" property cache for the indexer \"\"\"\n        return self._engine_type(lambda: self._values, len(self))\n\n    def _convert_tolerance(self, tolerance, target):\n        tolerance = np.asarray(to_timedelta(tolerance, box=False).to_numpy())\n        if target.size != tolerance.size and tolerance.size > 1:\n            raise ValueError(\"list-like tolerance size", "entropy": 18.807482292204387}
{"candidate": "        from pandas.core.indexes.period import PeriodEngine\n\n        return PeriodEngine(lambda s: s, len(self), self.freq)\n\n    def _maybe_promote(self, other):\n        if isinstance(other, PeriodArray):\n            if self.freq != other.freq:\n                raise IncompatibleFrequency(self.freqstr, other.freqstr)\n\n            return other\n        elif", "entropy": 20.304934320891977}
{"candidate": "        from pandas.core.indexes.period import PeriodEngine\n\n        return PeriodEngine(lambda: self.asi8, self.freq)\n\n    _engine_type = libindex.PeriodEngine\n\n    def get_value(self, series, key):\n        \"\"\"\n        Fast lookup of value from 1-dimensional ndarray. Only use this if you\n        know what you're doing\n        \"\"\"\n        if not is_integer(key", "entropy": 20.949447295876396}
{"candidate": "        return PeriodEngine(lambda s: s, len(self))\n\n    def _maybe_cast_slice_bound(self, label, side, kind):\n        \"\"\"\n        If label is a string that looks like a number, then cast it\n        to integer.\n\n        Parameters\n        ----------\n        label : object\n        side : {'left', 'right'}\n        kind : {'loc', 'getitem'}\n\n        Returns\n", "entropy": 21.11757732334019}
{"candidate": "        return PeriodEngine(lambda s: s, len(self))\n\n    @property\n    def _values(self):\n        return self.array\n\n    def _can_reindex(self, indexer):\n        \"\"\"\n        Check if we are allowing reindexing with this particular indexer\n\n        Parameters\n        ----------\n        indexer : an integer indexer\n\n        Raises\n        ------\n        ValueError if its a duplicate axis\n        \"\"\"", "entropy": 24.198346600996288}
{"candidate": "        raise AbstractMethodError(self)\n\n    def _maybe_cast_slice_bound(self, label, side, kind):\n        \"\"\"\n        If label is a string representing a slice bound, cast it\n        to Period.ordinal according to resolution. Returns None otherwise.\n\n        Parameters\n        ----------\n        label : object\n        side : {'left', 'right'}\n        kind : {'ix', 'loc', 'getitem'", "entropy": 25.212351098641197}
{"candidate": "        return PeriodIndexEngine(self)\n\n    def _maybe_update_attributes(self, attrs):\n        attrs = attrs.copy()\n        if \"freq\" not in attrs and hasattr(self, \"freq\"):\n            attrs[\"freq\"] = self.freq\n        return self._maybe_update_fields(attrs)\n\n    def _convert_scalar_indexer(self,", "entropy": 27.316224790553413}
{"candidate": "        return PeriodArrayEngine(lambda: com.asarray_tuplesafe(self), self.freq)\n\n    def get_loc(self, key, method=None, tolerance=None) -> int:\n        \"\"\"\n        Get integer location for requested label\n\n        Returns\n        -------\n        loc : int\n        \"\"\"\n        if is_scalar(key) and isna(key):\n            key = self._na_value\n\n       ", "entropy": 32.8361009081909}
{"candidate": "        return PeriodArrayEngine(lambda: self, len(self), self.dtype)\n\n    @Appender(Index.isin.__doc__)\n    def isin(self, values, level=None):\n        if level is not None:\n            self._validate_index_level(level)\n            return Index.isin(self, values, level=level)\n        try:\n            values = _ensure_dtype_co", "entropy": 39.437175278625496}
{"candidate": "        from pandas._libs import index as libindex\n\n        return libindex.PeriodEngine\n\n    @classmethod\n    def _create_index_level_with_freq(cls, freq: Optional[Frequency]) -> \"DatetimeIndexOpsMixin\":\n        return cls(\n            np.array([NaT], dtype=np.int64), freq=freq, name=\"__placeholder__\"\n       ", "entropy": 40.79713592490439}
{"candidate": "        return self.array._engine\n\n    def __array__(self, dtype=None) -> np.ndarray:\n        \"\"\" the array interface, return my values \"\"\"\n        return self.array.__array__(dtype=dtype)\n\n    @property\n    def ndim(self):\n        return 0\n\n    def __len__(self) -> int:\n        \"\"\"\n        return the length of my contained array\n        \"\"\"\n", "entropy": 41.11690279727651}
{"candidate": "        return self._base_indexer((0,), tuple())\n\n    @Appender(_index_shared_docs[\"get_loc\"])\n    def get_loc(self, key, method=None, tolerance=None):\n        if isinstance(key, datetime):\n            key = Period(key, self.freq)\n        return self._engine.get_loc(key)\n\n    def _maybe_cast_slice_bound(", "entropy": 41.531095261511425}
{"candidate": "        return self.array._engine\n\n    def _is_comparable_freq(self, other: \"PeriodArray\") -> bool:\n        \"\"\"\n        Can we compare values of the given PeriodArray to our own?\n        \"\"\"\n        return other.freq == self.freq\n\n    def _maybe_promote(self, other: object) -> \"PeriodArray\":\n        if other is not None:\n            if not isinstance", "entropy": 41.91859463915279}
{"candidate": "        cls = type(self)\n        return cls._engine_type(lambda: self, len(self), self.freq)\n\n    @property\n    def _can_hold_na(self) -> bool:\n        return False\n\n    def _should_fallback_to_positional(self, key):\n        \"\"\"\n        If we have an integer key and are not a MultiIndex, then we should\n        not fallback to", "entropy": 43.735476270829196}
{"candidate": "        \"\"\"\n        We use our Int64Index engine for period indexing.\n        \"\"\"\n        return self._int64index._engine\n\n    def _get_string_slice(self, key: int) -> np.ndarray:\n        \"\"\"\n        This is a temporary hack for internal compatibility with\n        numpy string indexing.\n\n        Parameters\n        ----------\n        key : int\n            A parsed key.\n\n        Returns\n        -------\n       ", "entropy": 44.27730325177598}
{"candidate": "        from pandas.core.indexes.period import PeriodEngine\n\n        return PeriodEngine(lambda s: s, len(self))\n\n    def _get_string_slice(self, key: slice, use_lhs: bool = True,\n                          use_rhs: bool = True) -> List[self.dtype]:\n        \"\"\"\n        This is for getting a slice of period strings.  It is only called\n        when the slice", "entropy": 44.75298319262391}
{"candidate": "        from pandas._libs.index import PeriodEngine\n        return PeriodEngine(self)\n\n    def _can_reindex(self, indexer) -> bool:\n        \"\"\"\n        Can we reindex with dtype & freq of the PeriodIndex?\n\n        Parameters\n        ----------\n        indexer : array-like\n\n        Returns\n        -------\n        boolean\n        \"\"\"\n        indexer = ensure_int64(np.array(index", "entropy": 53.629592329611974}
{"candidate": "        return PeriodIndexEngine(lambda s: s.asi8, len(self), self.dtype.freq)\n\n    @property\n    def _values(self):\n        # return my values as i8 (which is my underlying data representation)\n        return self.asi8\n\n    def _get_engine_type(self):\n        return PeriodIndexEngine\n\n    # ------------------------------------------------------------------------\n    # Properties\n\n    @property\n    def freq(", "entropy": 56.78024257894999}
{"candidate": "        if self.freq.n > 0:\n            cls = libindex.PeriodEngine\n        else:\n            cls = libindex.PeriodReverseEngine\n        return cls(lambda: self, len(self), self.freq)\n\n    def __getitem__(self, key):\n        if isinstance(key, Period):\n            # GH#30622 we shouldn't be comparing freqs here, only ord", "entropy": 61.87956071350431}
{"candidate": "        from pandas.core.indexing import (\n            _get_loc_optional_integer_kwargs,\n            PeriodArrayEngine,\n        )\n\n        if not hasattr(self, \"_values\"):\n            return PeriodArrayEngine(self, len(self))\n\n        _, int_kwargs = _get_loc_optional_integer_kwargs(self)\n        return PeriodArrayEngine(self, len(self), int_kw", "entropy": 63.09348992965516}
