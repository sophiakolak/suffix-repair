{"candidate": "                codes = self._codes\n                codes[codes == -1] = values_codes[codes == -1]\n            else:\n                codes = self._codes.copy()\n                codes[codes == -1] = self.categories.get_loc(value)\n\n        return Categorical(codes=codes, categories=self.categories, ordered=self.ordered)\n\n    def fillna(self, value=None, method=None", "entropy": 24.31821551999101}
{"candidate": "                codes = self._codes.copy()\n                mask = codes == -1\n                np.putmask(codes, mask, values_codes)\n\n            # If value is a valid category\n            elif value in self.categories:\n                codes = self._codes.copy()\n                np.putmask(codes, codes == -1, self.categories.get_loc(value))\n\n            # If value is a list-like of valid", "entropy": 30.143815158137997}
{"candidate": "                codes = codes.copy()\n                for i, cat in enumerate(value.index):\n                    codes[self.__array__() == cat] = values_codes[i]\n\n            # If value is a category or in self.categories\n            elif value in self.categories:\n                codes = codes.copy()\n                codes[codes == -1] = _get_codes_for_values(\n                    value, self.", "entropy": 30.8157910191005}
{"candidate": "                codes = _fillna_with_codes(codes, values_codes)\n            else:\n                codes = _fillna_with_codes(codes, _get_codes_for_values(value, self.categories))\n\n        new_categories = self.categories.take(codes)\n        return self._constructor(new_categories, codes, self.ordered, fastpath=True)\n\n    @Appender(_fillna", "entropy": 31.079490129385}
{"candidate": "            else:\n                if value not in self.categories and not isna(value):\n                    raise ValueError(\"fill value must be in categories\")\n\n                values_codes = _get_codes_for_values(\n                    Series(value, dtype=\"category\"), self.categories\n                )\n\n            codes = self._fill_na(codes, values_codes)\n\n        return self._constructor(codes, self.categories, self.", "entropy": 31.733071391590002}
{"candidate": "                value = self._constructor(values_codes, self.categories, fastpath=True)\n\n            if value is np.nan:\n                pass\n            elif is_categorical_dtype(value):\n                codes = value._codes\n            elif is_scalar(value):\n                codes = self.categories.get_loc(value)\n            else:\n                codes = _get_codes_for_values", "entropy": 33.704957251792294}
{"candidate": "                codes = np.where(codes == -1, values_codes, codes)\n\n            # If value is a scalar\n            else:\n\n                cat = self.categories\n                if is_categorical_dtype(value):\n                    cat = cat.add_categories(value.categories)\n\n                codes = np.where(codes == -1, cat.get_indexer([value]), codes)\n\n        return self._construct", "entropy": 34.51567795642651}
{"candidate": "                codes = np.where(codes == -1, values_codes, codes)\n\n            # If value is just a scalar\n            elif isna(value):\n                codes = np.where(codes == -1, -1, codes)\n            else:\n                codes = np.where(codes == -1, self._codes.max() + 1, codes)\n                self.cat.add_categories([value])\n\n        return", "entropy": 34.53744644340849}
{"candidate": "                codes = np.where(codes == -1, values_codes, codes)\n            else:\n                codes = np.where(codes == -1, -1, codes)\n\n        return Categorical(codes, categories=self.categories, dtype=self.dtype)\n\n    def _remove_accidental_casts(self, codes: np.ndarray, categories: tp.List[T]) -> tp.Tuple", "entropy": 46.732643244382295}
{"candidate": "                value = self._from_factorized(values_codes, self.categories)\n\n            # If value is a Categorical\n            elif is_categorical_dtype(value):\n                if not self._values_match(value.categories):\n                    raise ValueError(\"fill value must be in categories\")\n\n                # Convert value to codes\n                values_codes = value._codes\n                value = self._from_factorized(", "entropy": 47.1014212786972}
{"candidate": "                value = self._constructor(values_codes, self.categories)\n\n            # if a list, it must match the length of our categories\n            elif is_list_like(value) and len(value) != len(self.categories):\n                raise ValueError(\n                    \"Unable to fill {0} NaN values in {1} with a \"\n                    \"{2}-length list\".format(\n                        self.is", "entropy": 50.50266030016}
{"candidate": "                codes = self._codes.where(self._codes != -1, values_codes)\n\n            # If value is not a dict or Series (e.g. a scalar)\n            else:\n                if value not in self.categories and not isna(value):\n                    raise ValueError(\"fill value must be in categories\")\n\n                # If value is np.nan, then use NaN, otherwise use\n                # codes.\n                values", "entropy": 58.94921459657148}
{"candidate": "\n                codes = self.combine_first(values_codes)._codes\n            else:\n\n                # If value is not a dict and not a Series\n                if is_scalar(value):\n                    value_code = _get_codes_for_values_from_code(\n                        value, self._codes, self._categories, self.categories\n                    )\n                # If value is np.nan and dtype is object\n               ", "entropy": 65.32244702809048}
{"candidate": "\n                mask = isna(codes)\n                codes[mask] = values_codes[mask]\n\n            else:\n                # if we only have a value, use numpy.where to fill NA.\n                codes = np.where(isna(codes), -1, codes)\n\n        return type(self)(\n            codes, categories=self.categories, ordered=self.ordered, fastpath=True\n        )\n\n    def argsort(", "entropy": 67.46630291697699}
{"candidate": "                # Use pd.Series instead of pd.Index because the latter\n                # doesn't support np.nan in Series.__contains__\n                value_codes = pd.Series(values_codes, index=value.index)\n                codes = value_codes.reindex(self.index).fillna(codes).astype(\n                    self.dtype\n                )\n\n            elif is_scalar(value) and isn", "entropy": 68.81505403471539}
{"candidate": "                codes, fill_value = self._maybe_convert_codes(\n                    codes, values_codes, value, fill_value=True\n                )\n                # replace the bad codes\n                codes[codes == -1] = fill_value\n            else:\n                codes = super().fillna(value, method, limit)\n\n        return self._constructor(codes, self.categories, self.ordered, self._name)\n\n    def", "entropy": 70.51759789817632}
{"candidate": "\n                # Use .take() to ensure that fillna isn't affected by categorical\n                # ordering.\n                value = self.categories.take(values_codes)\n\n            else:\n                # If value is a scalar\n                if value not in self.categories:\n                    raise ValueError(\"fill value must be in categories\")\n                value = self.categories[value]\n\n            # Convert to codes\n            value_code = value.", "entropy": 77.531471866908}
{"candidate": "                codes = _fillna_with_values(codes, values_codes)\n\n            else:\n\n                if value not in self.categories:\n                    raise ValueError(\"fill value must be in categories\")\n\n                codes = _fillna_with_values(codes, self.categories.get_loc(value))\n\n        if self._is_dtype_auth:\n            # Set the dtype to `correct` object type\n            return self", "entropy": 77.12479278329698}
{"candidate": "                codes = values_codes.where(isna(codes), codes)\n\n            # Set codes to NaN. We don't do this for value=np.nan to avoid\n            # unnecessary conversions\n            elif not lib.is_scalar(value) or not isna(value):\n                msg = \"fill value must be in categories\"\n                raise ValueError(msg)\n\n        return Categorical(codes, categories=self.c", "entropy": 77.81403109893947}
{"candidate": "                # we need to set the nan to -2 here, because if we fillna with\n                # a different nan value, it's not nan anymore\n                values_codes[isna(value)] = -2\n                codes = algos.take_1d(values_codes, codes)\n\n            # Scalar, but not a category name\n            elif value is np.nan and not self.categories.dtype.kind == \"O", "entropy": 95.04463002442179}
