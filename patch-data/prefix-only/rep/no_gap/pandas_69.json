{"candidate": "                if is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an non-integer index \"\n                        \"cannot have an integer indexer\"\n                    )\n\n        return key\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = True\n\n    def _convert_key(self, key, is", "entropy": 8.520448407871502}
{"candidate": "                if is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on a non-integer \"\n                        \"index can only have non-integer indexers\"\n                    )\n        return list(key)\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = False\n\n    def _convert_key(self", "entropy": 8.910266161594494}
{"candidate": "                if is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on a non-integer index \"\n                        \"cannot have an integer indexer\"\n                    )\n\n        return list(key)\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = True\n\n\n@Appender(IndexingMixin.", "entropy": 8.943594532950998}
{"candidate": "                if is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an non-integer \"\n                        \"index can only have non-integer indexers\"\n                    )\n\n        return key\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = False\n\n    def _convert_key(self, key,", "entropy": 9.245983014659998}
{"candidate": "                if not ax.contains(i):\n                    raise ValueError(\n                        \"At based indexing on a non-integer index can \"\n                        \"only have non-integer indexers\"\n                    )\n        return list(key)\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = True\n\n\n@Appender(Indexing", "entropy": 13.243179670764997}
{"candidate": "                if not is_scalar(i):\n                    raise ValueError(\n                        \"iLocation based indexing can only \"\n                        \"have [scalar] indexers\"\n                    )\n        return list(key)\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = False\n\n    def _convert_key(self", "entropy": 15.026669052621196}
{"candidate": "                if not isinstance(i, Hashable):\n                    raise ValueError(\n                        \"At based indexing on an non-integer index \"\n                        \"cannot have non-hashable indexers\"\n                    )\n        return list(key)\n\n\nclass _iAtIndexer(_AtIndexer):\n    _takeable = True\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_", "entropy": 19.53657221415231}
{"candidate": "                if not isinstance(i, ax.inferred_type):\n                    raise ValueError(\n                        \"At based indexing can only have matching \"\n                        \"dtype indexers\"\n                    )\n        return key\n\n\nclass _iAtIndexer(_AtIndexer):\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require they keys to be the same type as the", "entropy": 20.132502738610196}
{"candidate": "                i = ax._convert_scalar_indexer(i, kind=\"getitem\")\n\n            key = list(key)\n            key[ax.axis] = i\n            key = tuple(key)\n\n        return key\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    \"\"\"\n    Special indexer to get or set a scalar", "entropy": 21.145977779267238}
{"candidate": "                if not is_scalar(i):\n                    raise ValueError(\n                        \"At based indexing on a non-integer index \"\n                        \"can only have scalar indexers\"\n                    )\n        return list(key)\n\n    def _validate_key(self, key, axis: int) -> None:\n        if self.obj.axes[axis].is_integer():\n            if not is_integer(key):\n", "entropy": 22.90800359554001}
{"candidate": "                if not isinstance(i, ax.inferred_type):\n                    raise ValueError(\n                        \"At based indexing can only have\"\n                        f\" compatible indexers, got\"\n                        f\" {type(i).__name__} for {ax.inferred_type.__name__}\"\n                    )\n        return list(key)\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _i", "entropy": 23.6268766136122}
{"candidate": "                if not isinstance(i, ax.dtype.type):\n                    raise ValueError(\n                        \"At based indexing can only have {} indexers\"\n                        \"\".format(ax.dtype.name)\n                    )\n        return [ax._maybe_cast_indexer(k) for k, ax in zip(key, self.obj.axes)]\n\n\n@Appender(IndexingMixin.iat.__doc__)", "entropy": 27.204814465289008}
{"candidate": "                assert isinstance(\n                    i, (slice, type(ax.missing_value))\n                ), f\"At based indexing on a non-integer index can only have non-integer indexers\"\n\n        return list(key)\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = True\n\n    def _convert_key(", "entropy": 31.90802563286699}
{"candidate": "                if not ax._can_reindex(i):\n                    raise ValueError(\n                        \"At based indexing can only have \"\n                        \"equal keys and axis\"\n                    )\n\n        return list(key)\n\n    def _getitem_tuple(self, tup):\n        try:\n            return self.obj._get_value(*tup)\n        except (KeyError, ValueError, IndexError):\n            # we can try", "entropy": 34.39842677262899}
{"candidate": "                if ax.is_numeric() and not is_integer(i):\n                    if not (is_float(i) or is_integer(i)):\n                        raise ValueError(\n                            \"At based indexing on a numeric index \"\n                            \"can only have non-integer indexers\"\n                        )\n                elif not isinstance(i, ax.dtype.type):\n                    raise ValueError(\n                        f\"At", "entropy": 34.54359433521678}
{"candidate": "                if not is_list_like(i):\n                    raise TypeError(\n                        \"At based indexing on a non-integer index \"\n                        \"can only have non-integer indexers\"\n                    )\n                if not is_scalar(i) and len(i) != 1:\n                    raise ValueError(\n                        \"Scalar array indexers are out-of-bounds \"\n                        \"in at-based indexing\"", "entropy": 39.954178292609}
{"candidate": "                # convert to label (or raise)\n                i = ax._convert_scalar_indexer(i, kind=\"getitem\")\n            yield i\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_AtIndexer):\n    _takeable = True\n\n\n_iLocIndexer = _AtIndexer\n\n\nclass _NDFrameIndexerBase:\n    \"\"\"\n   ", "entropy": 41.34158005988919}
{"candidate": "                # convert to label\n                # will raise a TypeError if we pass a label that is not\n                # in the index\n                i = ax._convert_scalar_indexer(i, kind=\"getitem\")\n\n        return list(key)\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = False\n    _", "entropy": 49.25991458881671}
{"candidate": "                if not isinstance(i, ax.inferred_type):\n                    raise ValueError(\"unsupported type for at based indexing\")\n\n        # GH 13700\n        # allow setting with integers\n        return key\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = False\n\n    def _convert_key(self, key,", "entropy": 50.51600175705369}
{"candidate": "                if not isinstance(i, (ax.dtype.type, compat.string_types)):\n                    raise ValueError(\n                        \"At based indexing on a non-integer index \"\n                        \"can only have non-integer indexers\"\n                    )\n        return list(key)\n\n    def _getitem_tuple(self, tup):\n        return tup[0]\n\n\n# defined here to allow for inheritance for _", "entropy": 52.9042802186134}
