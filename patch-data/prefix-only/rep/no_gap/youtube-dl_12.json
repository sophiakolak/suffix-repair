{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            BOOL_OPERATORS = {\n                '=': operator.methodcaller('__eq__', True),\n                '!=': operator.methodcaller('__eq__', False),\n            }\n            str_operator_rex = re.compile(r'''", "entropy": 17.517434919339}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n        if not m:\n            BOOLEAN_OPERATORS = {\n                '=': operator.eq,\n                '==': operator.eq,\n                '!=': operator.ne,\n                '<>': operator.ne,\n            }\n            boolean_operator_rex = re.comp", "entropy": 17.888048868583017}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            raise ValueError('Invalid format specification %r' % filter_spec)\n\n        key = m.group('key')\n        if key == 'abr':\n            key = 'abr'\n        if key == 'tbr':\n            key = 'tbr'\n        if", "entropy": 19.214418351990997}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            raise ValueError('Invalid format specification: %r' % filter_spec)\n\n        def filter_func(format):\n            if not format:\n                return False\n            attr = format.get(m.group('key'))\n            if attr is None:\n                return", "entropy": 21.325414022943}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            raise ValueError(\n                'Invalid format specification %r' % filter_spec)\n\n        def test(e):\n            attr = e.get(m.group('key'))\n            if attr is None:\n                return False\n            return op(attr, comparison_", "entropy": 22.425401506956902}
{"candidate": "                    def op(attr, value):\n                        return not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if m is None:\n            raise ValueError(\n                'Invalid format specification %r' % filter_spec)\n        elif m.group('none_inclusive'):\n            def predicate(info):\n                attr = info.get(m.group('key'))\n                return att", "entropy": 23.138273189137994}
{"candidate": "                    op = lambda attr, val: not str_op(attr, val)\n                else:\n                    op = str_op\n\n        if m is None:\n            raise ValueError(\n                'Invalid format specification %r' % filter_spec)\n\n        key = m.group('key')\n        none_inclusive = bool(m.group('none_inclusive'))\n        if key == 'fps':\n            comparison_value =", "entropy": 23.317696845635002}
{"candidate": "                    str_op = lambda attr, value: not str_op(attr, value)\n\n            if not m:\n                m = re.search(r'''(?x)\n                    \\s*(?P<key>[a-zA-Z0-9._-]+)\n                    \\s*=\n                    \\s*(?P<value>[a-zA-Z0-9._-]+)\n                    \\s", "entropy": 24.432509228331003}
{"candidate": "                    def op(attr, value):\n                        return not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            m = re.match(r'''(?x)\\s*\n                (?P<key>protocol)\n                \\s*(?P<none_inclusive>\\s*\\?)?\\s*\n                (?P<value>mmsh", "entropy": 24.561332493395994}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            raise ValueError(\n                'Invalid format specification %r' % filter_spec)\n\n        def is_valid_format(f):\n            key = m.group('key')\n            try:\n                attr = f[key]\n            except KeyError:\n                if key", "entropy": 25.752610740477007}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            m = _FILESIZE_RE.search(filter_spec)\n            if m:\n                comparison_value = parse_filesize(m.group('max_size'))\n                op = operator.le\n\n        if not m:\n            raise ValueError(\n                '", "entropy": 26.175527048978}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n        if not m:\n            m = re.search(r'^(?P<key>preference)\\s*(?P<op><=|>=|<|>)\\s*(?P<value>\\d+)$', filter_spec)\n            if m:\n                try:\n", "entropy": 26.430634621270993}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n\n        if m:\n            if m.group('none_inclusive') is not None:\n                f = (lambda info: info is not None and op(getattr(info, m.group('key')), comparison_value))\n            else:\n                f = (lambda info: op(getattr(info, m.group('key')), comparison_value", "entropy": 28.820217361279294}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            m = re.match(r'''(?x)\n                \\s*(?P<key>fps)\n                (?P<negate>!\\s*)?\n                (?P<op>=)\n                (?P<none_inclusive>\\", "entropy": 29.7899630207715}
{"candidate": "                    def str_op(attr, value, str_op=str_op):\n                        return not str_op(attr, value)\n                op = lambda attr, value, str_op=str_op: str_op(\n                    getattr(attr, m.group('key'), ''), value)\n\n        if not m:\n            print('Cannot parse format specification %r' % filter_spec)\n            continue\n\n        key =", "entropy": 32.969968057383}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n\n        if not m:\n            raise ValueError('Cannot parse format specification %r' % filter_spec)\n\n    key = m.group('key')\n    if key == 'ext':\n        key = 'ext'\n        comparison_attr = f.extension\n    elif key == 'acodec':\n        key = 'audio codec'\n       ", "entropy": 34.00837081888502}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            raise ValueError('Invalid filter %r' % filter_spec)\n\n        key = _FILTER_TYPES[m.group('key')]\n\n        if m.group('none_inclusive'):\n            is_none_inclusive = True\n\n    if key is None", "entropy": 41.17872862360251}
{"candidate": "                    def op(attr):\n                        return not str_op(attr, comparison_value)\n                else:\n                    op = str_op\n\n        if not m:\n            raise ValueError('Invalid format specification: ' + filter_spec)\n\n        # Perform the actual filter\n\n        key = m.group('key')\n        none_inclusive = m.group('none_inclusive')\n\n        def key_match(f):\n            if key", "entropy": 50.29565935616152}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            if filter_spec.startswith('exclude'):\n                exclude = True\n                filter_spec = filter_spec[8:].strip()\n            else:\n                exclude = False\n            # For convenience and backwards compatibility\n            fmt = self._search_regex(\n", "entropy": 51.19328855189001}
{"candidate": "                    op = lambda attr, value: not str_op(attr, value)\n                else:\n                    op = str_op\n\n        if not m:\n            # It is a dict syntax like {key=value,key=value,...}\n            m = re.match(r'\\{\\s*(?P<inner>.+)\\s*\\}\\s*$', filter_spec)\n            if m:\n                for p in filter", "entropy": 63.5198630369155}
