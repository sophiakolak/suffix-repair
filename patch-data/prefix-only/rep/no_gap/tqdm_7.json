{"candidate": "RE_SPLIT = re.compile(r'(\\s+|(?<!\\\\)\"|(?<!\\\\)\\')')\nRE_ESC_QUOTES = re.compile(r'\\\\(?=\"|\\')')\n\n\ndef split_options(s):\n    return RE_SPLIT.split(s)\n\n\ndef unescape_quotes(s):\n    return RE_ESC_QU", "entropy": 42.58698364608098}
{"candidate": "# re.compile(r'\\n {8}(?:/(?:/\\S+)|(?:-{2}\\S+)|(?:-\\S+))')\nRE_LONG_OPTS = re.compile(r'\\n {8}(?:/(?:/\\S+)|(?:-{2}\\S+))')\nRE_SHORT_OPTS = re.compile(r'\\n", "entropy": 50.42339084019002}
{"candidate": "RE_SUBMIT_ARGS = re.compile(r'\\s*([^\\s=]+)=([^\\s=]*)\\s*')\n\n\ndef parse_options(txt):\n    from collections import OrderedDict\n    d = OrderedDict()\n    for line in txt.splitlines():\n        m = RE_OPTS.match(line)\n        if m:\n            d[m.group", "entropy": 52.87670791658402}
{"candidate": "RE_SPLIT = re.compile(r'(\\s+|=)')\n\n\ndef get_opts(script):\n    \"\"\" find options in __main__ \"\"\"\n    with open(script, 'rb') as fin:\n        for line in fin:\n            if line.startswith('if __name__ == \"__main__\":'):\n                break\n\n        opts = []\n        for line in fin:\n           ", "entropy": 53.423182096644005}
{"candidate": "SPLIT_RE = re.compile(r\"\"\"\n    (?:                   # non-capture group\n      [^\\s\"'`\\\\]+ |       #   1. run of non-space, non-quote characters\n      \"(?: \\\\\\. | [^\"] )*\"|   #   2. a double quoted string\n      '(?: \\\\\\. | [^'] )*'|   #   2. a single quoted string\n", "entropy": 57.428479852155995}
{"candidate": "RE_SPLIT = re.compile(r'\"([^\"]*)\"|(\\S+)')\n\n# ------------------------------------------------------------------------------\n# defaults\n# ------------------------------------------------------------------------------\n\n\ndef exe_suffix(is_win):\n    return '.exe' if is_win else ''\n\n\nIS_WIN = sys.platform == 'win32'\nIS_MAC = sys.platform == 'darwin'\n\nEXE_SUFFIX = exe", "entropy": 62.61198830171351}
{"candidate": "RE_ARGS = re.compile(r'\\s+(?:([\"\\'])(?:\\\\.|[^\\\\])*?\\1|\\S+)')\n# matching quotes\nRE_QUOTES = re.compile(r'^\\s*[\"\\'](.*)[\"\\']$', flags=re.DOTALL)\n# matching pathnames\nRE_PATH = re.compile(r'^(?:/", "entropy": 63.09535168103498}
{"candidate": "RE_OPTS_ALT = re.compile(r'\\n {8}([\\w-]+)(?:=|\\s+)')\n# ((opt, val), ... )\nRE_OPTS_ALT_SPLIT = re.compile(r'=|\\s+')\nRE_OPT_DEFAULT = re.compile(r'\\n {8}[^:]+\\s{2,}:\\s", "entropy": 65.24918841365397}
{"candidate": "RE_ARGS = re.compile(r'\\s{2,}')\n\n\ndef parse_command_output(out):\n    '''\n\n    >>> out = '''\n    ... Option     : test_arg\n    ... Choices    : ('a', 'b')\n    ... Type       : str\n    ... Required   : True\n    ... Default    : None\n    ... Description: This is a test arg\n    ... '''", "entropy": 75.67542168800402}
{"candidate": "_RE_SPLIT = re.compile(r'\\s+')\n\n\ndef parse_script_options(script):\n    \"\"\"\n    Extract command-line options from script.\n\n    :param script:\n        ``str`` path to script\n\n    :return:\n        ``list`` [(option, argparse.Action), ... ]\n    \"\"\"\n    opts = []\n    with open(script) as f:\n        for line", "entropy": 77.408130958526}
{"candidate": "RE_OPTS_KEY = re.compile(r'\\s*(--?\\S+)\\s*')\nRE_OPTS_VAL = re.compile(r'\\s*([^,]+)\\s*')\n\n\ndef parse_opts(opts_str, must_parse=False, strict=True):\n    \"\"\"Parse program options from usage string\n\n    Parameters\n    ----------\n    opts_str", "entropy": 77.51088803357896}
{"candidate": "RE_OPTS_SPLIT = re.compile(r'(\\S+)=\"([^\"]+)\"')\n\n\ndef get_parser(parser=None, **kwargs):\n    \"\"\"\n    returns a parser for the given script\n    \"\"\"\n    # guess executable\n    if parser is None:\n        parser = os.path.join(sys.argv[0], os.pardir, 'bin', 'kallisto')", "entropy": 86.110374394928}
{"candidate": "SPLIT = re.compile(r'(?<!\\\\)\\s+').split\n# ((opt, type), ... )\nRE_POS_ARGS = re.compile(r'^([^\\(]*)\\((.*)\\)$')\n\n\ndef get_script_options(script, regex=RE_OPTS):\n    \"\"\"\n    Returns a list of options as passed to an optparse OptionParser for a\n   ", "entropy": 86.71572364688201}
{"candidate": "RE_WORD = re.compile(r'''((?:[^\\s'\"]|'[^']*'|\"[^\"]*\")+)''')\n\n\ndef _get_usage(command, exit_code=2, args=(), prefix=''):\n    '''Get usage text (help string) for a salt command.\n\n    :param str command: The command to get usage for.\n    :param int exit_code:", "entropy": 89.37673500130997}
{"candidate": "RE_YIELD = re.compile(r'''\n    (?x)\n    ((?P<short>\\S) (?P<long>\\S+))\n    \\s+\n    (?P<type>.+?)\n    (?:,\\s*(?P<choices>.+))?\n    $\n''')\n\n\ndef split_optparse_option(x):\n    '''Split an option string", "entropy": 90.29218805196003}
{"candidate": "RE_ARGS = re.compile(r' ([-\\w]+)')\n\n\ndef get_cli_opts(cmd, _RE_OPTS=RE_OPTS, _RE_ARGS=RE_ARGS):\n    '''Get Python-esque tuple of CLI options (cmd: str) -> ((opt, type), ... )'''\n    args = shlex.split(cmd)\n    cmd_name = args[", "entropy": 94.43451524259}
{"candidate": "# RE_SPLIT = re.compile(r'(\\s*--\\S+)')\nRE_SPLIT = re.compile(r'(\\s*[-/]\\w+)')\n\n\ndef parse_options(buf):\n    \"\"\"\n    Parse an executable's help text.\n\n    Mostly a port of the GNU coreutils source code.\n    \"\"\"\n    argv, buf = [], buf.splitlines()", "entropy": 97.878808064772}
{"candidate": "RE_SPLIT = re.compile(r'(?:-{1,2}|/)')\n\ndef parse_opts(opts_str, args, defaults=None):\n    \"\"\"\n    :param opts_str: string containing option descriptions\n    :param defaults: dict of defaults\n    :returns: dict of options, dict of commands\n    \"\"\"\n    # TODO : add choices ...\n    # TODO :", "entropy": 104.50155757693999}
{"candidate": "# (name, [type], [opt, ...])\nRE_SIG = re.compile(r'(?x) (?: ^ )\n( \\w+ )\n(?: \\s+ \\( ([^)]+) \\) ) ?\n\\s* (?: ; )?\n(?: \\s* (?: options? )? : \\s* (.*) ) ?\n(?: $ )\n')\n\n\n# def get_comment_", "entropy": 114.89725524891996}
{"candidate": "# re.compile( r'(\\n\\s{8}[^\\s]+\\s{2,}:\\s.*?,\\n)' )\n\n\ndef load_reopts(opts_fname, strict=False):\n    \"\"\"\n    Return a dictionary of remap options loaded from a text file.\n\n    The ``opts_fname`` parameter is the name of an options file.\n\n    \"\"\"\n    try:\n       ", "entropy": 124.54105218769999}
