{"candidate": "            if not task.deps:\n                n_unique_pending += 1\n            greedy_task = True\n            for resource, amount in task.resources.items():\n                available_amount = used_resources.get(resource, 0) - greedy_resources[resource]\n                if amount > available_amount:\n                    greedy_task = False\n                    break\n            if greedy_task:\n                greedy_workers[task.worker] -= 1", "entropy": 41.13314899996351}
{"candidate": "            if task.status == PENDING:\n                if task.worker == worker.id:\n                    locally_pending_tasks += 1\n                else:\n                    greedy_workers[task.worker] += task.n_workers\n\n            if task.status == RUNNING:\n                running_tasks.append(task)\n            elif task.status == PENDING:\n                assert task.worker is None\n                task_resources =", "entropy": 42.82941543924099}
{"candidate": "            if task.status != PENDING:\n                continue\n\n            for dep in task.deps:\n                if self._state.get_task(dep, default=None).status == FAILED:\n                    break\n            else:\n                greedydeps = self._greedydeps(task)\n                av_resources = self._available_resources(task, greedydeps, used_resources, greedy_resources, greedy_workers)\n", "entropy": 50.57283046570299}
{"candidate": "            if task.status != PENDING:\n                continue\n\n            if not self._task_ready(task):\n                continue\n\n            n_unique_pending += 1\n\n            if best_task is None:\n                # Start with the first non-failed task\n                if task.status != PENDING:\n                    continue\n                best_task = task\n                running_tasks = self._state.get_running_tasks(\n                   ", "entropy": 51.649115075770986}
{"candidate": "            n_unique_pending += task.unique\n            info = {}\n            if task.unique:\n                info['unique'] = True\n                if task.unique_id:\n                    info['unique_id'] = task.unique_id\n            if task.host is not None:\n                info['host'] = task.host\n            if task.deps:\n                info['deps'] = [dep.id for dep in task.", "entropy": 54.92803102188001}
{"candidate": "            # Check if the task is locally pending\n            if not task.key in self._task_to_workers:\n                if self._is_locally_pending(task):\n                    locally_pending_tasks += 1\n                    self._task_to_workers[task.key] = None\n            # Check if the task has already been assigned to a worker\n            if self._task_to_workers.get(task.key):\n", "entropy": 56.19416717029546}
{"candidate": "            if task.host and task.host != host:\n                continue\n\n            if self._task_is_runnable(task):\n                locally_pending_tasks += 1\n                n_unique_pending += 1\n                greedy_task = dict((self._type_key(k, v), v)\n                                   for k, v in task.resources.iteritems())\n                for key, val in greedy_task.iteritems", "entropy": 59.33553609795802}
{"candidate": "            task_resources = self._get_task_resources(task)\n            n_hosts = len(task.hosts)\n            n_workers = task.info.get('workers', 1)\n            n_unique_pending += 1\n            for resource, value in task_resources.items():\n                greedy_resources[resource] += value // n_hosts\n\n            if not self._can_launch(task):\n                continue\n\n", "entropy": 59.67661839413999}
{"candidate": "            if task.status != PENDING:\n                continue\n            if not self._task_ready(task):\n                continue\n\n            n_unique_pending += 1\n\n            if any(self._state.get_task(t).status == FAILED for t in task.deps):\n                continue\n\n            if task.resources is None:\n                # Task is not compatible with any worker, skip it\n                continue\n\n            if not any", "entropy": 59.94577119444042}
{"candidate": "            n_unique_pending += 1\n            # check locally pending\n            if not self._ready_for_pickup(task):\n                locally_pending_tasks += 1\n                continue\n            else:\n                # check globally pending\n                if task.id in used_resources:\n                    continue\n                else:\n                    # check greedy resources\n                    for resource, amount in task.resources.items():\n                        if greedy_resources[resource", "entropy": 60.61933978945101}
{"candidate": "            if task and self.can_start(task):\n                greedy_resources_after_task = used_resources.copy()\n                self._add_task_to_resources(task, greedy_resources_after_task)\n                if self.can_run_on_worker(task, greedy_resources_after_task,\n                                          greedy_workers):\n                    n_unique_pending += 1\n                    self._add_task_", "entropy": 62.07372164411097}
{"candidate": "            locally_pending_tasks += 1\n            if task.id not in self._state.tasks_by_status(RUNNING):\n                for resource, n in task.resources.items():\n                    greedy_resources[resource] += n * greedy_workers[task.worker]\n\n        for task in tasks:\n            # TODO: check if task is still possible\n            if not self._is_task_pending(task):", "entropy": 64.99761961142198}
{"candidate": "            if self._available_resources(task, used_resources) and \\\n                    self._available_resources(task, greedy_resources):\n                if task not in self._state.get_tasks_for_worker(worker.id):\n                    # Locally pending tasks get priority.\n                    if self._locally_pending(task):\n                        best_task = task\n                        break\n\n                    if self._rank(task) is not None:", "entropy": 65.81494156733902}
{"candidate": "            if task.worker is not None:\n                if worker.id != task.worker:\n                    continue\n                running_tasks.append(task)\n            else:\n                # Figure out if we can do this task at all.\n                can_run = True\n                resources = collections.defaultdict(int)\n                for res, req in task.resources.iteritems():\n                    need = req - used_resources.get(res, 0", "entropy": 67.24371613384699}
{"candidate": "            if task.id not in self._task_predecessors:\n                n_unique_pending += 1\n\n            # Check if any pending tasks can be freed up for greedy scheduling\n            for _task in self._state.get_running_tasks() + self._state.get_assisting_tasks():\n                if _task.status in [DONE, FAILED]:\n                    continue\n                task_worker = self._state.", "entropy": 88.63553388414495}
{"candidate": "            if not self._is_ready(task):\n                continue\n            resources = self.get_resources(task)\n            if (any(used_resources[k] + greedy_resources[k] + resources[k] > v\n                    for k, v in self.resources.items())):\n                continue\n\n            # The rank function prioritizes tasks that can be done by\n            # the current machine.\n            # For tasks that are scheduled", "entropy": 90.40707384698997}
{"candidate": "            if not self._task_is_locally_ready(task):\n                continue\n            if task.status == PENDING:\n                n_unique_pending += 1\n\n            # If we are greedy and would pick this task, it should be at least as good as\n            # the best task so far.\n            if task.resource_req.get('greedy', False) and n_unique_pending > 1:\n                resources", "entropy": 91.91415028411394}
{"candidate": "            if not self.can_schedule(task.id):\n                continue\n            n_unique_pending += 1\n            locally_pending_tasks += 1\n            # For each worker, figure out how many resources they could free if they were rescheduled\n            # greedily:\n            for wid, factor in task.resources.items():  # For each worker the task is dependent on\n                greedy_resources[wid] += factor\n", "entropy": 92.92688699899003}
{"candidate": "\n            if not self._can_run_task(task):\n                continue\n\n            # TODO: allow adjusting these resource requirements based on worker resources\n            if task.resources is None:\n                task_resources = {}\n            else:\n                task_resources = task.resources\n\n            # allow for FAILED tasks to be retried if they have no dependents\n            if task.status == FAILED and any(self._state.get_task", "entropy": 97.18531291436298}
{"candidate": "            # Don't return tasks that are already being worked on, or have been\n            # worked on by a worker who is still alive\n            try:\n                task.task_id\n            except AttributeError:\n                continue\n            if task.status == PENDING:\n                if task.worker_id not in self._state.workers:\n                    if self._check_deps(task):\n                        # Check resources\n                        if (task.", "entropy": 95.08036356787298}
