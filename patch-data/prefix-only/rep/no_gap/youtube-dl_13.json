{"candidate": "    if path.startswith(('http://', 'https://')):\n        return path\n    elif path.startswith('/'):\n        url_parsed = compat_urlparse.urlparse(base)\n        return '%s://%s%s' % (url_parsed.scheme, url_parsed.hostname, path)\n    else:\n        return compat_urlparse.url", "entropy": 22.798213304449114}
{"candidate": "    elif path.startswith('http://') or path.startswith('https://'):\n        return path\n    elif path.startswith('//'):\n        return re.sub(r'^(https?)://', r'\\g<1>://', base) + path[1:]\n    elif path.startswith('/'):\n        return base_url(base) + path[1:]\n", "entropy": 23.667141189522006}
{"candidate": "    if isinstance(base, bytes):\n        base = base.decode('utf-8')\n    if not isinstance(base, compat_str):\n        return None\n    if path.startswith('http://') or path.startswith('https://'):\n        return path\n    return compat_urlparse.urljoin(base, path)\n\n\ndef urlencode_postdata(d):\n    # Convert all non", "entropy": 23.836122813275495}
{"candidate": "    scheme, netloc, basepath, query, fragment = compat_urlparse.urlsplit(base)\n    if not basepath:\n        basepath = '/'\n    if path.startswith('?'):\n        basepath = re.sub(r'\\?.*$', '', basepath)\n        path = path.lstrip('?')\n    elif path.startswith('#'):\n", "entropy": 25.363933601598003}
{"candidate": "    if base and not base.endswith('/'):\n        base += '/'\n    if not base.startswith('http'):\n        base = 'http://' + base\n    return compat_urlparse.urljoin(base, path)\n\n\ndef urlencode_postdata(data):\n    if isinstance(data, dict):\n        return compat_urllib_parse_urlencode(data)\n   ", "entropy": 26.842457859044504}
{"candidate": "    if path.startswith('//'):\n        if '://' in base:\n            return compat_urlparse.urlparse(base).scheme + ':' + path\n        else:\n            return 'https:' + path\n    if path.startswith('/'):\n        return base_url(base) + path[1:]\n    return compat_urllib_parse_urljoin(base, path)\n\n\ndef", "entropy": 27.017000518287006}
{"candidate": "    if isinstance(base, bytes):\n        return compat_urlparse.urljoin(base.decode('utf-8'), path)\n    else:\n        return compat_urlparse.urljoin(base, path)\n\n\ndef urldefrag(url):\n    if '#' in url:\n        head, frag = url.split('#', 1)\n        return head + '#', frag\n    else:\n        return", "entropy": 29.432755293815486}
{"candidate": "    if path.startswith('http://') or path.startswith('https://'):\n        return path\n    elif not path.startswith('/'):\n        return compat_urlparse.urljoin(base.replace(' ', '%20'), path.replace(' ', '%20'))\n    else:\n        urlp = compat_urlparse.urlparse(base)\n        return compat_urlparse.urlun", "entropy": 31.777617874343004}
{"candidate": "    if not isinstance(base, compat_str):\n        base = base.decode('utf-8')\n    return compat_urlparse.urljoin(base, path)\n\n\ndef compat_urllib_request_urlopen(url, data=None, timeout=None, context=None, headers=None):\n    req = compat_urllib_request.Request(url, data=data, headers=headers)\n    try", "entropy": 33.0221410450447}
{"candidate": "    return compat_urlparse.urljoin(base, path)\n\n\ndef update_url_query(url, query):\n    \"\"\"Update a URL query string with associated key-value pairs.\"\"\"\n    parsed_url = compat_urlparse.urlsplit(url)\n    qs = compat_parse_qs(parsed_url.query)\n    qs.update(query)\n    return compat_urlparse.urlunsplit", "entropy": 35.42245915924232}
{"candidate": "    try:\n        scheme, netloc, path, query, fragment = compat_urllib_parse_urlparse(path)\n        if not scheme:\n            return compat_urllib_parse_urlparse(compat_urllib_parse_urljoin(base, path)).geturl()\n    except ValueError:\n        pass\n    return path\n\n\ndef unescapeHTML(s):\n    # http://stackoverflow.", "entropy": 36.29619789545599}
{"candidate": "    return compat_urllib_parse.urljoin(base, path)\n\n\ndef int_or_none(v, scale=1, invscale=1, get_attr=None, invget_attr=None):\n    if get_attr:\n        v = get_attr(v, 'value', v)\n    try:\n        return int(v * invscale if invscale != 1 else v / scale)\n    except (", "entropy": 36.54604884694581}
{"candidate": "    scheme, netloc, path_, query, fragment = compat_urlparse.urlsplit(path)\n    return compat_urlparse.urlunsplit((scheme or compat_urlparse.urlparse(base).scheme,\n                                    netloc or compat_urlparse.urlparse(base).netloc,\n                                    path_,\n                                    query,\n                                    fragment))\n\n\ndef get_sorted_path(path):", "entropy": 37.03748400136789}
{"candidate": "    if not url_or_none(path):\n        if not url_or_none(base):\n            return None\n        if path and path[0] == '/':\n            return base_url(base) + path[1:]\n        return base + path\n    if not isinstance(base, compat_str):\n        return path\n    return compat_urllib_parse_urljoin(base, path)\n\n\ndef try_", "entropy": 38.50428909550048}
{"candidate": "    url = compat_urlparse.urljoin(base, compat_urllib_parse_unquote_plus(path))\n    return url if is_url(url) else None\n\n\ndef prepend_extension(filename, new_ext):\n    return re.sub(r'\\.(?P<ext>[^.]*)$', '.%s.\\\\g<ext>' % (new_ext, ), filename)\n\n\ndef", "entropy": 41.621594220362184}
{"candidate": "    elif not any((path.startswith(protocol) for protocol in ('http://', 'https://', 'ftp://'))):\n        path = path.lstrip('/')\n        return compat_urlparse.urljoin(base, path)\n    else:\n        return path\n\n\ndef unescapeHTML(s):\n    return re.sub(r'&(#?)([\\w]+?);', _un", "entropy": 45.281131851617005}
{"candidate": "    parsed_url = compat_urlparse.urlparse(path)\n    if parsed_url.scheme:\n        return parsed_url.geturl()\n    # Ensure non-base path starts with '/'\n    if path[0] != '/':\n        path = '/' + path\n    return compat_urlparse.urljoin(base, path)\n\n\ndef unified_strdate(date):\n    if isinstance(date, dat", "entropy": 50.76607617954728}
{"candidate": "    new_path = urllib_parse.urljoin(base, path)\n    if new_path.startswith('//'):\n        # urljoin converts 'file://host/path' to '//host/path'\n        new_path = 'http:' + new_path\n    return new_path\n\n\ndef url_regex(pattern):\n    return re.compile(r'''(?ix)\n        (", "entropy": 54.17654424957948}
{"candidate": "    path = path.lstrip('/')\n    if '://' not in base:\n        base = base.encode('utf-8')\n    return '/'.join((compat_urlparse.urlparse(base).netloc, path))\n\n\ndef parse_filesize(s):\n    units = [\n        (1024 ** 3, 'G'), (1024 ** 2, 'M'), (1024, 'K'), (1, '", "entropy": 54.88809273518521}
{"candidate": "    if path.startswith('//'):\n        url_parts = urlparse.urlparse(base)\n        netloc = url_parts.netloc\n        path = path[2:]\n        if not netloc:\n            netloc = url_parts.path.split('/')[0]\n        # Fix for broken URLs with %2F in the netloc\n        if '%' in netloc:\n            netloc =", "entropy": 63.64000537803001}
