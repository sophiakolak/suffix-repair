{"candidate": "        xmin_d, xmax_d = x_trf.transform([dL.xmin, dL.xmax])\n        ymin_d, ymax_d = y_trf.transform([dL.ymin, dL.ymax])\n        xsize_d = max(abs(xmax_d - xmin_d), 1e-30)\n        ysize_d = max(abs(ymax_", "entropy": 9.588689232976504}
{"candidate": "        corners = (x_trf.transform(array([dL.xmin, dL.xmax])),\n                   y_trf.transform(array([dL.ymin, dL.ymax])))\n        x0, x1 = corners[0]\n        y0, y1 = corners[1]\n        xsize = max(abs(x1 - x0), 1e-30)\n        ysize = max(", "entropy": 10.792841320103204}
{"candidate": "        corners = (dL.x0, dL.y0), (dL.x1, dL.y0), (dL.x1, dL.y1), (dL.x0, dL.y1)\n        corners = np.array([x_trf.transform(pt) + y_trf.transform(pt)\n                            for pt in corners])\n        x0, y0 = corners.min(axis", "entropy": 11.321597468976998}
{"candidate": "        x_mid = 0.5 * (dL.xmin + dL.xmax)\n        y_mid = 0.5 * (dL.ymin + dL.ymax)\n        x_width = max(abs(dL.xmax - dL.xmin), 1e-30)\n        y_width = max(abs(dL.ymax - dL.ymin), 1e-30)\n        y_", "entropy": 12.539524720805597}
{"candidate": "        xmin_, xmax_ = x_trf.transform([dL.x0, dL.x1])\n        ymin_, ymax_ = y_trf.transform([dL.y0, dL.y1])\n        xsize_ = max(abs(xmax_ - xmin_), 1e-30)\n        ysize_ = max(abs(ymax_ - ymin_), 1e-", "entropy": 14.328448060579401}
{"candidate": "        x_points = np.array([dL.xmin, dL.xmax, dL.xmax, dL.xmin])\n        y_points = np.array([dL.ymin, dL.ymin, dL.ymax, dL.ymax])\n        xy_points = np.vstack((x_points, y_points)).T\n        XY_points = self.transData.transform(", "entropy": 14.484115938321095}
{"candidate": "        corners = (dL.x0, dL.y0), (dL.x1, dL.y0), (dL.x0, dL.y1), (dL.x1, dL.y1)\n        x_corners, y_corners = zip(*map(lambda c: self.transData.transform(c),\n                                        corners))\n        xmin, xmax = min(x_corners),", "entropy": 14.9369624447463}
{"candidate": "        x0, x1 = x_trf.transform_point((dL.x0, dL.x1))\n        y0, y1 = y_trf.transform_point((dL.y0, dL.y1))\n        xcen, ycen = 0.5 * (x0 + x1), 0.5 * (y0 + y1)\n\n        y_exp = y_expander / 2", "entropy": 17.5416348359855}
{"candidate": "        self.set_ylim(np.interp(y_expander * .5,\n                                [0., 1.],\n                                [dL.ymin, dL.ymax]),\n                      np.interp(1 - y_expander * .5,\n                                [0., 1.],\n                                [dL.ymin, dL.ymax]))\n\n    def get_axis_bgcolor(self):", "entropy": 22.128326367562405}
{"candidate": "        xmin, ymin, xmax, ymax = dL.extents\n        y_exp = y_expander / 2\n        y_min_exp = ymin - abs(ymin) * y_exp\n        y_max_exp = ymax + abs(ymax) * y_exp\n        self.set_ybound(y_min_exp, y_max_exp)\n\n    def _set_position(", "entropy": 28.27779743180799}
{"candidate": "        xmax = min(xmax, dL.xmax)\n        xmin = max(xmin, dL.xmin)\n\n        y_expand = (y_expander * (ymax - ymin)) / 2.\n        ymax += y_expand\n        ymin -= y_expand\n\n        self.set_xlim((xmin, xmax), emit=False, auto=None)\n        self.", "entropy": 28.30416339918901}
{"candidate": "        self.set_ylim(((1 + y_expander) *\n                       (y_trf.transform(self.get_ylim()) -\n                        y_trf.transform(dL.y0)) + y_trf.transform(dL.y0)) /\n                      (y_trf.transform(dL.y1) - y_trf.transform(dL.y0)) +\n                      y_trf.", "entropy": 28.360744605112096}
{"candidate": "        self.set_ylim((dL.y0*(1-y_expander) + dL.y1*y_expander,\n                       dL.y1*(1-y_expander) + dL.y0*y_expander))\n\n\nclass PolarAxes(Axes):\n\n    \"\"\"\n    A polar graph projection, where the input dimensions are radius\n    and angle.\n    \"\"\"\n\n    name", "entropy": 30.65675564663494}
{"candidate": "        x_centre = 0.5 * (dL.xmin + dL.xmax)\n        y_centre = 0.5 * (dL.ymin + dL.ymax)\n\n        centre = self.transData.inverted().transform((x_centre, y_centre))\n        x_min = centre[0] - xsize * 0.5 * (1 + y_expander)\n        x_", "entropy": 32.238679894712384}
{"candidate": "        xr = xmax - xmin\n        yr = ymax - ymin\n        ctr = dL.inverse_transformed(np.array([xmin + xr / 2.,\n                                                ymin + yr / 2.]))\n        ctr_x, ctr_y = ctr\n        xr_exp = xr * (1 + y_expander)\n        yr_exp = yr / (1 +", "entropy": 40.98182084705801}
{"candidate": "        x0 = dL.x0; x1 = dL.x1\n        y0 = dL.y0; y1 = dL.y1\n        # If y0 == y1, then try to expand the datalim by 1 in y\n        if y0 == y1:\n            y0 -= 1\n            y1 += 1\n        dy = (y1 - y0)\n        y_expand = y", "entropy": 41.43273961949699}
{"candidate": "        xrange = max(abs(dL.x1 - dL.x0), 1e-30)\n        yrange = max(abs(dL.y1 - dL.y0), 1e-30)\n        y_expander *= (yrange / xrange)\n\n        # Find the range of acceptable values for bottom.\n        ymin = self.dataLim.ymin\n        ymax = self.dataLim.ym", "entropy": 44.603302775612}
{"candidate": "        x_center, y_center = dL.x0 + 0.5 * dL.width, dL.y0 + 0.5 * dL.height\n\n        y_expander *= 0.5\n        x_size = 0.5 * xsize\n        y_size = 0.5 * ysize\n\n        # preserve the ymin, adjust ymax or vice-versa\n        if y_expander > 0:", "entropy": 48.50309299789847}
{"candidate": "        x0, x1 = x_trf.transform([dL.x0, dL.x1])\n        y0, y1 = y_trf.transform([dL.y0, dL.y1])\n        cenx, ceny = map(np.mean, [[x0, x1], [y0, y1]])\n\n        # the amount of the expansion.  0.5 due to x, y", "entropy": 51.115980636149004}
{"candidate": "        dx = dL.width\n        dy = dL.height\n\n        # Find a new width and height for the dataLim based on the\n        # axis aspect ratio\n        if y_expander < 0:\n            # Shrink the height of the axes to match the new aspect.\n            new_height = aspect * dx / xsize * ysize\n            y_zoom = dy / new_height\n        else:\n            # Sh", "entropy": 56.19266539843882}
