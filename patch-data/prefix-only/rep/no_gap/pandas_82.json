{"candidate": "        # GH-25014. We use NaT instead of iNaT, since this eventually\n        # ends up in DatetimeArray.take, which does not allow iNaT.\n        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n       ", "entropy": 3.756626905420201}
{"candidate": "        # GH-25014. We use NaT instead of iNaT, since this eventually\n        # ends up in DatetimeArray.take, which does not allow iNaT.\n        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"][0", "entropy": 5.8618293904502}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        # GH-25014. We use NaT instead of iNaT, since this eventually\n        # ends up in DatetimeArray.take, which does not allow iNaT.\n        return dtype[0], tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n       ", "entropy": 6.307963633290397}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.iNaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], tslibs.iNaT\n    elif \"period\" in upcast_classes:\n        dtype = upcast_classes[\"period\"]\n", "entropy": 6.469196118809999}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], tslibs.NaT\n    elif \"sparse\" in upcast_classes:\n        dtype = upcast_classes[\"sparse\"]\n", "entropy": 7.519253687972801}
{"candidate": "        # GH-25014. We use NaT instead of iNaT, since this eventually\n        # ends up in DatetimeArray.take, which does not allow iNaT.\n        return np.dtype(\"M8[ns]\"), tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        # GH-25014. We use NaT instead of iNaT, since this eventually\n       ", "entropy": 8.236279587627998}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], tslibs.NaT\n    elif \"mixed\" in upcast_classes:\n        return np.dtype(np.object_), np", "entropy": 8.813401090778}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], NaTd\n    elif \"period\" in upcast_classes:\n        dtype = upcast_classes[\"period\"]\n        return dtype[0], NaT\n   ", "entropy": 10.193119662549002}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], pd.NaT\n    elif \"mixed\" in upcast_classes:\n        return np.dtype(np.object_), np.nan", "entropy": 11.209222051714002}
{"candidate": "        return _coerce_to_dtype(upcast_classes[\"datetime\"])\n    elif \"timedelta\" in upcast_classes:\n        return _coerce_to_dtype(upcast_classes[\"timedelta\"])\n    elif \"integer\" in upcast_classes:\n        return _coerce_to_dtype(upcast_classes[\"integer\"])\n    elif \"s", "entropy": 12.989520001821404}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        if is_dtype_equal(dtype[0], np.dtype(\"M8[ns]\")):\n            return dtype[0], tslibs.NaT\n        else:\n            return np.dtype(\"M8[ns]\"), tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        dtype =", "entropy": 13.875010130546297}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.iNaT\n    elif \"timedelta\" in upcast_classes:\n        return np.dtype(\"m8[ns]\"), tslibs.iNaT\n    elif \"integer\" in upcast_classes:\n        dtype = upcast_classes[\"integer\"]\n        max_int = np.i", "entropy": 15.352043921357003}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.iNaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], tslibs.iNaT\n    elif \"float\" in upcast_classes:\n        # floats\n        dtype = upcast_classes", "entropy": 15.718424043792}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], np.datetime64('NaT', 'ns')\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], np.timedelta64('NaT', 'ns')\n    elif \"period\" in upcast_classes:\n        return np", "entropy": 15.843441067553995}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.iNaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], np.timedelta64(\"NaT\", \"ns\")\n    elif \"sparse[int32]\" in upcast_classes:\n        return Sp", "entropy": 18.645408468002998}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        raise AssertionError(dtype)\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        raise AssertionError(dtype)\n    elif \"date\" in upcast_classes:\n        return np.dtype(np.object_), np.nan\n    elif \"int\"", "entropy": 18.841212336474502}
{"candidate": "        # GH-25014. We use NaT instead of iNaT, since this eventually\n        # ends up in DatetimeArray.take, which does not allow iNaT.\n        dtype = upcast_classes[\"datetime\"]\n        if len(dtype) > 1:\n            return np.dtype(\"M8[ns]\"), tslibs.NaT\n        else:\n            # We use NaT instead of i", "entropy": 20.508094628568}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.NaT\n    elif \"timedelta\" in upcast_classes:\n        return _get_dtype_with_highest_precision(upcast_classes[\"timedelta\"])\n    elif \"string\" in upcast_classes:\n        return _get_dtype_with_highest_precision(upcast", "entropy": 22.096596559348804}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.iNaT\n    elif \"timedelta\" in upcast_classes:\n        dtype = upcast_classes[\"timedelta\"]\n        return dtype[0], tslibs.NaTd\n    elif \"complex\" in upcast_classes:\n        # we don't allow complex numerics\n        raise", "entropy": 24.200050710485996}
{"candidate": "        dtype = upcast_classes[\"datetime\"]\n        return dtype[0], tslibs.NaT\n    elif \"datetime64\" in upcast_classes:\n        dtype = upcast_classes[\"datetime64\"]\n        return (\n            np.dtype(np.float64),\n            getattr(tslibs.NaT, \"value\", tslibs.NaT),\n        )\n", "entropy": 24.959365458974005}
