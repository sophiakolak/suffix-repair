{"candidate": "    url_path = urlparse.urlparse(url).path\n    return os.path.basename(url_path)\n\n\ndef url_basename_ext(url):\n    url_path = urlparse.urlparse(url).path\n    return os.path.splitext(os.path.basename(url_path))", "entropy": 24.398724950042002}
{"candidate": "    \"\"\"\n    Get the basename of a URL.\n\n    >>> url_basename('http://example.com/path/to/foo.bar.bz2')\n    u'foo.bar.bz2'\n    >>> url_basename('http://example.com/path/to/')\n    u''\n    >>> url_basename('http://example.com/path/to')\n    u''\n    >>> url", "entropy": 31.690216908979995}
{"candidate": "    url = url.split('#', 1)[0].split('?', 1)[0]\n    return os.path.basename(url)\n\n\ndef url_dirname(url):\n    url = url.split('#', 1)[0].split('?', 1)[0]\n    return os.path.dirname(url)\n\n\ndef write_text_to_file(text, filepath):\n    with open(file", "entropy": 34.313659372238}
{"candidate": "    return posixpath.basename(urlparse.urlsplit(url)[2])\n\n\ndef url_filename(url):\n    return posixpath.splitext(url_basename(url))[0]\n\n\ndef url_ext(url):\n    return posixpath.splitext(url_basename(url))[1]\n\n\ndef get_images_dir():\n    \"\"\"\n    Return the images directory path\n\n", "entropy": 47.14488724588999}
{"candidate": "    \"\"\"Extract and return basename (last component of URL path)\"\"\"\n    return posixpath.basename(urlparse(url).path.rstrip(u'/'))\n\n\ndef url_basename_keep_ext(url):\n    \"\"\"Extract and return basename (last component of URL path)\"\"\"\n    return posixpath.splitext(posixpath.basename(\n        urlparse(url).path.r", "entropy": 49.79398160270499}
{"candidate": "    \"\"\"Return the basename of the url, or the url itself if there is no basename\"\"\"\n    try:\n        return os.path.basename(urllib.request.urlparse(url).path)\n    except ValueError:\n        return url\n\n\ndef url_unquote(s, encoding='utf-8', errors='strict'):\n    if s is None:\n        return None\n    return urllib.un", "entropy": 51.70726081474099}
{"candidate": "    if '?' in url:\n        url = url[:url.find('?')]\n    return os.path.basename(url)\n\n\ndef url_basename_noext(url):\n    return os.path.splitext(url_basename(url))[0]\n\n\ndef sanitize_path(path, base_dir=None, new_ext=None):\n    \"\"\"Sanitize a relative path\n\n", "entropy": 52.80206219102401}
{"candidate": "    \"\"\"Basename for URL (not URL-encoded)\"\"\"\n    try:\n        from urllib.parse import urlsplit\n    except ImportError:\n        from urlparse import urlsplit\n    s = remove_start(urlsplit(url).path, '/')\n    return os.path.splitext(s)[0]\n\n\ndef to_unicode(obj, encoding='utf-8'):\n    \"\"\"", "entropy": 55.49269381442251}
{"candidate": "    \"\"\"Return the base name of the URL path\n\n    >>> url_basename('http://example.com/path/to/foo')\n    'foo'\n    >>> url_basename('http://example.com/path/with/trailing/slash/')\n    ''\n    >>> url_basename(u'http://example.com/')\n    ''\n    >>> url_basename('x-foo://foo/bar')", "entropy": 55.99274099916402}
{"candidate": "    return remove_start(urlparse.urlparse(url)[2], '/').split('/', 1)[0]\n\n\ndef url_basename_ext(url):\n    return url_basename(url).rsplit('.', 1)\n\n\ndef url_basename_url(url):\n    name, ext = url_basename_ext(url)\n    return name.replace('%', '_'), ext or None\n\n", "entropy": 56.07093719628299}
{"candidate": "    return os.path.basename(urlparse(url).path)\n\n\ndef prepend_extension(filename, extension):\n    \"\"\"Prepend an extension to a filename\"\"\"\n    # http://stackoverflow.com/a/171410\n    name, ext = os.path.splitext(filename)\n    return name + extension + ext\n\n\ndef get_extension(filename):\n    \"\"\"Return the extension of a filename", "entropy": 56.40879243199098}
{"candidate": "    return url.rpartition('/')[2]\n\n\ndef url_domain(url):\n    # TODO: Try to fix this\n    return url.split('/')[2].replace(':', '_')\n\n\ndef url_hostname(url):\n    # TODO: Try to fix this\n    return url.split('/')[2]\n\n\ndef url_scheme(url):\n    return parse_url", "entropy": 65.70533803165502}
{"candidate": "    return remove_start(url, strip_string(os.path.sep) + strip_string(os.path.sep))\n\n\ndef subprocess_check_output(*args, **kwargs):\n    \"\"\"Python 2.7 compatibility\"\"\"\n    if 'shell' not in kwargs:\n        kwargs['shell'] = False\n    if hasattr(subprocess, 'check_output'):\n        try:\n           ", "entropy": 66.09514404102899}
{"candidate": "    \"\"\"Removes the URL suffix, if any\"\"\"\n    p = urlparse(url)\n    basename = p.path\n    return basename.rsplit('/', 1)[-1]\n\n\ndef extract_width(s):\n    \"\"\"Extract the width from a string that looks like '123x456'\"\"\"\n    m = re.match(r'^(\\d+)x(\\d+)$', s)\n    if m", "entropy": 73.58065965410397}
{"candidate": "    return remove_start(urlparse(url)[2], '/').split('/')[-1]\n\n\ndef get_xvfb_display():\n    \"\"\"\n    If a display is already set in the environment, return it.\n    Otherwise, create a new Xvfb virtual display.\n    \"\"\"\n    if os.environ.get('DISPLAY'):\n        return os.environ['DISPLAY']\n    port = str(", "entropy": 74.83756259904203}
{"candidate": "    \"\"\"Get the basename from the url\"\"\"\n    if url.find('://') == -1:\n        url = 'file://' + url\n\n    url = urlparse.urlparse(url).path.rstrip('/')\n\n    base = os.path.basename(url)\n    return base\n\n\ndef get_content_type(filename):\n    \"\"\"Get the content type of a file using its filename\"\"\"\n    if filename.", "entropy": 76.30916155725002}
{"candidate": "    last_separator_index = max(\n        url.rindex('/'),\n        url.rindex('\\\\'))\n    return url[last_separator_index + 1:]\n\n\ndef is_in_dir_case_insensitive(file_path, dir_path):  # TODO: test this on osx\n    norm_file_path = os.path.normpath(os.path.normcase(file_", "entropy": 76.69897640463098}
{"candidate": "    \"\"\" Return the basename of an url, no matter the url ends with a '/' or not. \"\"\"\n    s = url\n    if s.endswith(u'/'):\n        s = s[:-1]\n    return s.rsplit('/', 1)[1]\n\n\ndef listdir_dirs(dirname):\n    \"\"\"\n    Return the list of directories in a directory (not the files), including '.' and", "entropy": 88.866778590205}
{"candidate": "    # Only for paths (assume no query string)\n    return posixpath.basename(urlsplit(url).path)\n\n\ndef i18n_patterns(*urls):\n    \"\"\"\n    Uses the selected language code in the URL pattern.\n    \"\"\"\n    try:\n        return [I18nRegexURLResolver(url, settings.I18N_URLS_CONF_MODULE)\n                for url in", "entropy": 94.004817236934}
{"candidate": "    return basename(urlsplit(url).path)", "entropy": 14.3810021574}
