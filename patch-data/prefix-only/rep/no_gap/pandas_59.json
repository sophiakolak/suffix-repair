{"candidate": "        return super().corr(other=other, pairwise=pairwise, **kwargs)\n\n    def cov(self, other=None, pairwise=None, ddof=1, **kwargs):\n        if other is None:\n            other = self._selected_obj\n            # only default unset\n            pairwise = True if pairwise is None else pairwise\n        other = self._shallow_copy(other)\n        return", "entropy": 6.690953213326502}
{"candidate": "\n        return super().corr(other=other, pairwise=pairwise, **kwargs)\n\n\nclass Rolling(_Rolling_and_Expanding):\n    \"\"\"\n    Provide rolling window calculations.\n\n    Parameters\n    ----------\n    window : int\n        Size of the moving window. This is the number of observations\n        used for calculating the statistic. Each window will be a fixed\n        size.\n    min_periods : int, default None", "entropy": 13.636967097341}
{"candidate": "        return super().corr(other=other, pairwise=pairwise, **kwargs)\n\n    _agg_doc = dedent(\n        \"\"\"\n    Aggregate using one or more operations over the specified axis.\n    %(versionadded)s\n\n    Parameters\n    ----------\n    arg\n        Function to use for aggregating the data. If a function, must either\n        work when passed a {klass} or when passed to {k", "entropy": 14.255434651380002}
{"candidate": "        return super().corr(other=other, pairwise=pairwise, **kwargs)\n\n\nclass Window(_Rolling_and_Expanding):\n    r\"\"\"\n    Provide rolling window calculations.\n\n    Parameters\n    ----------\n    window : int, offset, or BaseIndexer subclass\n        Size of the moving window. This is the number of observations used for\n        calculating the statistic. Each window will be a fixed size.\n\n        If its", "entropy": 14.4248309115565}
{"candidate": "\n        return rolling_corr(self._selected_obj, other, self._on, pairwise)\n\n\nclass Rolling(_Rolling_and_Expanding):\n    _attributes = [\n        \"count\",\n        \"sum\",\n        \"mean\",\n        \"median\",\n        \"min\",\n        \"max\",\n        \"var\",\n        \"std\",\n        \"skew\",\n        \"kurt\",\n        \"", "entropy": 23.102888863484697}
{"candidate": "\n        def _get_corr(a, b):\n            a, b = self._prep_other(a, b)\n            if isna(a).any() or isna(b).any():\n                return np.nan\n\n            if not isinstance(a, np.ndarray):\n                a = a.values\n            if not isinstance(b, np.ndarray):\n                b = b.values\n\n            return nanops", "entropy": 26.893662011625093}
{"candidate": "        return Rolling.corr(self, other, pairwise=pairwise, **kwargs)\n\n    cov = _doc_template(\"\"\"\n    Compute covariance of two Series.\n\n    Parameters\n    ----------\n    other : Series, DataFrame, or ndarray, optional\n        If not supplied then will default to self and produce pairwise output.\n    ddof : int, default 1\n        Delta Degrees of Freedom.  The div", "entropy": 28.376984594042}
{"candidate": "        return corr(self._selected_obj, other=other, pairwise=pairwise, **kwargs)\n\n    def count(self, **kwargs):\n        \"\"\"\n        Compute count of non-NaN observations.\n\n        Parameters\n        ----------\n        **kwargs\n            For compatibility. Has no effect on the computed value.\n\n        Returns\n        -------\n        counts : DataFrame\n        \"\"\"\n        window = self._get_", "entropy": 28.523214471397004}
{"candidate": "\n        if pairwise == \"columns\":\n            return self._constructor(\n                Rolling.corr, (\"X\", \"Y\"), self, other, pairwise=True, **kwargs\n            )\n        elif pairwise == \"rows\" or pairwise is True:\n            return self._constructor(\n                lambda x, y: Rolling.corr(x, y, pairwise=False),\n                self._selected_obj.column", "entropy": 30.101562112434003}
{"candidate": "\n        def _get_corr(a, b):\n            a, b = _prep_binary(a, b)\n            if pairwise:\n                if not a.index.equals(b.index):\n                    raise ValueError(\"Can only compute pairwise correlation \"\n                                     \"with matching indexes\")\n            return a.corrwith(b, **kwargs)\n\n        return self._apply(_get_corr, other, pair", "entropy": 30.789459955483338}
{"candidate": "        kwargs.update(pairwise=pairwise)\n        window = self._get_window(other)\n        return window.corr(other=other, **kwargs)\n\n    _agg_doc = dedent(\n        \"\"\"\n    Aggregate using one or more operations over the specified axis.\n    %(versionadded)s\n\n    Parameters\n    ----------\n    arg\n        List, dict, or set of operations to apply to", "entropy": 33.9322335687348}
{"candidate": "        window = self._get_window(other)\n\n        def _get_corr(X, Y):\n            return X.corr(Y, **kwargs)\n\n        return_pairwise = True if pairwise is not None else False\n\n        return_windows = [\n            _use_window(X, Y, window, f, pairwise=pairwise)\n            for X, Y, f in zip(\n                self._selected_", "entropy": 35.14078684105851}
{"candidate": "\n        # compute the correlation matrix\n        result = rolling_cov(self, other, pairwise=pairwise)\n        result = divide(result, self.std(ddof=0), other.std(ddof=0))\n\n        return self._wrap_result(result)\n\n    def covariance(self, other=None, pairwise=None, ddof=1, **kwargs):\n        \"\"\"\n        Compute windowed covariance", "entropy": 39.081082842713194}
{"candidate": "\n        # GH 11343: rolling corr with missing values\n        if isinstance(self._selected_obj, ABCDataFrame):\n\n            def f(x, y):\n                if np.any(isna(x)) or np.any(isna(y)):\n                    return np.nan\n                return nanops.nancorr(x, y)\n\n            return self._binary_moment(\n                other, f, pairwise=", "entropy": 44.64235906109029}
{"candidate": "\n        return algorithms.Rolling.corr(\n            self._selected_obj, other=other, window=self._window, min_periods=self.min_periods, center=self.center,\n            expand=self.expand, pairwise=pairwise, **kwargs)\n\n    @Substitution(\n        cov=dedent(\n            \"\"\"\n    Calculate covariance between two Series or DataFrame columns using\n    non", "entropy": 46.56579893178999}
{"candidate": "\n        # GH 18296\n        if isinstance(other, (ABCSeries, ABCDataFrame)):\n            return rolling_corr(\n                other.reindex(self.window),\n                self._selected_obj,\n                self._on,\n                pairwise=pairwise,\n                **kwargs\n            )\n        elif isinstance(other, GroupBy):\n            return rolling_apply(\n                self._selected_obj,\n", "entropy": 47.26722304734103}
{"candidate": "\n        self._on_pandas_invalid_kwargs(\"corr\", kwargs)\n\n        return pairwise_corr(self, other, pairwise)\n\n    def cov(\n        self, other=None, pairwise=None, ddof=1, sample=True, **kwargs\n    ):\n        \"\"\"\n        Compute covariance with `other` Series, excluding missing values.\n\n        Covariance, the average of", "entropy": 60.292283115577995}
{"candidate": "\n        def _get_corr(X, Y):\n            # We need to use mask here to maintain dtype and avoid all-NaN\n            # slices falling thru to None\n            mask = notna(X) & notna(Y)\n\n            if mask.all():\n                return lib.corr_single(X, Y, **kwargs)\n            elif not mask.any():\n                return np.nan\n            else:\n", "entropy": 60.69441287052201}
{"candidate": "\n        # GH #12373\n        # correlating with self, we use cov_pairwise\n        # to mimic DataFrame.corr() behavior\n        # if pairwise is not None:\n        this, other = self._prep_other(other, pairwise=pairwise)\n\n        window = self._get_window(other)\n\n        def correlation(one, two):\n            return one.cov(two, pairwise=pairwise)", "entropy": 66.91047645397431}
{"candidate": "        return corr(self, other=other, pairwise=pairwise, **kwargs)\n\n    correl = _flex_method(\n        _doc_template.format(\n            name=\"correl\",\n            desc=\"\"\"\n    Rolling pearson correlation.\n    Compute the Pearson correlation coefficient,\n    between `self` and other DataFrame.\n    \"\"\",\n        )\n    )(corr)\n    autocorr = _", "entropy": 71.12579126608102}
