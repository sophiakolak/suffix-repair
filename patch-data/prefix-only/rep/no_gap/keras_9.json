{"candidate": "\n    if ending_point == -1 or ending_point > section_end:\n        ending_point = section_end\n\n    lines = docstring[starting_point: ending_point].split('\\n')\n\n    # Remove the computed number of leading white spaces from each line.\n    lines = [re.sub('^' + ' ' * leading_spaces, '', line) for line in lines]\n\n    # Usually lines have at least 4", "entropy": 12.625116937113699}
{"candidate": "    if ending_point == -1:\n        ending_point = section_end\n    block = docstring[starting_point: ending_point]\n\n    # Place marker for later reinjection.\n    docstring = docstring.replace(block, marker)\n\n    lines = block.split('\\n')\n    for i in range(len(lines)):\n        lines[i] = lines[i][leading_spaces:]\n        lines", "entropy": 17.4800181350015}
{"candidate": "\n    if ending_point == -1 or ending_point > section_end:\n        ending_point = section_end\n\n    block = docstring[starting_point: ending_point]\n    processed_block = re.sub(' {' + str(leading_spaces) + '}', '', block)\n    processed_block = marker + ' ' + processed_block + '\\n\\n'\n    return processed_block\n\n\ndef", "entropy": 18.396644178853805}
{"candidate": "\n    if ending_point == -1 or ending_point > section_end:\n        ending_point = section_end\n\n    list_string = docstring[starting_point: ending_point]\n\n    # figure out the common leading spaces\n    spaces = 100\n    for line in list_string.split('\\n'):\n        spaces = min(spaces, count_leading_spaces(line))\n\n    if spaces > 0:\n       ", "entropy": 18.4645293105178}
{"candidate": "    if ending_point == -1 or ending_point > section_end:\n        ending_point = section_end\n    block = docstring[starting_point:ending_point]\n    # Place marker for later reinjection.\n    docstring = docstring.replace(block, marker)\n    # Remove leading spaces.\n    lines = block.split('\\n')\n    lines = [line[leading_spaces:] for line in lines", "entropy": 18.300092903455795}
{"candidate": "    block = docstring[starting_point:ending_point]\n    lines = block.split('\\n')\n\n    # Remove leading spaces\n    lines = [line[leading_spaces:] for line in lines]\n\n    # Remove first and last lines if they are empty\n    if lines and not lines[0]:\n        lines.pop(0)\n    if lines and not lines[-1]:\n        lines.pop(-1)\n\n   ", "entropy": 19.883681438598504}
{"candidate": "    block = docstring[starting_point:ending_point].split('\\n')\n    for i in range(len(block)):\n        if i == 0:\n            block[i] = block[i].lstrip(' ')\n        if i == len(block) - 1:\n            block[i] = block[i].rstrip(' ')\n        if count_leading_spaces(block[i]) != leading_", "entropy": 24.827598752292506}
{"candidate": "    block = docstring[starting_point:ending_point]\n    # Place marker for later reinjection.\n    docstring = docstring.replace(block, marker)\n    block_lines = block.split('\\n')[1:]\n    indent = count_leading_spaces(block_lines[0])\n    ret = ''\n    for line in block_lines:\n        text = '    ' + line[indent:] +", "entropy": 25.6942376158545}
{"candidate": "\n    if ending_point == -1 or ending_point > section_end:\n        ending_point = section_end\n\n    # place marker for later reinjection\n    docstring = docstring[:starting_point] + marker + docstring[starting_point:]\n\n    list_str = docstring[starting_point:ending_point]\n\n    # divide into individual items\n    list_items = [i.strip(' ') for i in list", "entropy": 28.820894402935902}
{"candidate": "\n    # Find the index of the last character in the block\n    if ending_point != -1 and ending_point <= section_end:\n        block = docstring[starting_point:ending_point]\n    else:\n        block = docstring[starting_point:]\n\n    # Determine the common leading whitespace for the block\n    common_leading_spaces = 1e6\n    for line in block.split('\\n')[1", "entropy": 29.675453084846797}
{"candidate": "    if ending_point == -1:\n        ending_point = section_end\n    snippet = docstring[starting_point:ending_point]\n    snippet = snippet.replace('\\t', '    ')\n    lines = snippet.split('\\n')\n\n    # Get the common leading space of all lines\n    shift = 100\n    for line in lines:\n        if line == '':\n            continue\n        leading_spaces =", "entropy": 29.83308355730649}
{"candidate": "    if ending_point == -1:\n        ending_point = section_end\n    block = docstring[starting_point: ending_point]\n    lines = block.split('\\n')\n    # Find indentation of first line of the list.\n    counter = 0\n    while lines[counter].startswith(marker):\n        counter += 1\n    indent1 = count_leading_spaces(lines[counter])\n   ", "entropy": 38.69220971917701}
{"candidate": "\n    raw_block = docstring[starting_point:section_end].strip('\\n')\n    processed_block = raw_block\n\n    # Find the character that indicates a code block.\n    if marker == '-':\n        code_block_indicator = ':'\n    else:\n        code_block_indicator = marker\n\n    if code_block_indicator in processed_block:\n        split_index = processed_block.", "entropy": 44.69984533474691}
{"candidate": "\n    # Find the first indented block\n    pos = docstring.find('\\n' + ' ' * (leading_spaces + 4), starting_point)\n    if (pos > 0 and pos < ending_point):\n        # Indented block.\n        # Recurse to get the enclosed block and then continued\n        # after the block.\n        inner_block, final_pos = process_list_block(\n            docstring, pos", "entropy": 45.295304310491815}
{"candidate": "    if ending_point == -1 and section_end < starting_point:\n        ending_point = section_end\n    elif ending_point == -1:\n        raise ValueError('List is missing the closing an empty line.')\n    if section_end < ending_point < starting_point:\n        ending_point = section_end\n\n    list_string = docstring[starting_point:ending_point]\n    lines = list", "entropy": 47.2449273902262}
{"candidate": "    block = docstring[starting_point: section_end].strip()\n    block = re.sub('  ', '\\t', block)\n    block = block.rstrip('|')\n    lines = block.split('\\n')\n    lines = [l.rstrip().rstrip('|') for l in lines]\n    indent = float('inf')\n    for line in lines:\n        if line.endswith(':", "entropy": 48.133652266065496}
{"candidate": "\n    # If there are no more paragraphs before the next section,\n    # search for the next section.\n    if ending_point < 0:\n        ending_point = section_end\n\n    # List item texts are indented, so remove the common leading\n    # whitespace from each item.\n    raw_block = docstring[starting_point:ending_point].rstrip()\n    lines = raw_block.split('\\n')\n\n   ", "entropy": 49.93414072648459}
{"candidate": "    if ending_point == -1:\n        ending_point = section_end\n    block = docstring[starting_point:ending_point]\n    if block.count(marker) == 1:\n        # No lists included, just return\n        return docstring[:starting_point] + docstring[ending_point:], 0\n\n    lines = docstring[starting_point:ending_point].split('\\n')\n    new", "entropy": 52.98296165743301}
{"candidate": "    block = docstring[starting_point:ending_point]\n\n    # Remove the last \\n\n    block = block[:-1]\n\n    if len(block) != 0:\n        # split into a list (lines of the list)\n        lines = block.split('\\n')\n\n        # remove empty lines\n        lines = [line for line in lines if len(line) != 0]\n        # remove the common spaces from the beginning", "entropy": 72.935680518082}
{"candidate": "\n    # Consistency check\n    if docstring[section_end:section_end + 2] != '\\n\\n':\n        raise ValueError('List is not followed by a double newline.')\n\n    # Accumulate list items into a list\n    items = []\n    item = ''\n    empty_item = True\n    first = True\n    inside_code_block = False\n    item_starting_spaces = np.", "entropy": 75.1583675355405}
