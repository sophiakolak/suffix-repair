{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # Datetime dtypes must be come to this path for NumPy 1.7.1 compat\n    elif is_datetime64_dtype(left) or is_datetime64_dtype(right):\n\n        if not strict_nan:\n            # isna considers NaN and None to be equivalent.\n            return lib.array_equivalent_", "entropy": 14.664298037297002}
{"candidate": "                if left_value != right_value:\n                    return False\n    elif is_datetimetz(left) or is_datetimetz(right):\n\n        if not strict_nan:\n            # isna considers NaN and None to be equivalent.\n            return lib.array_equivalent_object(\n                ensure_object(left.ravel()), ensure_object(right.ravel())\n            )\n\n        # GH#23", "entropy": 26.166380039074}
{"candidate": "                if left_value != right_value:\n                    return False\n        return True\n\n    # some dtypes are not supported by isna\n    if is_object_dtype(left) or is_object_dtype(right):\n        if strict_nan:\n            for left_value, right_value in zip(left.ravel(), right.ravel()):\n                if left_value is None and right_value is not None:\n                   ", "entropy": 35.476688960968005}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # extension types\n    if is_extension_array_dtype(left):\n        left = left.values\n\n    if is_extension_array_dtype(right):\n        right = right.values\n\n    # numpy compat\n    typ = left.dtype.type\n\n    if issubclass(typ, (np.datetime64,", "entropy": 40.00895884271359}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n    else:\n        return lib.array_equivalent(left, right)\n\n\ndef _possibly_cast_item(obj, item, dtype):\n    chunk = obj[item]\n\n    # we might have a non-scalar type block here\n    # so coerce to a compatible dtype\n    if chunk.values.dtype != dtype", "entropy": 42.72822110577398}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    return _array_equivalent(left, right, strict_nan=strict_nan)\n\n\ndef _array_equivalent(left, right, strict_nan=False, assume_unique=False):\n    \"\"\" array_equivalent with dtypes and assume_unique \"\"\"\n    if assume_unique:\n        left, right = np.asarray(left", "entropy": 50.98933257097102}
{"candidate": "                if left_value != right_value:\n                    return False\n        return True\n    else:\n\n        # if not Datetime, Timedelta or Integer,\n        # then convert to a numpy object\n        if not (is_datetime64_dtype(left) or is_timedelta64_dtype(left)):\n            left, right = left.astype(object), right.astype(object)\n\n        #", "entropy": 54.76435010959259}
{"candidate": "                if left_value != right_value:\n                    return False\n    else:\n        # TODO: NaT\n\n        # compare if values is nan\n        if strict_nan and not (isna(left) & isna(right)).all():\n            return False\n\n        # compare other values\n        if not np.array_equal(left, right):\n            return False\n\n    return True\n\n\ndef _compare_or_repr", "entropy": 60.940395217625}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        # we are not equal if we are not nan\n        return True\n\n    # NaT-aware equals\n    elif ((not strict_nan) and\n          is_datetime64_dtype(left) and is_datetime64_dtype(right)):\n\n        # allow object array to pass by\n        if ((is_object_dtype(left) and is", "entropy": 85.91012517140302}
{"candidate": "                if left_value != right_value:\n                    return False\n        return True\n\n    # avoid double checking NaN values (and NaT for datetimelike)\n    # we already checked for those if the dtype was object,\n    # so skip them for non-object dtypes\n    if not strict_nan:\n        left = np.asarray(left).copy()\n        left[pd.isna(left)] = np", "entropy": 94.02272444774799}
