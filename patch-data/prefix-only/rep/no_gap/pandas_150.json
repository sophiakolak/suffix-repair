{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    elif is_datetime64_dtype(left) and is_datetime64_dtype(right):\n\n        if not strict_nan:\n            return lib.array_equivalent_datetime(left.ravel(), right.ravel())\n\n        for left_value, right_value in zip(left, right):\n            if left_value is Na", "entropy": 13.780429991962494}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # datetimelike\n    if is_datetime64_dtype(left) or is_datetime64tz_dtype(left):\n        if not (is_datetime64_dtype(right) or is_datetime64tz_dtype(right)):\n            return False\n\n    # datetime64tz compat\n    if is", "entropy": 22.224071930657995}
{"candidate": "                if not left_value == right_value:\n                    return False\n\n        return True\n\n    if left.dtype != right.dtype:\n        try:\n            left, right = left.astype(object), right.astype(object)\n            return array_equivalent(left, right)\n        except (ValueError, TypeError):\n            pass\n\n        return False\n\n    left = left.ravel()\n    right = right.", "entropy": 22.611599940065002}
{"candidate": "                if left_value != right_value:\n                    return False\n        return True\n\n    if is_complex_dtype(left) or is_complex_dtype(right):\n        return np.all(left == right)\n\n    # datetimelike compat\n    if is_datetime64_dtype(left) or is_datetime64_dtype(right):\n        if is_datetime64_dtype(left", "entropy": 22.97153711778}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # datetime64 compat\n    if is_datetime64_dtype(left) and is_datetime64_dtype(right):\n        return lib.array_equivalent(np.asarray(left), np.asarray(right))\n\n    # timedelta64 compat\n    if is_timedelta64_dtype(left) and is", "entropy": 23.942082450387606}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    if is_sparse(left) and is_sparse(right):\n        left, right = left.toarray(), right.toarray()\n\n    if is_extension_type(left):\n        return left.equals(right)\n\n    if is_extension_array_dtype(left):\n        return left.array_equivalent(", "entropy": 28.694824037105633}
{"candidate": "                if left_value is not right_value:\n                    return False\n\n        return True\n\n    # name compat\n    if hasattr(left, \"name\") and hasattr(right, \"name\"):\n        if getattr(left, \"name\") != getattr(right, \"name\"):\n            return False\n\n    # dtype compat\n    if (\n        left.dtype != right.dtype\n        and not (strict_", "entropy": 35.117402684784}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # check datetime64 on both sides\n    if is_datetime64_dtype(left):\n        if is_object_dtype(right):\n            return lib.array_equivalent_object(\n                left.ravel(), ensure_object(right.ravel())\n            )\n        return lib.array_equivalent_datetime64(left.", "entropy": 37.130949527713994}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    if not is_bool_dtype(left) and not is_bool_dtype(right):\n        # compare other non-string, non-bool dtypes\n        return lib.array_equivalent(_ensure_object(left.ravel()),\n                                    _ensure_object(right.ravel()))\n\n    if left.dtype != right", "entropy": 40.667800515816026}
{"candidate": "                if not left_value == right_value:\n                    return False\n        return True\n\n    # valid for numeric\n    if issubclass(left.dtype.type, (np.datetime64, np.timedelta64)):\n        return not isinstance(left, np.datetime64) and not isinstance(right, np.datetime64)\n    elif issubclass(left.dtype.type, (np", "entropy": 40.74080024240204}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # skip NaN check for non-numerical dtypes\n    if not np.issubdtype(left.dtype, np.number) or not np.issubdtype(\n        right.dtype, np.number\n    ):\n        return np.array_equal(left, right)\n\n    # Check if the arrays are equal ignoring Na", "entropy": 41.618323523388014}
{"candidate": "                if left_value != right_value:\n                    return False\n\n    elif is_object_dtype(left) or is_object_dtype(right):\n        # e.g. both datetime64[ns]\n        return lib.array_equivalent_object(\n            ensure_object(left.ravel()), ensure_object(right.ravel())\n        )\n\n    # compare other types\n    return not np.any(", "entropy": 43.10688038936339}
{"candidate": "                if left_value != right_value:\n                    return False\n\n    else:\n        if not strict_nan:\n            # NumPy has an array_equivalent that handles nan\n            return np.array_equivalent(left, right)\n\n        # need to handle NaT\n        for left_value, right_value in zip(left, right):\n            if left_value is NaT and right_value is not NaT:\n               ", "entropy": 46.24726154192599}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    if not strict_nan:\n        if is_float_dtype(left) or is_float_dtype(right):\n\n            # nan != nan\n            with np.errstate(invalid=\"ignore\"):\n                result = (\n                    left.ravel() == right.ravel()\n                )  # this results in False if either is NaN\n\n", "entropy": 46.60369721579999}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # Valid dtypes: anything but object or datetime64\n    if left.dtype.kind != right.dtype.kind:\n        return False\n\n    # non-numeric dtypes (e.g. datetime64, timedelta64)\n    if not is_numeric_dtype(left):\n        return np.all(left == right", "entropy": 52.519634734551616}
{"candidate": "                if left_value != right_value:\n                    return False\n        return True\n\n    # datetime64[ns]\n    elif is_datetime64_dtype(left) and is_datetime64_dtype(right):\n\n        if not strict_nan:\n            # NaT is considered equivalent to itself\n            # and anything else that isn't a real datetime64\n            # value.\n            return lib.array_equ", "entropy": 53.46511909809499}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        # the cases where:\n        #   - both are NaT\n        #   - left is NaN, right is not NaN\n        #   - left is not NaN, right is NaN\n        #   - left is NaN, right is NaN\n        # have already been tested above.\n        return True\n\n    # if we have nans, but no strings", "entropy": 65.56066201240901}
{"candidate": "                if left_value != right_value:\n                    return False\n        return True\n    else:\n\n        if not strict_nan:\n            return lib.array_equivalent(left, right)\n\n        # must strictly check NaN values\n        left = ensure_float(left)\n        right = ensure_float(right)\n        # check that the na values are the same\n        return (isna(left) == isna(right)).", "entropy": 66.40686159442181}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # datetime64 dtypes are broken because np.nan != np.nan\n    # GH#5665\n    if needs_i8_conversion(left) and needs_i8_conversion(right):\n        return array_equivalent_datetime(left.ravel(), right.ravel())\n\n    # if we have an object array here, its because", "entropy": 68.94915831090672}
{"candidate": "                if left_value != right_value:\n                    return False\n\n        return True\n\n    # Only consider NaN equivalent if NaN is present in both arrays\n    # or we are not comparing nan stuff.\n    if (isna(left).any() or isna(right).any()) and not strict_nan:\n        return logical_and(isna(left), isna(right)).all()\n\n    # Avoid conversions\n    try:\n", "entropy": 77.753799395623}
