{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def get_label(self):\n        \"\"\"Get the label for the long axis of the colorbar.\"\"\"\n        return self._label\n\n    def set_ticks(self, ticks, update_ticks=True):\n        \"\"\"\n        Set the colorbar ticks.\n\n        Parameters\n        ----------\n        ticks : list\n            A", "entropy": 13.784721501093}
{"candidate": "        if label is None:\n            self.ax.set_xlabel(label, **kw)\n            self.ax.set_ylabel(label, **kw)\n        else:\n            self._label = label\n            self._labelkw = kw\n            self._set_label()\n        self.stale = True\n\n    def update_label(self):\n        self._set_label()\n\n    def get_label(self", "entropy": 20.514253768893}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def _outline(self, X, Y):\n        N = len(X)\n\n        if self.orientation == 'vertical':\n            x = np.zeros(2 * N + 2, np.float)\n            y = np.zeros(2 * N + 2, np.float)\n            x[0", "entropy": 21.860965140224316}
{"candidate": "        if label is None:\n            self.ax.set_ylabel(\"\")\n            self.ax.set_xlabel(\"\")\n            self.stale = True\n            return\n        else:\n            self._label = label\n            self._labelkw = kw\n        self._set_label()\n\n    def get_label(self):\n        \"\"\"Return the long axis label for the colorbar.\"\"\"\n        return self._label\n\n", "entropy": 23.777630931947}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def get_label(self):\n        \"\"\"Return the label for the long axis of the colorbar.\"\"\"\n        return self._label\n\n    def set_ticks(self, ticks, update_ticks=True):\n        \"\"\"Set the ticks and labels on the colorbar.\"\"\"\n        self._ticks = ticks\n        if update", "entropy": 24.019482732453703}
{"candidate": "        if 'fontsize' not in kw:\n            kw['fontsize'] = rcParams['axes.labelsize']\n        if 'fontname' not in kw:\n            kw['fontname'] = rcParams['font.family']\n        self._labelkw = kw\n        self._label = label\n        self._set_label()\n\n    def get_label(self):\n        \"\"\"Label the long", "entropy": 24.107335944103493}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def _get_label(self):\n        if self.orientation == 'vertical':\n            ret = self.ax.get_ylabel()\n        else:\n            ret = self.ax.get_xlabel()\n        ret = mpl.cbook.safe_unicode(ret)\n        return ret\n\n    def", "entropy": 24.260184574009195}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def set_ticks(self, ticks, update_ticks=True):\n        \"\"\"\n        Set the colorbar ticks.\n\n        Parameters\n        ----------\n        ticks : list of ticks\n            The list of ticks to be used.\n        update_ticks : bool, optional\n            Whether to update the ticks on the plot.\n\n", "entropy": 26.614306830005994}
{"candidate": "        self._label = label\n        self._labelkw = dict(kw)\n        self._set_label()\n\n    def get_transform(self):\n        '''\n        Return the :class:`~matplotlib.transforms.Transform` which maps\n        data coordinates to the colorbar's coordinate system.\n        '''\n        return self.ax.transData\n\n    def set_ticks(self, ticks, update_ticks", "entropy": 29.613259980322987}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self.stale = True\n\n    def draw_all(self, renderer):\n        self.ax.draw(renderer)\n        self.outline.remove()\n        self.patch.remove()\n        self.update_bruteforce(renderer)\n        for c in self.solids:\n            c.remove()\n        del self.sol", "entropy": 31.395280226803006}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def draw_all(self, renderer):\n        if self._image is not None:\n            self._image.remove()\n            self._image = None\n        self.draw_labels()\n        ax = self.ax\n        renderer.open_group('colorbar', gid=self.get_gid())\n", "entropy": 32.093667692769}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def _find_range(self):\n        \"\"\"Find the bounding range of the colorbar.\"\"\"\n        N = self.N\n        if self.vmin is not None and self.vmax is not None:\n            vmin = self.vmin\n            vmax = self.vmax\n        else:\n            mapp", "entropy": 32.10866505619099}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def update_ticks(self):\n        \"\"\"Force updating the ticks and ticklabels.\"\"\"\n        self._ticker = None\n        self.locator = None\n        self.formatter = None\n        self.update_units()\n\n    def update_units(self):\n        \"\"\"\n        Update the units using :meth", "entropy": 32.19576519776123}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n        self.stale = True\n\n    set_label_text = set_label\n\n    def set_ticks(self, ticks, update_ticks=False):\n        \"\"\"\n        Set the colorbar tick locations.\n\n        Parameters\n        ----------\n        ticks :\n            A list of locations.\n\n        update_ticks : optional", "entropy": 32.78752545693699}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def set_ticks(self, ticks, **kw):\n        \"\"\"\n        Set the ticks of the colorbar.\n\n        Parameters\n        ----------\n        ticks : list of ticks\n\n        Optional keyword arguments:\n        *ticklocation* [ auto | left | right | top | bottom ]\n            Where the ticks should be located.\n       ", "entropy": 34.79372899190701}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self.stale = True\n\n    def add_lines(self, lines):\n        \"\"\"\n        Add a `.LineCollection` to the colorbar.\n\n        Parameters\n        ----------\n        lines : `~matplotlib.collections.LineCollection`\n            A collection of lines that will be added to the colorbar.\n\n        \"\"\"\n\n        for line in lines.", "entropy": 37.82085441100599}
{"candidate": "        self._labelkw = kw\n        self._label = label\n        self._set_label()\n\n    def _process_values(self):\n        if self._values is not None and self._boundaries is not None:\n            raise RuntimeError('Cannot specify both boundaries and values')\n\n        if self._boundaries is not None:\n            values = self._boundaries\n        elif self._values is not None:\n            values =", "entropy": 38.65630112031601}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def update_ticks(self):\n        'update the ticks and ticklabels'\n        ax = self.ax\n\n        pts = np.array([0, 0.5, 1])\n        self.vmin = self.mappable.norm.vmin\n        self.vmax = self.mappable.norm.", "entropy": 40.522972072440496}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def draw_all(self):\n        'Draw everything (plot and ticks).'\n        if self.mappable is None:\n            raise TypeError(\n                \"You must first set the ScalarMappable using set_cmap or \"\n                \"set_array before using the colorbar\")\n        if self._A is", "entropy": 42.18112268432131}
{"candidate": "        self._label = label\n        self._labelkw = kw\n        self._set_label()\n\n    def _update_ticks(self):\n        '''\n        Update ticks and ticklabels along colorbar.\n        '''\n        raise NotImplementedError\n\n\nclass ColorbarBase(Colorbar):\n    _slice_dict = {\n        'nearest': np.s_[0:-1:1j * self", "entropy": 45.428263162238}
