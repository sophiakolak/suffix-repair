{"candidate": "        new_values[mask] = new\n\n        new_blocks = [self.make_block(new_values)]\n\n        return new_blocks\n\n    def fillna(\n        self, value: Scalar, inplace: bool = False, axis: int = 0, transpose: bool = False,\n    ) -> List[\"Block\"]:\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n        new_values", "entropy": 23.25388546187949}
{"candidate": "        new_values[mask] = new\n\n        if inplace:\n            return []\n        else:\n            return [\n                ExtensionBlock(\n                    np.asarray(new_values, dtype=self.dtype, order=\"F\"),\n                    placement=self.mgr_locs,\n                    ndim=self.ndim,\n                    fastpath=True,\n                )\n            ]\n\n    def delete(self, loc):\n", "entropy": 35.52788030015389}
{"candidate": "        if isinstance(mask, np.ndarray) and len(mask.shape) == 1:\n            if mask.dtype == np.bool_:\n                new_values[mask] = new\n            else:\n                new_values[mask] = new[mask]\n        else:\n            new_values[mask] = new\n        return [make_block(new_values, ndim=self.ndim)]\n\n    def rename", "entropy": 39.77108985021899}
{"candidate": "        if not isinstance(new, (np.ndarray, ABCSeries)):\n            new = np.asarray(new)\n\n        new_values[mask] = new\n\n        return [\n            make_block(new_values, (self.items,), self.ref_items, self.ref_locs)\n        ]\n\n    def reindex_axis(\n        self,\n        indexer,\n        axis=0,\n       ", "entropy": 41.046423877424}
{"candidate": "        mask = _maybe_swap(mask, transpose)\n        new_values[mask] = _maybe_swap(new, transpose)\n\n        if inplace:\n            return []\n        else:\n            return [\n                self.__class__(values=new_values, placement=self.mgr_locs)\n            ]\n\n\nclass IntBlock(NumericBlock):\n    \"\"\"\n    create a block for int,", "entropy": 42.29441873813619}
{"candidate": "        if axis == 0:\n            new_values[mask] = _extract_array(new)\n        elif axis == 1:\n            new_values = new_values.copy()\n            for i, row in enumerate(new_values):\n                row[mask[i]] = new[i]\n\n        self.set(0, new_values)\n        return [self]\n\n    def iget_item(self, item):", "entropy": 44.68220171130601}
{"candidate": "        if len(mask) == 0:\n            mask = np.array([False])\n\n        new_values = np.where(mask, new, new_values)\n\n        return [self.make_block(new_values, klass=self.__class__)]\n\n    def reindex_axis(self, new_index: Index, indexer: ArrayLike, axis: int = 0) -> \"Block\":\n        \"\"\"\n        See Block.", "entropy": 46.67325881278}
{"candidate": "        if isinstance(new, np.ndarray) and new.ndim == 0:\n            new = new.item()\n        if isinstance(new, (str, float, int)):\n            # scalars\n            new_values[mask] = np.asarray(new)\n        elif isinstance(new, np.ndarray):\n            # array-like\n            if new.shape != (1,):\n                raise Ass", "entropy": 50.60762315887799}
{"candidate": "        if not isinstance(new, (np.ndarray, ExtensionArray)):\n            # TODO: Don't coerce to a NumPy array in the general case\n            new = np.asarray(new)\n\n        if transpose:\n            new_values[:] = new[mask.T]\n        else:\n            new_values[:] = new[mask]\n\n        return [\n            make_block(\n                new_values,", "entropy": 51.19673537973601}
{"candidate": "        # TODO(EA2D): unnecessary with 2D EAs\n        if self.ndim == 2 and not isinstance(mask, np.ndarray):\n            mask = mask.values\n\n        if new_values.size != mask.size:\n            raise ValueError(\n                f\"cannot putmask on the array with shape {self.shape} \"\n                f\"and mask with size {mask.size}.\"\n            )\n\n       ", "entropy": 53.640783829474}
{"candidate": "        if len(new) == 0 and not isinstance(new, np.ndarray):\n            # special case of missing data\n            new = np.nan\n        new_values[mask] = new\n\n        values = self.values if inplace else new_values\n        return [make_block(values, self.items, self.ref_items)]\n\n    def where(\n        self, other, cond, align: bool = True, errors:", "entropy": 54.801714433339995}
{"candidate": "        if is_extension_array_dtype(new):\n            # we are setting with an EA, coerce the new values\n            new = self._holder(new)\n            new = new.astype(new_values.dtype)\n\n        new_values[mask] = new\n\n        return [self.make_block_same_class(new_values)]\n\n    def fillna(self, fill_value: ArrayLike, inplace", "entropy": 57.08713399499804}
{"candidate": "        if not isinstance(new, np.ndarray) or new.ndim != mask.ndim:\n            new = np.asarray(new)\n\n        if is_extension_array_dtype(new.dtype):\n            new = np.array(new, dtype=object)\n\n        # TODO(EA2D): can we make this more efficient?\n        new = com.asarray_tuplesafe(new,", "entropy": 57.15304456625779}
{"candidate": "        if not mask.any():\n            if not inplace:\n                return [\n                    make_block(\n                        new_values,\n                        self.mgr_locs[:axis] + (self.mgr_locs[axis] - _extract_range(mask)),\n                        self.items,\n                    )\n                ]\n        else:\n            if isinstance(new, np.ndarray) and new.shape != mask.", "entropy": 57.4593277305407}
{"candidate": "        nv.putmask(new_values, mask, new)\n\n        self._holder = self._holder.from_backing_data(new_values)\n\n        return [self._consolidate_inplace()]\n\n    def _consolidate_inplace(self) -> \"Block\":\n        \"\"\"\n        Consolidate this block, returning the result.\n        \"\"\"\n        new_values = self.values.copy()\n        new_", "entropy": 58.55493972331999}
{"candidate": "        if axis == 0:\n            if transpose:\n                new_values[mask] = np.atleast_1d(new).T\n            else:\n                new_values[mask] = new\n        else:\n            raise NotImplementedError\n\n        return [self.make_block(values=new_values)]", "entropy": 49.30275273937601}
{"candidate": "        if mask.any():\n            # Reminder: .values is always a numpy.ndarray\n            new_values = _putmask_smart(new_values, new, mask, axis=axis)\n\n        new_block = self if inplace else make_block(new_values, self.ref_items, self.ndim)\n        return [new_block]\n\n    def replace(self, to_replace, value, inplace:", "entropy": 65.39945845934601}
{"candidate": "        if transpose:\n            # nrows, ncols = self.shape\n            ncols = self.shape[1]\n            if axis is not None:\n                if axis < 0:\n                    axis += ncols\n                # if axis >= ncols:\n                #     raise ValueError(\"axis should be less than the number of columns\")\n                if axis >= ncols:\n                    axis = ncols - 1\n                   ", "entropy": 67.37980629049903}
{"candidate": "        if axis != 0:\n            raise AssertionError(\"Cannot perform an inplace putmask on a EA along axis != 0\")\n\n        if mask.ndim == 0:\n            return self.set(0, new)\n        elif mask.ndim == 1:\n            if mask.dtype == np.bool_:\n                new_values[locs] = new[mask]\n            else:\n                new_values[loc", "entropy": 68.58215513154998}
{"candidate": "        if isinstance(new, (ABCSeries, np.ndarray, ExtensionArray)):\n            # GH 18287 (fancy indexing)\n            if is_extension_array_dtype(new.dtype):\n                new = new.values\n\n            new_values[mask] = new.values\n\n        else:\n            # scalar\n            # GH 18287 (scalar assignment)\n            new_values[mask] = new", "entropy": 73.56293412095204}
