{"candidate": "            if len(task.stakeholders) == 0:\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_passive_tasks(self):\n        passive_tasks = set()\n        for task in self.get_active_tasks():\n            if task not in self._active_tasks:\n                passive_tasks.add(task)\n        return passive_tasks\n\n", "entropy": 24.665178996385503}
{"candidate": "            if not task.ready_for_work():\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_active_tasks(self, last_active_lt=None):\n        for task in six.itervalues(self._active_tasks):\n            if (last_active_lt is None or task.last_active < last_active_lt):\n                yield task\n\n    def", "entropy": 27.34670667083741}
{"candidate": "            if not task.is_done:\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_needed_tasks(self, stakeholder):\n        needed_tasks = set()\n        for task in self.get_necessary_tasks():\n            if task.is_needed_by(stakeholder):\n                needed_tasks.add(task)\n        return needed_tasks\n\n", "entropy": 27.517234196487994}
{"candidate": "            if not task.is_completed:\n                necessary_tasks.add(task.id)\n                necessary_tasks.update(task.dependencies)\n        return necessary_tasks\n\n    def get_invalid_tasks(self):\n        invalid_tasks = set()\n        for task in self.get_active_tasks():\n            if task.is_invalid:\n                invalid_tasks.add(", "entropy": 27.834876589003805}
{"candidate": "            if task.is_necessary():\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_active_tasks(self):\n        active_tasks = set()\n        for task in itertools.chain(self.tasks, self.task_queues):\n            if task.active:\n                active_tasks.add(task)\n        return active_tasks\n\n    def remove", "entropy": 30.627643799239202}
{"candidate": "            if not task.is_blocked and len(task.stakeholders) == 0:\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_active_tasks(self):\n        now = datetime.datetime.utcnow()\n        active_tasks = set()\n        for task in self._active_tasks.itervalues():\n            if not task.is_", "entropy": 38.24118187711902}
{"candidate": "            if not task.is_done():\n                necessary_tasks.add(task.id)\n        return necessary_tasks\n\n    def get_tasks_for_worker(self, worker_id):\n        with self._lock:\n            return list(self.get_worker(worker_id).tasks)\n\n    def get_task_properties(self, task_id):\n        with self._lock:\n            task = self", "entropy": 43.9393433554265}
{"candidate": "            if task.status == 'blocked' and not task.workers:\n                necessary_tasks.add(task)\n                task.reset_blockers()\n        return necessary_tasks\n\n    def get_new_tasks(self):\n        new_tasks = set()\n        for task in self.get_active_tasks():\n            if task.status == 'queued' and not task.stakeholders:\n               ", "entropy": 46.60683644991299}
{"candidate": "            if task.required_tasks and not task.finished:\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_active_tasks(self):\n        for task in sorted(six.itervalues(self._active_tasks), key=lambda task: str(task.task_id)):\n            if not task.finished:\n                yield task\n            elif task.last_", "entropy": 48.49399878692851}
{"candidate": "            if task.workers:\n                # this task is being worked on\n                continue\n            if self.tasks_stakeholders[task.name].intersection(self.workers):\n                necessary_tasks.add(task)\n        return sorted(necessary_tasks)\n\n    def get_possible_tasks(self):\n        possible_tasks = set()\n        for task in self.get_active_tasks():\n", "entropy": 55.19639159863}
{"candidate": "            if not task.workers and task.stakeholders:\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_neutral_needed_tasks(self, worker_id):\n        neg_tasks = self.get_worker(worker_id).neg_tasks\n        necessary_tasks = self.get_necessary_tasks()\n        needed_tasks = necessary_tasks - neg", "entropy": 58.24864852257101}
{"candidate": "            if task.get_task_state() == TaskState.ABORTING_TASK:\n                continue\n            if not task.workers and not task.stakeholders:\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_stale_workers(self, max_worker_inactivity_time):\n        now = datetime.utcnow()\n        for worker in self.get_", "entropy": 60.30257055092004}
{"candidate": "            if (task.ready and task.stakeholders and not task.workers):\n                necessary_tasks.add(task)\n        return list(necessary_tasks)\n\n    def get_latest_stakeholder_updates(self, task_id):\n        if task_id not in self._tasks:\n            return []\n        return list(self._tasks[task_id].last_stakeholder_updates)", "entropy": 62.0753105980735}
{"candidate": "            if not task.is_stakeholders_exclusive_possibility():\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_active_tasks(self):\n        for task in self._tasks.values():\n            if task.is_active_and_unassigned():\n                yield task\n\n    def delete_task(self, task_id):\n        return self._tasks.pop", "entropy": 63.39023978409498}
{"candidate": "            if task.status == con.NEEDS_INPUT:\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_sorted_tasks(self, sort_attribute=None, reverse=True, status=None):\n        sort_attribute = sort_attribute or con.PRIORITY\n        return sorted((t for t in self.get_active_tasks()\n                       if (status is", "entropy": 63.81651348524761}
{"candidate": "            if task.status.is_final:\n                continue\n            if any(task.node_failure_counts.values()):\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_unnecessary_open_tasks(self, worker_ids):\n        unnecessary_tasks = set()\n        for task in self.get_active_tasks():\n            if not task.status.", "entropy": 66.11078520160048}
{"candidate": "            if task.find_missing_resources(self.resources):\n                necessary_tasks.add(task)\n        return necessary_tasks\n\n    def get_active_tasks(self, return_all=False):\n        for task in self.get_tasks():\n            if return_all or task.need_resources():\n                yield task\n\n    def get_tasks(self):\n        for key, task in self.t", "entropy": 66.78912526417743}
{"candidate": "            if task.execution_parent is None:  # not a sub_task\n                necessary_tasks.add(task)\n            if task.all_dependencies_satisfied():\n                necessary_tasks.add(task)\n        return sorted(necessary_tasks, key=lambda t: t.priority, reverse=True)\n\n    def get_refresh_tasks(self):\n        refresh_tasks = []\n", "entropy": 68.57576037618448}
{"candidate": "            if task.is_ready():\n                necessary_tasks.add(task)\n                for child in task.children:\n                    child.stakeholders.difference_update(task.workers)\n        return necessary_tasks\n\n    def get_next_work(self, worker_id, timeout=None,\n                      force_restart=False, exclude_tasks=None):\n        result = None\n        try:\n            worker", "entropy": 70.726479048125}
{"candidate": "            if self._is_ready_for_work(task):\n                necessary_tasks.add(task)\n        return sorted(necessary_tasks, key=self.get_task_queued_time)\n\n    def _is_ready_for_work(self, task):\n        # Check if the task has been allocated\n        if not self.get_task_allocated(task):\n            return False\n        # Skip if the", "entropy": 75.40090008614843}
