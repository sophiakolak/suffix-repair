{"prefix": "                # Response cannot contain both Content-Length and\n                # Transfer-Encoding headers.\n                # http://tools.ietf.org/html/rfc7230#section-3.3.3\n                raise httputil.HTTPInputError(\n                    \"Response with both Transfer-Encoding and Content-Length\")\n            if \",\" in headers[\"Content-Length\"]:\n                # Proxies sometimes cause Content-Length headers to get\n                # duplicated.  If all the values are identical then we can\n                # use them but if they differ it's an error.\n                pieces = re.split(r',\\s*', headers[\"Content-Length\"])\n                if any(i != pieces[0] for i in pieces):\n                    raise httputil.HTTPInputError(\n                        \"Multiple unequal Content-Lengths: %r\" %\n                        headers[\"Content-Length\"])\n                headers[\"Content-Length\"] = pieces[0]\n\n            try:\n                content_length = int(headers[\"Content-Length\"])\n            except ValueError:\n                # Handles non-integer Content-Length value.\n                raise httputil.HTTPInputError(\n                    \"Only integer Content-Length is allowed: %s\" % headers[\"Content-Length\"])\n\n            if content_length > self._max_body_size:\n                raise httputil.HTTPInputError(\"Content-Length too long\")\n        else:\n            content_length = None\n\n        if code == 204:\n            # This response code is not allowed to have a non-empty body,\n            # and has an implicit length of zero instead of read-until-close.\n            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n            if (\"Transfer-Encoding\" in headers or\n                    content_length not in (None, 0)):\n                raise httputil.HTTPInputError(\n                    \"Response with code %d should not have body\" % code)\n            content_length = 0\n\n        if content_length is not None:\n            return self._read_fixed_body(content_length, delegate)\n", "suffix": "            return self._read_chunked_body(delegate)\n        if self.is_client:\n            return self._read_body_until_close(delegate)\n        return None\n\n    @gen.coroutine\n    def _read_fixed_body(self, content_length, delegate):\n        while content_length > 0:\n            body = yield self.stream.read_bytes(\n                min(self.params.chunk_size, content_length), partial=True)\n            content_length -= len(body)\n            if not self._write_finished or self.is_client:\n                with _ExceptionLoggingContext(app_log):\n                    ret = delegate.data_received(body)\n                    if ret is not None:\n                        yield ret\n\n    @gen.coroutine\n    def _read_chunked_body(self, delegate):\n        # TODO: \"chunk extensions\" http://tools.ietf.org/html/rfc2616#section-3.6.1\n        total_size = 0\n        while True:\n            chunk_len = yield self.stream.read_until(b\"\\r\\n\", max_bytes=64)\n            chunk_len = int(chunk_len.strip(), 16)\n            if chunk_len == 0:\n                return\n            total_size += chunk_len\n            if total_size > self._max_body_size:\n                raise httputil.HTTPInputError(\"chunked body too large\")\n            bytes_to_read = chunk_len\n            while bytes_to_read:\n                chunk = yield self.stream.read_bytes(\n                    min(bytes_to_read, self.params.chunk_size), partial=True)\n                bytes_to_read -= len(chunk)\n                if not self._write_finished or self.is_client:\n                    with _ExceptionLoggingContext(app_log):\n                        ret = delegate.data_received(chunk)\n                        if ret is not None:\n                            yield ret\n            # chunk ends with \\r\\n\n", "long_prefix": ["            return connection_header != \"close\"\n        elif (\"Content-Length\" in headers or\n              headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\" or\n              getattr(start_line, 'method', None) in (\"HEAD\", \"GET\")):\n            # start_line may be a request or reponse start line; only\n            # the former has a method attribute.\n            return connection_header == \"keep-alive\"\n        return False\n\n    def _finish_request(self, future):\n        self._clear_callbacks()\n        if not self.is_client and self._disconnect_on_finish:\n            self.close()\n            return\n        # Turn Nagle's algorithm back on, leaving the stream in its\n        # default state for the next request.\n        self.stream.set_nodelay(False)\n        if not self._finish_future.done():\n            self._finish_future.set_result(None)\n\n    def _parse_headers(self, data):\n        # The lstrip removes newlines that some implementations sometimes\n        # insert between messages of a reused connection.  Per RFC 7230,\n        # we SHOULD ignore at least one empty line before the request.\n        # http://tools.ietf.org/html/rfc7230#section-3.5\n        data = native_str(data.decode('latin1')).lstrip(\"\\r\\n\")\n        # RFC 7230 section allows for both CRLF and bare LF.\n        eol = data.find(\"\\n\")\n        start_line = data[:eol].rstrip(\"\\r\")\n        try:\n            headers = httputil.HTTPHeaders.parse(data[eol:])\n        except ValueError:\n            # probably form split() if there was no ':' in the line\n            raise httputil.HTTPInputError(\"Malformed HTTP headers: %r\" %\n                                          data[eol:100])\n        return start_line, headers\n\n    def _read_body(self, code, headers, delegate):\n        if \"Content-Length\" in headers:\n            if \"Transfer-Encoding\" in headers:\n                # Response cannot contain both Content-Length and\n                # Transfer-Encoding headers.\n                # http://tools.ietf.org/html/rfc7230#section-3.3.3\n                raise httputil.HTTPInputError(\n                    \"Response with both Transfer-Encoding and Content-Length\")\n            if \",\" in headers[\"Content-Length\"]:\n                # Proxies sometimes cause Content-Length headers to get\n                # duplicated.  If all the values are identical then we can\n                # use them but if they differ it's an error.\n                pieces = re.split(r',\\s*', headers[\"Content-Length\"])\n                if any(i != pieces[0] for i in pieces):\n                    raise httputil.HTTPInputError(\n                        \"Multiple unequal Content-Lengths: %r\" %\n                        headers[\"Content-Length\"])\n                headers[\"Content-Length\"] = pieces[0]\n\n            try:\n                content_length = int(headers[\"Content-Length\"])\n            except ValueError:\n                # Handles non-integer Content-Length value.\n                raise httputil.HTTPInputError(\n                    \"Only integer Content-Length is allowed: %s\" % headers[\"Content-Length\"])\n\n            if content_length > self._max_body_size:\n                raise httputil.HTTPInputError(\"Content-Length too long\")\n        else:\n            content_length = None\n\n        if code == 204:\n            # This response code is not allowed to have a non-empty body,\n            # and has an implicit length of zero instead of read-until-close.\n            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n            if (\"Transfer-Encoding\" in headers or\n                    content_length not in (None, 0)):\n                raise httputil.HTTPInputError(\n                    \"Response with code %d should not have body\" % code)\n            content_length = 0\n\n        if content_length is not None:\n            return self._read_fixed_body(content_length, delegate)\n", "            return self._read_chunked_body(delegate)\n        if self.is_client:\n            return self._read_body_until_close(delegate)\n        return None\n\n    @gen.coroutine\n    def _read_fixed_body(self, content_length, delegate):\n        while content_length > 0:\n            body = yield self.stream.read_bytes(\n                min(self.params.chunk_size, content_length), partial=True)\n            content_length -= len(body)\n            if not self._write_finished or self.is_client:\n                with _ExceptionLoggingContext(app_log):\n                    ret = delegate.data_received(body)\n                    if ret is not None:\n                        yield ret\n\n    @gen.coroutine\n    def _read_chunked_body(self, delegate):\n        # TODO: \"chunk extensions\" http://tools.ietf.org/html/rfc2616#section-3.6.1\n        total_size = 0\n        while True:\n            chunk_len = yield self.stream.read_until(b\"\\r\\n\", max_bytes=64)\n            chunk_len = int(chunk_len.strip(), 16)\n            if chunk_len == 0:\n                return\n            total_size += chunk_len\n            if total_size > self._max_body_size:\n                raise httputil.HTTPInputError(\"chunked body too large\")\n            bytes_to_read = chunk_len\n            while bytes_to_read:\n                chunk = yield self.stream.read_bytes(\n                    min(bytes_to_read, self.params.chunk_size), partial=True)\n                bytes_to_read -= len(chunk)\n                if not self._write_finished or self.is_client:\n                    with _ExceptionLoggingContext(app_log):\n                        ret = delegate.data_received(chunk)\n                        if ret is not None:\n                            yield ret\n            # chunk ends with \\r\\n\n"]}