{"prefix": "                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n            if route.callbacks:\n                callback_flat_models |= get_flat_models_from_routes(route.callbacks)\n    flat_models = callback_flat_models | get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes, known_models=set()\n    )\n    return flat_models\n\n\ndef get_model_definitions(\n    *, flat_models: Set[Type[BaseModel]], model_name_map: Dict[Type[BaseModel], str]\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict] = {}\n    for model in flat_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions\n\n\ndef get_path_param_names(path: str) -> Set[str]:\n    return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n\n\ndef create_cloned_field(field: ModelField) -> ModelField:\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n        original_type = original_type.__pydantic_model__  # type: ignore\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = create_model(\n            original_type.__name__, __config__=original_type.__config__\n        )\n        for f in original_type.__fields__.values():\n", "suffix": "        use_type.__validators__ = original_type.__validators__\n    if PYDANTIC_1:\n        new_field = ModelField(\n            name=field.name,\n            type_=use_type,\n            class_validators={},\n            default=None,\n            required=False,\n            model_config=BaseConfig,\n            field_info=FieldInfo(None),\n        )\n    else:  # pragma: nocover\n        new_field = ModelField(  # type: ignore\n            name=field.name,\n            type_=use_type,\n            class_validators={},\n            default=None,\n            required=False,\n            model_config=BaseConfig,\n            schema=FieldInfo(None),\n        )\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    if PYDANTIC_1:\n        new_field.field_info = field.field_info\n    else:  # pragma: nocover\n        new_field.schema = field.schema  # type: ignore\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [\n            create_cloned_field(sub_field) for sub_field in field.sub_fields\n        ]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field)\n    new_field.validators = field.validators\n", "long_prefix": ["    from pydantic import Schema as FieldInfo  # type: ignore\n\n    logger.warning(\n        \"Pydantic versions < 1.0.0 are deprecated in FastAPI and support will be \"\n        \"removed soon.\"\n    )\n    PYDANTIC_1 = False\n\n\n# TODO: remove when removing support for Pydantic < 1.0.0\ndef get_field_info(field: ModelField) -> FieldInfo:\n    if PYDANTIC_1:\n        return field.field_info  # type: ignore\n    else:\n        return field.schema  # type: ignore  # pragma: nocover\n\n\n# TODO: remove when removing support for Pydantic < 1.0.0\ndef warning_response_model_skip_defaults_deprecated() -> None:\n    logger.warning(  # pragma: nocover\n        \"response_model_skip_defaults has been deprecated in favor of \"\n        \"response_model_exclude_unset to keep in line with Pydantic v1, support for \"\n        \"it will be removed soon.\"\n    )\n\n\ndef get_flat_models_from_routes(routes: Sequence[BaseRoute]) -> Set[Type[BaseModel]]:\n    body_fields_from_routes: List[ModelField] = []\n    responses_from_routes: List[ModelField] = []\n    callback_flat_models: Set[Type[BaseModel]] = set()\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, ModelField\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n            if route.callbacks:\n                callback_flat_models |= get_flat_models_from_routes(route.callbacks)\n    flat_models = callback_flat_models | get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes, known_models=set()\n    )\n    return flat_models\n\n\ndef get_model_definitions(\n    *, flat_models: Set[Type[BaseModel]], model_name_map: Dict[Type[BaseModel], str]\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict] = {}\n    for model in flat_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions\n\n\ndef get_path_param_names(path: str) -> Set[str]:\n    return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n\n\ndef create_cloned_field(field: ModelField) -> ModelField:\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n        original_type = original_type.__pydantic_model__  # type: ignore\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = create_model(\n            original_type.__name__, __config__=original_type.__config__\n        )\n        for f in original_type.__fields__.values():\n", "        use_type.__validators__ = original_type.__validators__\n    if PYDANTIC_1:\n        new_field = ModelField(\n            name=field.name,\n            type_=use_type,\n            class_validators={},\n            default=None,\n            required=False,\n            model_config=BaseConfig,\n            field_info=FieldInfo(None),\n        )\n    else:  # pragma: nocover\n        new_field = ModelField(  # type: ignore\n            name=field.name,\n            type_=use_type,\n            class_validators={},\n            default=None,\n            required=False,\n            model_config=BaseConfig,\n            schema=FieldInfo(None),\n        )\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    if PYDANTIC_1:\n        new_field.field_info = field.field_info\n    else:  # pragma: nocover\n        new_field.schema = field.schema  # type: ignore\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [\n            create_cloned_field(sub_field) for sub_field in field.sub_fields\n        ]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field)\n    new_field.validators = field.validators\n"]}