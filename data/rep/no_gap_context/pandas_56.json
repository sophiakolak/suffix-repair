{"prefix": "                )\n                result = result.__finalize__(self)\n\n            # If there is only one column being returned, and its name is\n            # either an empty string, or a tuple with an empty string as its\n            # first element, then treat the empty string as a placeholder\n            # and return the column as if the user had provided that empty\n            # string in the key. If the result is a Series, exclude the\n            # implied empty string from its name.\n            if len(result.columns) == 1:\n                top = result.columns[0]\n                if isinstance(top, tuple):\n                    top = top[0]\n                if top == \"\":\n                    result = result[\"\"]\n                    if isinstance(result, Series):\n                        result = self._constructor_sliced(\n                            result, index=self.index, name=key\n                        )\n\n            result._set_is_copy(self)\n            return result\n        else:\n            return self._get_item_cache(key)\n\n    def _get_value(self, index, col, takeable: bool = False):\n        \"\"\"\n        Quickly retrieve single value at passed column and index.\n\n        Parameters\n        ----------\n        index : row label\n        col : column label\n        takeable : interpret the index/col as indexers, default False\n\n        Returns\n        -------\n        scalar\n        \"\"\"\n        if takeable:\n", "suffix": "\n        series = self._get_item_cache(col)\n        engine = self.index._engine\n\n        try:\n            loc = engine.get_loc(index)\n            return series._values[loc]\n        except KeyError:\n            # GH 20629\n            if self.index.nlevels > 1:\n                # partial indexing forbidden\n                raise\n\n        # we cannot handle direct indexing\n        # use positional\n        col = self.columns.get_loc(col)\n        index = self.index.get_loc(index)\n        return self._get_value(index, col, takeable=True)\n\n    def __setitem__(self, key, value):\n        key = com.apply_if_callable(key, self)\n\n        # see if we can slice the rows\n        indexer = convert_to_index_sliceable(self, key)\n        if indexer is not None:\n            # either we have a slice or we have a string that can be converted\n            #  to a slice for partial-string date indexing\n            return self._setitem_slice(indexer, value)\n\n        if isinstance(key, DataFrame) or getattr(key, \"ndim\", None) == 2:\n            self._setitem_frame(key, value)\n        elif isinstance(key, (Series, np.ndarray, list, Index)):\n            self._setitem_array(key, value)\n        else:\n            # set column\n            self._set_item(key, value)\n\n    def _setitem_slice(self, key: slice, value):\n        # NB: we can't just use self.loc[key] = value because that\n        #  operates on labels and we need to operate positional for\n", "long_prefix": ["                data = data[key]\n\n        return data\n\n    def _getitem_bool_array(self, key):\n        # also raises Exception if object array with NA values\n        # warning here just in case -- previously __setitem__ was\n        # reindexing but __getitem__ was not; it seems more reasonable to\n        # go with the __setitem__ behavior since that is more consistent\n        # with all other indexing behavior\n        if isinstance(key, Series) and not key.index.equals(self.index):\n            warnings.warn(\n                \"Boolean Series key will be reindexed to match DataFrame index.\",\n                UserWarning,\n                stacklevel=3,\n            )\n        elif len(key) != len(self.index):\n            raise ValueError(\n                f\"Item wrong length {len(key)} instead of {len(self.index)}.\"\n            )\n\n        # check_bool_indexer will throw exception if Series key cannot\n        # be reindexed to match DataFrame rows\n        key = check_bool_indexer(self.index, key)\n        indexer = key.nonzero()[0]\n        return self._take_with_is_copy(indexer, axis=0)\n\n    def _getitem_multilevel(self, key):\n        # self.columns is a MultiIndex\n        loc = self.columns.get_loc(key)\n        if isinstance(loc, (slice, Series, np.ndarray, Index)):\n            new_columns = self.columns[loc]\n            result_columns = maybe_droplevels(new_columns, key)\n            if self._is_mixed_type:\n                result = self.reindex(columns=new_columns)\n                result.columns = result_columns\n            else:\n                new_values = self.values[:, loc]\n                result = self._constructor(\n                    new_values, index=self.index, columns=result_columns\n                )\n                result = result.__finalize__(self)\n\n            # If there is only one column being returned, and its name is\n            # either an empty string, or a tuple with an empty string as its\n            # first element, then treat the empty string as a placeholder\n            # and return the column as if the user had provided that empty\n            # string in the key. If the result is a Series, exclude the\n            # implied empty string from its name.\n            if len(result.columns) == 1:\n                top = result.columns[0]\n                if isinstance(top, tuple):\n                    top = top[0]\n                if top == \"\":\n                    result = result[\"\"]\n                    if isinstance(result, Series):\n                        result = self._constructor_sliced(\n                            result, index=self.index, name=key\n                        )\n\n            result._set_is_copy(self)\n            return result\n        else:\n            return self._get_item_cache(key)\n\n    def _get_value(self, index, col, takeable: bool = False):\n        \"\"\"\n        Quickly retrieve single value at passed column and index.\n\n        Parameters\n        ----------\n        index : row label\n        col : column label\n        takeable : interpret the index/col as indexers, default False\n\n        Returns\n        -------\n        scalar\n        \"\"\"\n        if takeable:\n", "\n        series = self._get_item_cache(col)\n        engine = self.index._engine\n\n        try:\n            loc = engine.get_loc(index)\n            return series._values[loc]\n        except KeyError:\n            # GH 20629\n            if self.index.nlevels > 1:\n                # partial indexing forbidden\n                raise\n\n        # we cannot handle direct indexing\n        # use positional\n        col = self.columns.get_loc(col)\n        index = self.index.get_loc(index)\n        return self._get_value(index, col, takeable=True)\n\n    def __setitem__(self, key, value):\n        key = com.apply_if_callable(key, self)\n\n        # see if we can slice the rows\n        indexer = convert_to_index_sliceable(self, key)\n        if indexer is not None:\n            # either we have a slice or we have a string that can be converted\n            #  to a slice for partial-string date indexing\n            return self._setitem_slice(indexer, value)\n\n        if isinstance(key, DataFrame) or getattr(key, \"ndim\", None) == 2:\n            self._setitem_frame(key, value)\n        elif isinstance(key, (Series, np.ndarray, list, Index)):\n            self._setitem_array(key, value)\n        else:\n            # set column\n            self._set_item(key, value)\n\n    def _setitem_slice(self, key: slice, value):\n        # NB: we can't just use self.loc[key] = value because that\n        #  operates on labels and we need to operate positional for\n"]}