{"prefix": "        self.resources = _get_default(resources, {})\n        self.family = family\n        self.module = module\n        self.params = _get_default(params, {})\n        self.disable_failures = disable_failures\n        self.disable_hard_timeout = disable_hard_timeout\n        self.failures = Failures(disable_window)\n        self.scheduler_disable_time = None\n\n    def __repr__(self):\n        return \"Task(%r)\" % vars(self)\n\n    def add_failure(self):\n        self.failures.add_failure()\n\n    def has_excessive_failures(self):\n\n        excessive_failures = False\n\n        if (self.failures.first_failure_time is not None and\n                self.disable_hard_timeout):\n            if (time.time() >= self.failures.first_failure_time +\n                    self.disable_hard_timeout):\n                excessive_failures = True\n\n        if self.failures.num_failures() >= self.disable_failures:\n            excessive_failures = True\n\n        return excessive_failures\n\n    def can_disable(self):\n        return (self.disable_failures is not None or\n                self.disable_hard_timeout is not None)\n\n\nclass Worker(object):\n    \"\"\"\n    Structure for tracking worker activity and keeping their references.\n    \"\"\"\n\n", "suffix": "        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active  # seconds since epoch\n        self.started = time.time()  # seconds since epoch\n        self.tasks = set()  # task objects\n        self.info = {}\n\n    def add_info(self, info):\n        self.info.update(info)\n\n    def update(self, worker_reference):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()\n\n    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True\n\n    def get_pending_tasks(self):\n        return six.moves.filter(lambda task: task.status in [PENDING, RUNNING],\n                                self.tasks)\n\n    def is_trivial_worker(self):\n        \"\"\"\n        If it's not an assistant having only tasks that are without\n        requirements\n        \"\"\"\n        if self.assistant:\n            return False\n        return all(not task.resources for task in self.get_pending_tasks())\n\n    @property\n    def assistant(self):\n        return self.info.get('assistant', False)\n\n    def __str__(self):\n        return self.id\n\n", "long_prefix": ["        min_time = time.time() - self.window\n\n        while self.failures and fix_time(self.failures[0]) < min_time:\n            self.failures.popleft()\n\n        return len(self.failures)\n\n    def clear(self):\n        \"\"\"\n        Clear the failure queue.\n        \"\"\"\n        self.failures.clear()\n\n\ndef _get_default(x, default):\n    if x is not None:\n        return x\n    else:\n        return default\n\n\nclass Task(object):\n\n    def __init__(self, task_id, status, deps, resources=None, priority=0, family='', module=None,\n                 params=None, disable_failures=None, disable_window=None, disable_hard_timeout=None):\n        self.id = task_id\n        self.stakeholders = set()  # workers ids that are somehow related to this task (i.e. don't prune while any of these workers are still active)\n        self.workers = set()  # workers ids that can perform task - task is 'BROKEN' if none of these workers are active\n        if deps is None:\n            self.deps = set()\n        else:\n            self.deps = set(deps)\n        self.status = status  # PENDING, RUNNING, FAILED or DONE\n        self.time = time.time()  # Timestamp when task was first added\n        self.retry = None\n        self.remove = None\n        self.worker_running = None  # the worker id that is currently running the task or None\n        self.time_running = None  # Timestamp when picked up by worker\n        self.expl = None\n        self.priority = priority\n        self.resources = _get_default(resources, {})\n        self.family = family\n        self.module = module\n        self.params = _get_default(params, {})\n        self.disable_failures = disable_failures\n        self.disable_hard_timeout = disable_hard_timeout\n        self.failures = Failures(disable_window)\n        self.scheduler_disable_time = None\n\n    def __repr__(self):\n        return \"Task(%r)\" % vars(self)\n\n    def add_failure(self):\n        self.failures.add_failure()\n\n    def has_excessive_failures(self):\n\n        excessive_failures = False\n\n        if (self.failures.first_failure_time is not None and\n                self.disable_hard_timeout):\n            if (time.time() >= self.failures.first_failure_time +\n                    self.disable_hard_timeout):\n                excessive_failures = True\n\n        if self.failures.num_failures() >= self.disable_failures:\n            excessive_failures = True\n\n        return excessive_failures\n\n    def can_disable(self):\n        return (self.disable_failures is not None or\n                self.disable_hard_timeout is not None)\n\n\nclass Worker(object):\n    \"\"\"\n    Structure for tracking worker activity and keeping their references.\n    \"\"\"\n\n", "        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active  # seconds since epoch\n        self.started = time.time()  # seconds since epoch\n        self.tasks = set()  # task objects\n        self.info = {}\n\n    def add_info(self, info):\n        self.info.update(info)\n\n    def update(self, worker_reference):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()\n\n    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True\n\n    def get_pending_tasks(self):\n        return six.moves.filter(lambda task: task.status in [PENDING, RUNNING],\n                                self.tasks)\n\n    def is_trivial_worker(self):\n        \"\"\"\n        If it's not an assistant having only tasks that are without\n        requirements\n        \"\"\"\n        if self.assistant:\n            return False\n        return all(not task.resources for task in self.get_pending_tasks())\n\n    @property\n    def assistant(self):\n        return self.info.get('assistant', False)\n\n    def __str__(self):\n        return self.id\n\n"]}