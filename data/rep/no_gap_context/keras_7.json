{"prefix": "                the `.compile()` method of the model.\n        \"\"\"\n        y = np.searchsorted(self.classes_, y)\n        kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n\n        loss_name = self.model.loss\n        if hasattr(loss_name, '__name__'):\n            loss_name = loss_name.__name__\n        if loss_name == 'categorical_crossentropy' and len(y.shape) != 2:\n            y = to_categorical(y)\n\n        outputs = self.model.evaluate(x, y, **kwargs)\n        outputs = to_list(outputs)\n        for name, output in zip(self.model.metrics_names, outputs):\n            if name == 'acc':\n                return output\n        raise ValueError('The model is not configured to compute accuracy. '\n                         'You should pass `metrics=[\"accuracy\"]` to '\n                         'the `model.compile()` method.')\n\n\nclass KerasRegressor(BaseWrapper):\n    \"\"\"Implementation of the scikit-learn regressor API for Keras.\n    \"\"\"\n\n    def predict(self, x, **kwargs):\n        \"\"\"Returns predictions for the given test data.\n\n        # Arguments\n            x: array-like, shape `(n_samples, n_features)`\n                Test samples where `n_samples` is the number of samples\n                and `n_features` is the number of features.\n            **kwargs: dictionary arguments\n                Legal arguments are the arguments of `Sequential.predict`.\n\n        # Returns\n            preds: array-like, shape `(n_samples,)`\n                Predictions.\n        \"\"\"\n        kwargs = self.filter_sk_params(Sequential.predict, kwargs)\n", "suffix": "\n    def score(self, x, y, **kwargs):\n        \"\"\"Returns the mean loss on the given test data and labels.\n\n        # Arguments\n            x: array-like, shape `(n_samples, n_features)`\n                Test samples where `n_samples` is the number of samples\n                and `n_features` is the number of features.\n            y: array-like, shape `(n_samples,)`\n                True labels for `x`.\n            **kwargs: dictionary arguments\n                Legal arguments are the arguments of `Sequential.evaluate`.\n\n        # Returns\n            score: float\n                Mean accuracy of predictions on `x` wrt. `y`.\n        \"\"\"\n        kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n        loss = self.model.evaluate(x, y, **kwargs)\n        if isinstance(loss, list):\n            return -loss[0]\n        return -loss\n", "long_prefix": ["            **kwargs: dictionary arguments\n                Legal arguments are the arguments\n                of `Sequential.predict_classes`.\n\n        # Returns\n            proba: array-like, shape `(n_samples, n_outputs)`\n                Class probability estimates.\n                In the case of binary classification,\n                to match the scikit-learn API,\n                will return an array of shape `(n_samples, 2)`\n                (instead of `(n_sample, 1)` as in Keras).\n        \"\"\"\n        kwargs = self.filter_sk_params(Sequential.predict_proba, kwargs)\n        probs = self.model.predict(x, **kwargs)\n\n        # check if binary classification\n        if probs.shape[1] == 1:\n            # first column is probability of class 0 and second is of class 1\n            probs = np.hstack([1 - probs, probs])\n        return probs\n\n    def score(self, x, y, **kwargs):\n        \"\"\"Returns the mean accuracy on the given test data and labels.\n\n        # Arguments\n            x: array-like, shape `(n_samples, n_features)`\n                Test samples where `n_samples` is the number of samples\n                and `n_features` is the number of features.\n            y: array-like, shape `(n_samples,)` or `(n_samples, n_outputs)`\n                True labels for `x`.\n            **kwargs: dictionary arguments\n                Legal arguments are the arguments of `Sequential.evaluate`.\n\n        # Returns\n            score: float\n                Mean accuracy of predictions on `x` wrt. `y`.\n\n        # Raises\n            ValueError: If the underlying model isn't configured to\n                compute accuracy. You should pass `metrics=[\"accuracy\"]` to\n                the `.compile()` method of the model.\n        \"\"\"\n        y = np.searchsorted(self.classes_, y)\n        kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n\n        loss_name = self.model.loss\n        if hasattr(loss_name, '__name__'):\n            loss_name = loss_name.__name__\n        if loss_name == 'categorical_crossentropy' and len(y.shape) != 2:\n            y = to_categorical(y)\n\n        outputs = self.model.evaluate(x, y, **kwargs)\n        outputs = to_list(outputs)\n        for name, output in zip(self.model.metrics_names, outputs):\n            if name == 'acc':\n                return output\n        raise ValueError('The model is not configured to compute accuracy. '\n                         'You should pass `metrics=[\"accuracy\"]` to '\n                         'the `model.compile()` method.')\n\n\nclass KerasRegressor(BaseWrapper):\n    \"\"\"Implementation of the scikit-learn regressor API for Keras.\n    \"\"\"\n\n    def predict(self, x, **kwargs):\n        \"\"\"Returns predictions for the given test data.\n\n        # Arguments\n            x: array-like, shape `(n_samples, n_features)`\n                Test samples where `n_samples` is the number of samples\n                and `n_features` is the number of features.\n            **kwargs: dictionary arguments\n                Legal arguments are the arguments of `Sequential.predict`.\n\n        # Returns\n            preds: array-like, shape `(n_samples,)`\n                Predictions.\n        \"\"\"\n        kwargs = self.filter_sk_params(Sequential.predict, kwargs)\n", "\n    def score(self, x, y, **kwargs):\n        \"\"\"Returns the mean loss on the given test data and labels.\n\n        # Arguments\n            x: array-like, shape `(n_samples, n_features)`\n                Test samples where `n_samples` is the number of samples\n                and `n_features` is the number of features.\n            y: array-like, shape `(n_samples,)`\n                True labels for `x`.\n            **kwargs: dictionary arguments\n                Legal arguments are the arguments of `Sequential.evaluate`.\n\n        # Returns\n            score: float\n                Mean accuracy of predictions on `x` wrt. `y`.\n        \"\"\"\n        kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n        loss = self.model.evaluate(x, y, **kwargs)\n        if isinstance(loss, list):\n            return -loss[0]\n        return -loss\n"]}