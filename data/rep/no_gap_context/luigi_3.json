{"prefix": "            def run(self):\n                for location in self.book_locations:\n                    print(\"Go to page %d, line %d\" % (location[0], location[1]))\n\n\n    At the command line, use\n\n    .. code-block:: console\n\n        $ luigi --module my_tasks MyTask --book_locations <JSON string>\n\n    Simple example with two grades:\n\n    .. code-block:: console\n\n        $ luigi --module my_tasks MyTask --book_locations '((12,3),(4,15),(52,1))'\n    \"\"\"\n\n    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        # Since the result of json.dumps(tuple) differs from a tuple string, we must handle either case.\n        # A tuple string may come from a config file or from cli execution.\n\n        # t = ((1, 2), (3, 4))\n        # t_str = '((1,2),(3,4))'\n        # t_json_str = json.dumps(t)\n        # t_json_str == '[[1, 2], [3, 4]]'\n        # json.loads(t_json_str) == t\n        # json.loads(t_str) == ValueError: No JSON object could be decoded\n\n        # Therefore, if json.loads(x) returns a ValueError, try ast.literal_eval(x).\n        # ast.literal_eval(t_str) == t\n        try:\n            # loop required to parse tuple of tuples\n            return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n", "suffix": "\n\nclass NumericalParameter(Parameter):\n    \"\"\"\n    Parameter whose value is a number of the specified type, e.g. ``int`` or\n    ``float`` and in the range specified.\n\n    In the task definition, use\n\n    .. code-block:: python\n\n        class MyTask(luigi.Task):\n            my_param_1 = luigi.NumericalParameter(\n                var_type=int, min_value=-3, max_value=7) # -3 <= my_param_1 < 7\n            my_param_2 = luigi.NumericalParameter(\n                var_type=int, min_value=-3, max_value=7, left_op=operator.lt, right_op=operator.le) # -3 < my_param_2 <= 7\n\n    At the command line, use\n\n    .. code-block:: console\n\n        $ luigi --module my_tasks MyTask --my-param-1 -3 --my-param-2 -2\n    \"\"\"\n\n    def __init__(self, left_op=operator.le, right_op=operator.lt, *args, **kwargs):\n        \"\"\"\n        :param function var_type: The type of the input variable, e.g. int or float.\n        :param min_value: The minimum value permissible in the accepted values\n                          range.  May be inclusive or exclusive based on left_op parameter.\n                          This should be the same type as var_type.\n        :param max_value: The maximum value permissible in the accepted values\n                          range.  May be inclusive or exclusive based on right_op parameter.\n                          This should be the same type as var_type.\n        :param function left_op: The comparison operator for the left-most comparison in\n                                 the expression ``min_value left_op value right_op value``.\n                                 This operator should generally be either\n                                 ``operator.lt`` or ``operator.le``.\n                                 Default: ``operator.le``.\n        :param function right_op: The comparison operator for the right-most comparison in\n                                  the expression ``min_value left_op value right_op value``.\n", "long_prefix": ["    def normalize(self, x):\n        \"\"\"\n        Ensure that struct is recursively converted to a tuple so it can be hashed.\n\n        :param str x: the value to parse.\n        :return: the normalized (hashable/immutable) value.\n        \"\"\"\n        return _recursively_freeze(x)\n\n    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        return list(json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n\n    def serialize(self, x):\n        \"\"\"\n        Opposite of :py:meth:`parse`.\n\n        Converts the value ``x`` to a string.\n\n        :param x: the value to serialize.\n        \"\"\"\n        return json.dumps(x, cls=_DictParamEncoder)\n\n\nclass TupleParameter(ListParameter):\n    \"\"\"\n    Parameter whose value is a ``tuple`` or ``tuple`` of tuples.\n\n    In the task definition, use\n\n    .. code-block:: python\n\n        class MyTask(luigi.Task):\n          book_locations = luigi.TupleParameter()\n\n            def run(self):\n                for location in self.book_locations:\n                    print(\"Go to page %d, line %d\" % (location[0], location[1]))\n\n\n    At the command line, use\n\n    .. code-block:: console\n\n        $ luigi --module my_tasks MyTask --book_locations <JSON string>\n\n    Simple example with two grades:\n\n    .. code-block:: console\n\n        $ luigi --module my_tasks MyTask --book_locations '((12,3),(4,15),(52,1))'\n    \"\"\"\n\n    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        # Since the result of json.dumps(tuple) differs from a tuple string, we must handle either case.\n        # A tuple string may come from a config file or from cli execution.\n\n        # t = ((1, 2), (3, 4))\n        # t_str = '((1,2),(3,4))'\n        # t_json_str = json.dumps(t)\n        # t_json_str == '[[1, 2], [3, 4]]'\n        # json.loads(t_json_str) == t\n        # json.loads(t_str) == ValueError: No JSON object could be decoded\n\n        # Therefore, if json.loads(x) returns a ValueError, try ast.literal_eval(x).\n        # ast.literal_eval(t_str) == t\n        try:\n            # loop required to parse tuple of tuples\n            return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n", "\n\nclass NumericalParameter(Parameter):\n    \"\"\"\n    Parameter whose value is a number of the specified type, e.g. ``int`` or\n    ``float`` and in the range specified.\n\n    In the task definition, use\n\n    .. code-block:: python\n\n        class MyTask(luigi.Task):\n            my_param_1 = luigi.NumericalParameter(\n                var_type=int, min_value=-3, max_value=7) # -3 <= my_param_1 < 7\n            my_param_2 = luigi.NumericalParameter(\n                var_type=int, min_value=-3, max_value=7, left_op=operator.lt, right_op=operator.le) # -3 < my_param_2 <= 7\n\n    At the command line, use\n\n    .. code-block:: console\n\n        $ luigi --module my_tasks MyTask --my-param-1 -3 --my-param-2 -2\n    \"\"\"\n\n    def __init__(self, left_op=operator.le, right_op=operator.lt, *args, **kwargs):\n        \"\"\"\n        :param function var_type: The type of the input variable, e.g. int or float.\n        :param min_value: The minimum value permissible in the accepted values\n                          range.  May be inclusive or exclusive based on left_op parameter.\n                          This should be the same type as var_type.\n        :param max_value: The maximum value permissible in the accepted values\n                          range.  May be inclusive or exclusive based on right_op parameter.\n                          This should be the same type as var_type.\n        :param function left_op: The comparison operator for the left-most comparison in\n                                 the expression ``min_value left_op value right_op value``.\n                                 This operator should generally be either\n                                 ``operator.lt`` or ``operator.le``.\n                                 Default: ``operator.le``.\n        :param function right_op: The comparison operator for the right-most comparison in\n                                  the expression ``min_value left_op value right_op value``.\n"]}