{"prefix": "            \\s*\\(\\s*(?P<callback_data>.*)\\);?\n            \\s*?(?://[^\\n]*)*$''',\n        r'\\g<callback_data>', code)\n\n\ndef js_to_json(code):\n    COMMENT_RE = r'/\\*(?:(?!\\*/).)*?\\*/|//[^\\n]*'\n    SKIP_RE = r'\\s*(?:{comment})?\\s*'.format(comment=COMMENT_RE)\n    INTEGER_TABLE = (\n        (r'(?s)^(0[xX][0-9a-fA-F]+){skip}:?$'.format(skip=SKIP_RE), 16),\n        (r'(?s)^(0+[0-7]+){skip}:?$'.format(skip=SKIP_RE), 8),\n    )\n\n    def fix_kv(m):\n        v = m.group(0)\n        if v in ('true', 'false', 'null'):\n            return v\n        elif v.startswith('/*') or v.startswith('//') or v == ',':\n            return \"\"\n\n        if v[0] in (\"'\", '\"'):\n            v = re.sub(r'(?s)\\\\.|\"', lambda m: {\n                '\"': '\\\\\"',\n                \"\\\\'\": \"'\",\n                '\\\\\\n': '',\n                '\\\\x': '\\\\u00',\n            }.get(m.group(0), m.group(0)), v[1:-1])\n\n        for regex, base in INTEGER_TABLE:\n            im = re.match(regex, v)\n            if im:\n                i = int(im.group(1), base)\n                return '\"%d\":' % i if v.endswith(':') else '%d' % i\n\n        return '\"%s\"' % v\n\n    return re.sub(r'''(?sx)\n        \"(?:[^\"\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^\"\\\\]*\"|\n        '(?:[^'\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^'\\\\]*'|\n        {comment}|,(?={skip}[\\]}}])|\n", "suffix": "        \\b(?:0[xX][0-9a-fA-F]+|0+[0-7]+)(?:{skip}:)?|\n        [0-9]+(?={skip}:)\n        '''.format(comment=COMMENT_RE, skip=SKIP_RE), fix_kv, code)\n\n\ndef qualities(quality_ids):\n    \"\"\" Get a numeric quality value out of a list of possible values \"\"\"\n    def q(qid):\n        try:\n            return quality_ids.index(qid)\n        except ValueError:\n            return -1\n    return q\n\n\nDEFAULT_OUTTMPL = '%(title)s-%(id)s.%(ext)s'\n\n\ndef limit_length(s, length):\n    \"\"\" Add ellipses to overly long strings \"\"\"\n    if s is None:\n        return None\n    ELLIPSES = '...'\n    if len(s) > length:\n        return s[:length - len(ELLIPSES)] + ELLIPSES\n    return s\n\n\ndef version_tuple(v):\n    return tuple(int(e) for e in re.split(r'[-.]', v))\n\n\ndef is_outdated_version(version, limit, assume_new=True):\n    if not version:\n        return not assume_new\n    try:\n        return version_tuple(version) < version_tuple(limit)\n    except ValueError:\n        return not assume_new\n\n", "long_prefix": ["    return string if isinstance(string, compat_str) else compat_str(string, encoding, errors)\n\n\nUS_RATINGS = {\n    'G': 0,\n    'PG': 10,\n    'PG-13': 13,\n    'R': 16,\n    'NC': 18,\n}\n\n\nTV_PARENTAL_GUIDELINES = {\n    'TV-Y': 0,\n    'TV-Y7': 7,\n    'TV-G': 0,\n    'TV-PG': 0,\n    'TV-14': 14,\n    'TV-MA': 17,\n}\n\n\ndef parse_age_limit(s):\n    if type(s) == int:\n        return s if 0 <= s <= 21 else None\n    if not isinstance(s, compat_basestring):\n        return None\n    m = re.match(r'^(?P<age>\\d{1,2})\\+?$', s)\n    if m:\n        return int(m.group('age'))\n    if s in US_RATINGS:\n        return US_RATINGS[s]\n    return TV_PARENTAL_GUIDELINES.get(s)\n\n\ndef strip_jsonp(code):\n    return re.sub(\n        r'''(?sx)^\n            (?:window\\.)?(?P<func_name>[a-zA-Z0-9_.$]+)\n            (?:\\s*&&\\s*(?P=func_name))?\n            \\s*\\(\\s*(?P<callback_data>.*)\\);?\n            \\s*?(?://[^\\n]*)*$''',\n        r'\\g<callback_data>', code)\n\n\ndef js_to_json(code):\n    COMMENT_RE = r'/\\*(?:(?!\\*/).)*?\\*/|//[^\\n]*'\n    SKIP_RE = r'\\s*(?:{comment})?\\s*'.format(comment=COMMENT_RE)\n    INTEGER_TABLE = (\n        (r'(?s)^(0[xX][0-9a-fA-F]+){skip}:?$'.format(skip=SKIP_RE), 16),\n        (r'(?s)^(0+[0-7]+){skip}:?$'.format(skip=SKIP_RE), 8),\n    )\n\n    def fix_kv(m):\n        v = m.group(0)\n        if v in ('true', 'false', 'null'):\n            return v\n        elif v.startswith('/*') or v.startswith('//') or v == ',':\n            return \"\"\n\n        if v[0] in (\"'\", '\"'):\n            v = re.sub(r'(?s)\\\\.|\"', lambda m: {\n                '\"': '\\\\\"',\n                \"\\\\'\": \"'\",\n                '\\\\\\n': '',\n                '\\\\x': '\\\\u00',\n            }.get(m.group(0), m.group(0)), v[1:-1])\n\n        for regex, base in INTEGER_TABLE:\n            im = re.match(regex, v)\n            if im:\n                i = int(im.group(1), base)\n                return '\"%d\":' % i if v.endswith(':') else '%d' % i\n\n        return '\"%s\"' % v\n\n    return re.sub(r'''(?sx)\n        \"(?:[^\"\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^\"\\\\]*\"|\n        '(?:[^'\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^'\\\\]*'|\n        {comment}|,(?={skip}[\\]}}])|\n", "        \\b(?:0[xX][0-9a-fA-F]+|0+[0-7]+)(?:{skip}:)?|\n        [0-9]+(?={skip}:)\n        '''.format(comment=COMMENT_RE, skip=SKIP_RE), fix_kv, code)\n\n\ndef qualities(quality_ids):\n    \"\"\" Get a numeric quality value out of a list of possible values \"\"\"\n    def q(qid):\n        try:\n            return quality_ids.index(qid)\n        except ValueError:\n            return -1\n    return q\n\n\nDEFAULT_OUTTMPL = '%(title)s-%(id)s.%(ext)s'\n\n\ndef limit_length(s, length):\n    \"\"\" Add ellipses to overly long strings \"\"\"\n    if s is None:\n        return None\n    ELLIPSES = '...'\n    if len(s) > length:\n        return s[:length - len(ELLIPSES)] + ELLIPSES\n    return s\n\n\ndef version_tuple(v):\n    return tuple(int(e) for e in re.split(r'[-.]', v))\n\n\ndef is_outdated_version(version, limit, assume_new=True):\n    if not version:\n        return not assume_new\n    try:\n        return version_tuple(version) < version_tuple(limit)\n    except ValueError:\n        return not assume_new\n\n"]}