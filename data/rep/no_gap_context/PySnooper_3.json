{"prefix": "# Copyright 2019 Ram Rachum.\n# This program is distributed under the MIT license.\n\nimport sys\nimport os\nimport inspect\nimport types\nimport datetime as datetime_module\nimport re\nimport collections\n\nimport decorator\n\nfrom . import utils\nfrom . import pycompat\nfrom .tracer import Tracer\n\n\ndef get_write_function(output):\n    if output is None:\n        def write(s):\n            stderr = sys.stderr\n            stderr.write(s)\n    elif isinstance(output, (pycompat.PathLike, str)):\n        def write(s):\n", "suffix": "                output_file.write(s)\n    else:\n        assert isinstance(output, utils.WritableStream)\n        def write(s):\n            output.write(s)\n\n    return write\n\n\n\ndef snoop(output=None, variables=(), depth=1, prefix=''):\n    '''\n    Snoop on the function, writing everything it's doing to stderr.\n\n    This is useful for debugging.\n\n    When you decorate a function with `@pysnooper.snoop()`, you'll get a log of\n    every line that ran in the function and a play-by-play of every local\n    variable that changed.\n\n    If stderr is not easily accessible for you, you can redirect the output to\n    a file::\n\n        @pysnooper.snoop('/my/log/file.log')\n\n    See values of some variables that aren't local variables::\n\n        @pysnooper.snoop(variables=('foo.bar', 'self.whatever'))\n\n    Show snoop lines for functions that your function calls::\n\n        @pysnooper.snoop(depth=2)\n\n    Start all snoop lines with a prefix, to grep for them easily::\n\n        @pysnooper.snoop(prefix='ZZZ ')\n\n    '''\n    write = get_write_function(output)\n    @decorator.decorator\n", "long_prefix": ["# Copyright 2019 Ram Rachum.\n# This program is distributed under the MIT license.\n\nimport sys\nimport os\nimport inspect\nimport types\nimport datetime as datetime_module\nimport re\nimport collections\n\nimport decorator\n\nfrom . import utils\nfrom . import pycompat\nfrom .tracer import Tracer\n\n\ndef get_write_function(output):\n    if output is None:\n        def write(s):\n            stderr = sys.stderr\n            stderr.write(s)\n    elif isinstance(output, (pycompat.PathLike, str)):\n        def write(s):\n", "                output_file.write(s)\n    else:\n        assert isinstance(output, utils.WritableStream)\n        def write(s):\n            output.write(s)\n\n    return write\n\n\n\ndef snoop(output=None, variables=(), depth=1, prefix=''):\n    '''\n    Snoop on the function, writing everything it's doing to stderr.\n\n    This is useful for debugging.\n\n    When you decorate a function with `@pysnooper.snoop()`, you'll get a log of\n    every line that ran in the function and a play-by-play of every local\n    variable that changed.\n\n    If stderr is not easily accessible for you, you can redirect the output to\n    a file::\n\n        @pysnooper.snoop('/my/log/file.log')\n\n    See values of some variables that aren't local variables::\n\n        @pysnooper.snoop(variables=('foo.bar', 'self.whatever'))\n\n    Show snoop lines for functions that your function calls::\n\n        @pysnooper.snoop(depth=2)\n\n    Start all snoop lines with a prefix, to grep for them easily::\n\n        @pysnooper.snoop(prefix='ZZZ ')\n\n    '''\n    write = get_write_function(output)\n    @decorator.decorator\n"]}