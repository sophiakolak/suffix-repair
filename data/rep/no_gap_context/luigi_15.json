{"prefix": "\n    def get_active_workers(self, last_active_lt=None, last_get_work_gt=None):\n        for worker in six.itervalues(self._active_workers):\n            if last_active_lt is not None and worker.last_active >= last_active_lt:\n                continue\n            last_get_work = getattr(worker, 'last_get_work', None)\n            if last_get_work_gt is not None and (\n                    last_get_work is None or last_get_work <= last_get_work_gt):\n                continue\n            yield worker\n\n    def get_assistants(self, last_active_lt=None):\n        return filter(lambda w: w.assistant, self.get_active_workers(last_active_lt))\n\n    def get_worker_ids(self):\n        return self._active_workers.keys()  # only used for unit tests\n\n    def get_worker(self, worker_id):\n        return self._active_workers.setdefault(worker_id, Worker(worker_id))\n\n    def inactivate_workers(self, delete_workers):\n        # Mark workers as inactive\n        for worker in delete_workers:\n            self._active_workers.pop(worker)\n        self._remove_workers_from_tasks(delete_workers)\n\n    def _remove_workers_from_tasks(self, workers, remove_stakeholders=True):\n        for task in self.get_active_tasks():\n            if remove_stakeholders:\n                task.stakeholders.difference_update(workers)\n            task.workers.difference_update(workers)\n\n    def disable_workers(self, workers):\n        self._remove_workers_from_tasks(workers, remove_stakeholders=False)\n        for worker in workers:\n            self.get_worker(worker).disabled = True\n\n    def get_necessary_tasks(self):\n        necessary_tasks = set()\n        for task in self.get_active_tasks():\n", "suffix": "                necessary_tasks.update(task.deps)\n                necessary_tasks.add(task.id)\n        return necessary_tasks\n\n\nclass CentralPlannerScheduler(Scheduler):\n    \"\"\"\n    Async scheduler that can handle multiple workers, etc.\n\n    Can be run locally or on a server (using RemoteScheduler + server.Server).\n    \"\"\"\n\n    def __init__(self, config=None, resources=None, task_history_impl=None, **kwargs):\n        \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_override: ignore config and use this object as the task history\n        \"\"\"\n        self._config = config or scheduler(**kwargs)\n        self._state = SimpleTaskState(self._config.state_path)\n\n        if task_history_impl:\n            self._task_history = task_history_impl\n        elif self._config.record_task_history:\n            from luigi import db_task_history  # Needs sqlalchemy, thus imported here\n            self._task_history = db_task_history.DbTaskHistory()\n        else:\n            self._task_history = history.NopHistory()\n        self._resources = resources or configuration.get_config().getintdict('resources')  # TODO: Can we make this a Parameter?\n        self._make_task = functools.partial(\n            Task, disable_failures=self._config.disable_failures,\n            disable_hard_timeout=self._config.disable_hard_timeout,\n            disable_window=self._config.disable_window)\n        self._worker_requests = {}\n\n    def load(self):\n        self._state.load()\n\n    def dump(self):\n", "long_prefix": ["            task.status = new_status\n            task.updated = time.time()\n\n    def fail_dead_worker_task(self, task, config, assistants):\n        # If a running worker disconnects, tag all its jobs as FAILED and subject it to the same retry logic\n        if task.status == RUNNING and task.worker_running and task.worker_running not in task.stakeholders | assistants:\n            logger.info(\"Task %r is marked as running by disconnected worker %r -> marking as \"\n                        \"FAILED with retry delay of %rs\", task.id, task.worker_running,\n                        config.retry_delay)\n            task.worker_running = None\n            self.set_status(task, FAILED, config)\n            task.retry = time.time() + config.retry_delay\n\n    def update_status(self, task, config):\n        # Mark tasks with no remaining active stakeholders for deletion\n        if not task.stakeholders:\n            if task.remove is None:\n                logger.info(\"Task %r has stakeholders %r but none remain connected -> might remove \"\n                            \"task in %s seconds\", task.id, task.stakeholders, config.remove_delay)\n                task.remove = time.time() + config.remove_delay\n\n        # Re-enable task after the disable time expires\n        if task.status == DISABLED and task.scheduler_disable_time is not None:\n            if time.time() - task.scheduler_disable_time > config.disable_persist:\n                self.re_enable(task, config)\n\n        # Reset FAILED tasks to PENDING if max timeout is reached, and retry delay is >= 0\n        if task.status == FAILED and config.retry_delay >= 0 and task.retry < time.time():\n            self.set_status(task, PENDING, config)\n\n    def may_prune(self, task):\n        return task.remove and time.time() > task.remove\n\n    def inactivate_tasks(self, delete_tasks):\n        # The terminology is a bit confusing: we used to \"delete\" tasks when they became inactive,\n        # but with a pluggable state storage, you might very well want to keep some history of\n        # older tasks as well. That's why we call it \"inactivate\" (as in the verb)\n        for task in delete_tasks:\n            task_obj = self._tasks.pop(task)\n            self._status_tasks[task_obj.status].pop(task)\n\n    def get_active_workers(self, last_active_lt=None, last_get_work_gt=None):\n        for worker in six.itervalues(self._active_workers):\n            if last_active_lt is not None and worker.last_active >= last_active_lt:\n                continue\n            last_get_work = getattr(worker, 'last_get_work', None)\n            if last_get_work_gt is not None and (\n                    last_get_work is None or last_get_work <= last_get_work_gt):\n                continue\n            yield worker\n\n    def get_assistants(self, last_active_lt=None):\n        return filter(lambda w: w.assistant, self.get_active_workers(last_active_lt))\n\n    def get_worker_ids(self):\n        return self._active_workers.keys()  # only used for unit tests\n\n    def get_worker(self, worker_id):\n        return self._active_workers.setdefault(worker_id, Worker(worker_id))\n\n    def inactivate_workers(self, delete_workers):\n        # Mark workers as inactive\n        for worker in delete_workers:\n            self._active_workers.pop(worker)\n        self._remove_workers_from_tasks(delete_workers)\n\n    def _remove_workers_from_tasks(self, workers, remove_stakeholders=True):\n        for task in self.get_active_tasks():\n            if remove_stakeholders:\n                task.stakeholders.difference_update(workers)\n            task.workers.difference_update(workers)\n\n    def disable_workers(self, workers):\n        self._remove_workers_from_tasks(workers, remove_stakeholders=False)\n        for worker in workers:\n            self.get_worker(worker).disabled = True\n\n    def get_necessary_tasks(self):\n        necessary_tasks = set()\n        for task in self.get_active_tasks():\n", "                necessary_tasks.update(task.deps)\n                necessary_tasks.add(task.id)\n        return necessary_tasks\n\n\nclass CentralPlannerScheduler(Scheduler):\n    \"\"\"\n    Async scheduler that can handle multiple workers, etc.\n\n    Can be run locally or on a server (using RemoteScheduler + server.Server).\n    \"\"\"\n\n    def __init__(self, config=None, resources=None, task_history_impl=None, **kwargs):\n        \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_override: ignore config and use this object as the task history\n        \"\"\"\n        self._config = config or scheduler(**kwargs)\n        self._state = SimpleTaskState(self._config.state_path)\n\n        if task_history_impl:\n            self._task_history = task_history_impl\n        elif self._config.record_task_history:\n            from luigi import db_task_history  # Needs sqlalchemy, thus imported here\n            self._task_history = db_task_history.DbTaskHistory()\n        else:\n            self._task_history = history.NopHistory()\n        self._resources = resources or configuration.get_config().getintdict('resources')  # TODO: Can we make this a Parameter?\n        self._make_task = functools.partial(\n            Task, disable_failures=self._config.disable_failures,\n            disable_hard_timeout=self._config.disable_hard_timeout,\n            disable_window=self._config.disable_window)\n        self._worker_requests = {}\n\n    def load(self):\n        self._state.load()\n\n    def dump(self):\n"]}