{"prefix": "        elif isinstance(other, DateOffset):\n            freqstr = other.rule_code\n            base = libfrequencies.get_base_alias(freqstr)\n            if base == self.freq.rule_code:\n                return other.n\n\n            raise raise_on_incompatible(self, other)\n        elif is_integer(other):\n            # integer is passed to .shift via\n            # _add_datetimelike_methods basically\n            # but ufunc may pass integer to _add_delta\n            return other\n\n        # raise when input doesn't have freq\n        raise raise_on_incompatible(self, None)\n\n    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\n        \"\"\"\n        Can we compare values of the given dtype to our own?\n        \"\"\"\n        if not isinstance(dtype, PeriodDtype):\n            return False\n        return dtype.freq == self.freq\n\n    # ------------------------------------------------------------------------\n    # Rendering Methods\n\n    def _mpl_repr(self):\n        # how to represent ourselves to matplotlib\n        return self.astype(object)._values\n\n    @property\n    def _formatter_func(self):\n        return self.array._formatter(boxed=False)\n\n    # ------------------------------------------------------------------------\n    # Indexing\n\n    @cache_readonly\n    def _engine(self):\n", "suffix": "        return self._engine_type(period, len(self))\n\n    @doc(Index.__contains__)\n    def __contains__(self, key: Any) -> bool:\n        if isinstance(key, Period):\n            if key.freq != self.freq:\n                return False\n            else:\n                return key.ordinal in self._engine\n        else:\n            hash(key)\n            try:\n                self.get_loc(key)\n                return True\n            except KeyError:\n                return False\n\n    @cache_readonly\n    def _int64index(self) -> Int64Index:\n        return Int64Index._simple_new(self.asi8, name=self.name)\n\n    # ------------------------------------------------------------------------\n    # Index Methods\n\n    def __array_wrap__(self, result, context=None):\n        \"\"\"\n        Gets called after a ufunc. Needs additional handling as\n        PeriodIndex stores internal data as int dtype\n\n        Replace this to __numpy_ufunc__ in future version\n        \"\"\"\n        if isinstance(context, tuple) and len(context) > 0:\n            func = context[0]\n            if func is np.add:\n                pass\n            elif func is np.subtract:\n                name = self.name\n                left = context[1][0]\n                right = context[1][1]\n                if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n", "long_prefix": ["        return np.asarray(self)\n\n    @property\n    def _has_complex_internals(self):\n        # used to avoid libreduction code paths, which raise or require conversion\n        return True\n\n    def _shallow_copy(self, values=None, name: Label = no_default):\n        name = name if name is not no_default else self.name\n        cache = self._cache.copy() if values is None else {}\n        if values is None:\n            values = self._data\n\n        result = self._simple_new(values, name=name)\n        result._cache = cache\n        return result\n\n    def _maybe_convert_timedelta(self, other):\n        \"\"\"\n        Convert timedelta-like input to an integer multiple of self.freq\n\n        Parameters\n        ----------\n        other : timedelta, np.timedelta64, DateOffset, int, np.ndarray\n\n        Returns\n        -------\n        converted : int, np.ndarray[int64]\n\n        Raises\n        ------\n        IncompatibleFrequency : if the input cannot be written as a multiple\n            of self.freq.  Note IncompatibleFrequency subclasses ValueError.\n        \"\"\"\n        if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):\n            offset = frequencies.to_offset(self.freq.rule_code)\n            if isinstance(offset, Tick):\n                # _check_timedeltalike_freq_compat will raise if incompatible\n                delta = self._data._check_timedeltalike_freq_compat(other)\n                return delta\n        elif isinstance(other, DateOffset):\n            freqstr = other.rule_code\n            base = libfrequencies.get_base_alias(freqstr)\n            if base == self.freq.rule_code:\n                return other.n\n\n            raise raise_on_incompatible(self, other)\n        elif is_integer(other):\n            # integer is passed to .shift via\n            # _add_datetimelike_methods basically\n            # but ufunc may pass integer to _add_delta\n            return other\n\n        # raise when input doesn't have freq\n        raise raise_on_incompatible(self, None)\n\n    def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:\n        \"\"\"\n        Can we compare values of the given dtype to our own?\n        \"\"\"\n        if not isinstance(dtype, PeriodDtype):\n            return False\n        return dtype.freq == self.freq\n\n    # ------------------------------------------------------------------------\n    # Rendering Methods\n\n    def _mpl_repr(self):\n        # how to represent ourselves to matplotlib\n        return self.astype(object)._values\n\n    @property\n    def _formatter_func(self):\n        return self.array._formatter(boxed=False)\n\n    # ------------------------------------------------------------------------\n    # Indexing\n\n    @cache_readonly\n    def _engine(self):\n", "        return self._engine_type(period, len(self))\n\n    @doc(Index.__contains__)\n    def __contains__(self, key: Any) -> bool:\n        if isinstance(key, Period):\n            if key.freq != self.freq:\n                return False\n            else:\n                return key.ordinal in self._engine\n        else:\n            hash(key)\n            try:\n                self.get_loc(key)\n                return True\n            except KeyError:\n                return False\n\n    @cache_readonly\n    def _int64index(self) -> Int64Index:\n        return Int64Index._simple_new(self.asi8, name=self.name)\n\n    # ------------------------------------------------------------------------\n    # Index Methods\n\n    def __array_wrap__(self, result, context=None):\n        \"\"\"\n        Gets called after a ufunc. Needs additional handling as\n        PeriodIndex stores internal data as int dtype\n\n        Replace this to __numpy_ufunc__ in future version\n        \"\"\"\n        if isinstance(context, tuple) and len(context) > 0:\n            func = context[0]\n            if func is np.add:\n                pass\n            elif func is np.subtract:\n                name = self.name\n                left = context[1][0]\n                right = context[1][1]\n                if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n"]}