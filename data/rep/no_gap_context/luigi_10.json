{"prefix": "class Worker(object):\n    \"\"\"\n    Structure for tracking worker activity and keeping their references.\n    \"\"\"\n\n    def __init__(self, worker_id, last_active=None):\n        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active or time.time()  # seconds since epoch\n        self.last_get_work = None\n        self.started = time.time()  # seconds since epoch\n        self.tasks = set()  # task objects\n        self.info = {}\n        self.disabled = False\n\n    def add_info(self, info):\n        self.info.update(info)\n\n    def update(self, worker_reference, get_work=False):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()\n        if get_work:\n            self.last_get_work = time.time()\n\n    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True\n\n    def get_pending_tasks(self, state):\n        \"\"\"\n        Get PENDING (and RUNNING) tasks for this worker.\n\n        You have to pass in the state for optimization reasons.\n        \"\"\"\n        if len(self.tasks) < state.num_pending_tasks():\n            return six.moves.filter(lambda task: task.status in [PENDING, RUNNING],\n                                    self.tasks)\n        else:\n", "suffix": "\n    def is_trivial_worker(self, state):\n        \"\"\"\n        If it's not an assistant having only tasks that are without\n        requirements.\n\n        We have to pass the state parameter for optimization reasons.\n        \"\"\"\n        if self.assistant:\n            return False\n        return all(not task.resources for task in self.get_pending_tasks(state))\n\n    @property\n    def assistant(self):\n        return self.info.get('assistant', False)\n\n    def __str__(self):\n        return self.id\n\n\nclass SimpleTaskState(object):\n    \"\"\"\n    Keep track of the current state and handle persistance.\n\n    The point of this class is to enable other ways to keep state, eg. by using a database\n    These will be implemented by creating an abstract base class that this and other classes\n    inherit from.\n    \"\"\"\n\n    def __init__(self, state_path):\n        self._state_path = state_path\n        self._tasks = {}  # map from id to a Task object\n        self._status_tasks = collections.defaultdict(dict)\n        self._active_workers = {}  # map from id to a Worker object\n        self._task_batchers = {}\n\n    def get_state(self):\n        return self._tasks, self._active_workers, self._task_batchers\n\n    def set_state(self, state):\n", "long_prefix": ["        self.failures = Failures(self.retry_policy.disable_window)\n        self.tracking_url = tracking_url\n        self.status_message = status_message\n        self.scheduler_disable_time = None\n        self.runnable = False\n        self.batchable = False\n        self.batch_id = None\n\n    def __repr__(self):\n        return \"Task(%r)\" % vars(self)\n\n    # TODO(2017-08-10) replace this function with direct calls to batchable\n    # this only exists for backward compatibility\n    def is_batchable(self):\n        try:\n            return self.batchable\n        except AttributeError:\n            return False\n\n    def add_failure(self):\n        self.failures.add_failure()\n\n    def has_excessive_failures(self):\n        if self.failures.first_failure_time is not None:\n            if (time.time() >= self.failures.first_failure_time + self.retry_policy.disable_hard_timeout):\n                return True\n\n        logger.debug('%s task num failures is %s and limit is %s', self.id, self.failures.num_failures(), self.retry_policy.retry_count)\n        if self.failures.num_failures() >= self.retry_policy.retry_count:\n            logger.debug('%s task num failures limit(%s) is exceeded', self.id, self.retry_policy.retry_count)\n            return True\n\n        return False\n\n    @property\n    def pretty_id(self):\n        param_str = ', '.join('{}={}'.format(key, value) for key, value in self.params.items())\n        return '{}({})'.format(self.family, param_str)\n\n\nclass Worker(object):\n    \"\"\"\n    Structure for tracking worker activity and keeping their references.\n    \"\"\"\n\n    def __init__(self, worker_id, last_active=None):\n        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active or time.time()  # seconds since epoch\n        self.last_get_work = None\n        self.started = time.time()  # seconds since epoch\n        self.tasks = set()  # task objects\n        self.info = {}\n        self.disabled = False\n\n    def add_info(self, info):\n        self.info.update(info)\n\n    def update(self, worker_reference, get_work=False):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()\n        if get_work:\n            self.last_get_work = time.time()\n\n    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True\n\n    def get_pending_tasks(self, state):\n        \"\"\"\n        Get PENDING (and RUNNING) tasks for this worker.\n\n        You have to pass in the state for optimization reasons.\n        \"\"\"\n        if len(self.tasks) < state.num_pending_tasks():\n            return six.moves.filter(lambda task: task.status in [PENDING, RUNNING],\n                                    self.tasks)\n        else:\n", "\n    def is_trivial_worker(self, state):\n        \"\"\"\n        If it's not an assistant having only tasks that are without\n        requirements.\n\n        We have to pass the state parameter for optimization reasons.\n        \"\"\"\n        if self.assistant:\n            return False\n        return all(not task.resources for task in self.get_pending_tasks(state))\n\n    @property\n    def assistant(self):\n        return self.info.get('assistant', False)\n\n    def __str__(self):\n        return self.id\n\n\nclass SimpleTaskState(object):\n    \"\"\"\n    Keep track of the current state and handle persistance.\n\n    The point of this class is to enable other ways to keep state, eg. by using a database\n    These will be implemented by creating an abstract base class that this and other classes\n    inherit from.\n    \"\"\"\n\n    def __init__(self, state_path):\n        self._state_path = state_path\n        self._tasks = {}  # map from id to a Task object\n        self._status_tasks = collections.defaultdict(dict)\n        self._active_workers = {}  # map from id to a Worker object\n        self._task_batchers = {}\n\n    def get_state(self):\n        return self._tasks, self._active_workers, self._task_batchers\n\n    def set_state(self, state):\n"]}