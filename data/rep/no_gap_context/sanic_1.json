{"prefix": "        return response\n\n    def register_middleware(self, middleware, attach_to=\"request\"):\n        \"\"\"\n        Register an application level middleware that will be attached\n        to all the API URLs registered under this application.\n\n        This method is internally invoked by the :func:`middleware`\n        decorator provided at the app level.\n\n        :param middleware: Callback method to be attached to the\n            middleware\n        :param attach_to: The state at which the middleware needs to be\n            invoked in the lifecycle of an *HTTP Request*.\n            **request** - Invoke before the request is processed\n            **response** - Invoke before the response is returned back\n        :return: decorated method\n        \"\"\"\n        if attach_to == \"request\":\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if attach_to == \"response\":\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return middleware\n\n    def register_named_middleware(\n        self, middleware, route_names, attach_to=\"request\"\n    ):\n        if attach_to == \"request\":\n            for _rn in route_names:\n                if _rn not in self.named_request_middleware:\n                    self.named_request_middleware[_rn] = deque()\n                if middleware not in self.named_request_middleware[_rn]:\n                    self.named_request_middleware[_rn].append(middleware)\n        if attach_to == \"response\":\n            for _rn in route_names:\n                if _rn not in self.named_response_middleware:\n                    self.named_response_middleware[_rn] = deque()\n                if middleware not in self.named_response_middleware[_rn]:\n", "suffix": "\n    # Decorator\n    def middleware(self, middleware_or_request):\n        \"\"\"\n        Decorate and register middleware to be called before a request.\n        Can either be called as *@app.middleware* or\n        *@app.middleware('request')*\n\n        :param: middleware_or_request: Optional parameter to use for\n            identifying which type of middleware is being registered.\n        \"\"\"\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if callable(middleware_or_request):\n            return self.register_middleware(middleware_or_request)\n\n        else:\n            return partial(\n                self.register_middleware, attach_to=middleware_or_request\n            )\n\n    # Static Files\n    def static(\n        self,\n        uri,\n        file_or_directory,\n        pattern=r\"/?.+\",\n        use_modified_since=True,\n        use_content_range=False,\n        stream_large_files=False,\n        name=\"static\",\n        host=None,\n        strict_slashes=None,\n        content_type=None,\n    ):\n        \"\"\"\n        Register a root to serve files from. The input can either be a\n        file or a directory. This method will enable an easy and simple way\n        to setup the :class:`Route` necessary to serve the static files.\n\n        :param uri: URL path to be used for serving static content\n", "long_prefix": ["            uri,\n            host=host,\n            strict_slashes=strict_slashes,\n            subprotocols=subprotocols,\n            name=name,\n        )(handler)\n\n    def enable_websocket(self, enable=True):\n        \"\"\"Enable or disable the support for websocket.\n\n        Websocket is enabled automatically if websocket routes are\n        added to the application.\n        \"\"\"\n        if not self.websocket_enabled:\n            # if the server is stopped, we want to cancel any ongoing\n            # websocket tasks, to allow the server to exit promptly\n            @self.listener(\"before_server_stop\")\n            def cancel_websocket_tasks(app, loop):\n                for task in self.websocket_tasks:\n                    task.cancel()\n\n        self.websocket_enabled = enable\n\n    # Decorator\n    def exception(self, *exceptions):\n        \"\"\"Decorate a function to be registered as a handler for exceptions\n\n        :param exceptions: exceptions\n        :return: decorated function\n        \"\"\"\n\n        def response(handler):\n            for exception in exceptions:\n                if isinstance(exception, (tuple, list)):\n                    for e in exception:\n                        self.error_handler.add(e, handler)\n                else:\n                    self.error_handler.add(exception, handler)\n            return handler\n\n        return response\n\n    def register_middleware(self, middleware, attach_to=\"request\"):\n        \"\"\"\n        Register an application level middleware that will be attached\n        to all the API URLs registered under this application.\n\n        This method is internally invoked by the :func:`middleware`\n        decorator provided at the app level.\n\n        :param middleware: Callback method to be attached to the\n            middleware\n        :param attach_to: The state at which the middleware needs to be\n            invoked in the lifecycle of an *HTTP Request*.\n            **request** - Invoke before the request is processed\n            **response** - Invoke before the response is returned back\n        :return: decorated method\n        \"\"\"\n        if attach_to == \"request\":\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if attach_to == \"response\":\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return middleware\n\n    def register_named_middleware(\n        self, middleware, route_names, attach_to=\"request\"\n    ):\n        if attach_to == \"request\":\n            for _rn in route_names:\n                if _rn not in self.named_request_middleware:\n                    self.named_request_middleware[_rn] = deque()\n                if middleware not in self.named_request_middleware[_rn]:\n                    self.named_request_middleware[_rn].append(middleware)\n        if attach_to == \"response\":\n            for _rn in route_names:\n                if _rn not in self.named_response_middleware:\n                    self.named_response_middleware[_rn] = deque()\n                if middleware not in self.named_response_middleware[_rn]:\n", "\n    # Decorator\n    def middleware(self, middleware_or_request):\n        \"\"\"\n        Decorate and register middleware to be called before a request.\n        Can either be called as *@app.middleware* or\n        *@app.middleware('request')*\n\n        :param: middleware_or_request: Optional parameter to use for\n            identifying which type of middleware is being registered.\n        \"\"\"\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if callable(middleware_or_request):\n            return self.register_middleware(middleware_or_request)\n\n        else:\n            return partial(\n                self.register_middleware, attach_to=middleware_or_request\n            )\n\n    # Static Files\n    def static(\n        self,\n        uri,\n        file_or_directory,\n        pattern=r\"/?.+\",\n        use_modified_since=True,\n        use_content_range=False,\n        stream_large_files=False,\n        name=\"static\",\n        host=None,\n        strict_slashes=None,\n        content_type=None,\n    ):\n        \"\"\"\n        Register a root to serve files from. The input can either be a\n        file or a directory. This method will enable an easy and simple way\n        to setup the :class:`Route` necessary to serve the static files.\n\n        :param uri: URL path to be used for serving static content\n"]}