{"prefix": "\n        key = self._convert_key(key)\n        return self.obj._get_value(*key, takeable=self._takeable)\n\n    def __setitem__(self, key, value):\n        if isinstance(key, tuple):\n            key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n        else:\n            # scalar callable may return tuple\n            key = com.apply_if_callable(key, self.obj)\n\n        if not isinstance(key, tuple):\n            key = _tuplify(self.ndim, key)\n        if len(key) != self.ndim:\n            raise ValueError(\"Not enough indexers for scalar access (setting)!\")\n        key = list(self._convert_key(key, is_setter=True))\n        self.obj._set_value(*key, value=value, takeable=self._takeable)\n\n\n@Appender(IndexingMixin.at.__doc__)\nclass _AtIndexer(_ScalarAccessIndexer):\n    _takeable = False\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require they keys to be the same type as the index. (so we don't\n        fallback)\n        \"\"\"\n        # allow arbitrary setting\n        if is_setter:\n            return list(key)\n\n        for ax, i in zip(self.obj.axes, key):\n            if ax.is_integer():\n                if not is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an integer index \"\n                        \"can only have integer indexers\"\n                    )\n            else:\n", "suffix": "                    raise ValueError(\n                        \"At based indexing on an non-integer \"\n                        \"index can only have non-integer \"\n                        \"indexers\"\n                    )\n        return key\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = True\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require integer args. (and convert to label arguments)\n        \"\"\"\n        for a, i in zip(self.obj.axes, key):\n            if not is_integer(i):\n                raise ValueError(\"iAt based indexing can only have integer indexers\")\n        return key\n\n\ndef _tuplify(ndim: int, loc: Hashable) -> Tuple[Union[Hashable, slice], ...]:\n    \"\"\"\n    Given an indexer for the first dimension, create an equivalent tuple\n    for indexing over all dimensions.\n\n    Parameters\n    ----------\n    ndim : int\n    loc : object\n\n    Returns\n    -------\n    tuple\n    \"\"\"\n    _tup: List[Union[Hashable, slice]]\n    _tup = [slice(None, None) for _ in range(ndim)]\n    _tup[0] = loc\n    return tuple(_tup)\n", "long_prefix": ["        if not need_slice(slice_obj):\n            return obj.copy(deep=False)\n\n        indexer = self._convert_slice_indexer(slice_obj, axis)\n        return self._slice(indexer, axis=axis, kind=\"iloc\")\n\n    def _convert_to_indexer(self, key, axis: int):\n        \"\"\"\n        Much simpler as we only have to deal with our valid types.\n        \"\"\"\n        # make need to convert a float key\n        if isinstance(key, slice):\n            return self._convert_slice_indexer(key, axis)\n\n        elif is_float(key):\n            return self._convert_scalar_indexer(key, axis)\n\n        try:\n            self._validate_key(key, axis)\n            return key\n        except ValueError:\n            raise ValueError(f\"Can only index by location with a [{self._valid_types}]\")\n\n\nclass _ScalarAccessIndexer(_NDFrameIndexerBase):\n    \"\"\"\n    Access scalars quickly.\n    \"\"\"\n\n    def _convert_key(self, key, is_setter: bool = False):\n        raise AbstractMethodError(self)\n\n    def __getitem__(self, key):\n        if not isinstance(key, tuple):\n\n            # we could have a convertible item here (e.g. Timestamp)\n            if not is_list_like_indexer(key):\n                key = tuple([key])\n            else:\n                raise ValueError(\"Invalid call for scalar access (getting)!\")\n\n        key = self._convert_key(key)\n        return self.obj._get_value(*key, takeable=self._takeable)\n\n    def __setitem__(self, key, value):\n        if isinstance(key, tuple):\n            key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n        else:\n            # scalar callable may return tuple\n            key = com.apply_if_callable(key, self.obj)\n\n        if not isinstance(key, tuple):\n            key = _tuplify(self.ndim, key)\n        if len(key) != self.ndim:\n            raise ValueError(\"Not enough indexers for scalar access (setting)!\")\n        key = list(self._convert_key(key, is_setter=True))\n        self.obj._set_value(*key, value=value, takeable=self._takeable)\n\n\n@Appender(IndexingMixin.at.__doc__)\nclass _AtIndexer(_ScalarAccessIndexer):\n    _takeable = False\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require they keys to be the same type as the index. (so we don't\n        fallback)\n        \"\"\"\n        # allow arbitrary setting\n        if is_setter:\n            return list(key)\n\n        for ax, i in zip(self.obj.axes, key):\n            if ax.is_integer():\n                if not is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an integer index \"\n                        \"can only have integer indexers\"\n                    )\n            else:\n", "                    raise ValueError(\n                        \"At based indexing on an non-integer \"\n                        \"index can only have non-integer \"\n                        \"indexers\"\n                    )\n        return key\n\n\n@Appender(IndexingMixin.iat.__doc__)\nclass _iAtIndexer(_ScalarAccessIndexer):\n    _takeable = True\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require integer args. (and convert to label arguments)\n        \"\"\"\n        for a, i in zip(self.obj.axes, key):\n            if not is_integer(i):\n                raise ValueError(\"iAt based indexing can only have integer indexers\")\n        return key\n\n\ndef _tuplify(ndim: int, loc: Hashable) -> Tuple[Union[Hashable, slice], ...]:\n    \"\"\"\n    Given an indexer for the first dimension, create an equivalent tuple\n    for indexing over all dimensions.\n\n    Parameters\n    ----------\n    ndim : int\n    loc : object\n\n    Returns\n    -------\n    tuple\n    \"\"\"\n    _tup: List[Union[Hashable, slice]]\n    _tup = [slice(None, None) for _ in range(ndim)]\n    _tup[0] = loc\n    return tuple(_tup)\n"]}