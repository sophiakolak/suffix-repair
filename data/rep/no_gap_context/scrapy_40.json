{"prefix": "    def export_item(self, item):\n        marshal.dump(dict(self._get_serialized_fields(item)), self.file)\n\n\nclass PprintItemExporter(BaseItemExporter):\n\n    def __init__(self, file, **kwargs):\n        self._configure(kwargs)\n        self.file = file\n\n    def export_item(self, item):\n        itemdict = dict(self._get_serialized_fields(item))\n        self.file.write(to_bytes(pprint.pformat(itemdict) + '\\n'))\n\n\nclass PythonItemExporter(BaseItemExporter):\n    \"\"\"The idea behind this exporter is to have a mechanism to serialize items\n    to built-in python types so any serialization library (like\n    json, msgpack, binc, etc) can be used on top of it. Its main goal is to\n    seamless support what BaseItemExporter does plus nested items.\n    \"\"\"\n    def _configure(self, options, dont_fail=False):\n        self.binary = options.pop('binary', True)\n        super(PythonItemExporter, self)._configure(options, dont_fail)\n        if self.binary:\n            warnings.warn(\n                \"PythonItemExporter will drop support for binary export in the future\",\n                ScrapyDeprecationWarning)\n\n    def serialize_field(self, field, name, value):\n        serializer = field.get('serializer', self._serialize_value)\n        return serializer(value)\n\n    def _serialize_value(self, value):\n        if isinstance(value, BaseItem):\n            return self.export_item(value)\n        if isinstance(value, dict):\n            return dict(self._serialize_dict(value))\n        if is_listlike(value):\n            return [self._serialize_value(v) for v in value]\n", "suffix": "\n    def _serialize_dict(self, value):\n        for key, val in six.iteritems(value):\n            key = to_bytes(key) if self.binary else key\n            yield key, self._serialize_value(val)\n\n    def export_item(self, item):\n        result = dict(self._get_serialized_fields(item))\n        if self.binary:\n            result = dict(self._serialize_dict(result))\n        return result\n", "long_prefix": ["        self.csv_writer.writerow(values)\n\n    def _build_row(self, values):\n        for s in values:\n            try:\n                yield to_native_str(s)\n            except TypeError:\n                yield to_native_str(repr(s))\n\n    def _write_headers_and_set_fields_to_export(self, item):\n        if self.include_headers_line:\n            if not self.fields_to_export:\n                if isinstance(item, dict):\n                    # for dicts try using fields of the first item\n                    self.fields_to_export = list(item.keys())\n                else:\n                    # use fields declared in Item\n                    self.fields_to_export = list(item.fields.keys())\n            row = list(self._build_row(self.fields_to_export))\n            self.csv_writer.writerow(row)\n\n\nclass PickleItemExporter(BaseItemExporter):\n\n    def __init__(self, file, protocol=2, **kwargs):\n        self._configure(kwargs)\n        self.file = file\n        self.protocol = protocol\n\n    def export_item(self, item):\n        d = dict(self._get_serialized_fields(item))\n        pickle.dump(d, self.file, self.protocol)\n\n\nclass MarshalItemExporter(BaseItemExporter):\n\n    def __init__(self, file, **kwargs):\n        self._configure(kwargs)\n        self.file = file\n\n    def export_item(self, item):\n        marshal.dump(dict(self._get_serialized_fields(item)), self.file)\n\n\nclass PprintItemExporter(BaseItemExporter):\n\n    def __init__(self, file, **kwargs):\n        self._configure(kwargs)\n        self.file = file\n\n    def export_item(self, item):\n        itemdict = dict(self._get_serialized_fields(item))\n        self.file.write(to_bytes(pprint.pformat(itemdict) + '\\n'))\n\n\nclass PythonItemExporter(BaseItemExporter):\n    \"\"\"The idea behind this exporter is to have a mechanism to serialize items\n    to built-in python types so any serialization library (like\n    json, msgpack, binc, etc) can be used on top of it. Its main goal is to\n    seamless support what BaseItemExporter does plus nested items.\n    \"\"\"\n    def _configure(self, options, dont_fail=False):\n        self.binary = options.pop('binary', True)\n        super(PythonItemExporter, self)._configure(options, dont_fail)\n        if self.binary:\n            warnings.warn(\n                \"PythonItemExporter will drop support for binary export in the future\",\n                ScrapyDeprecationWarning)\n\n    def serialize_field(self, field, name, value):\n        serializer = field.get('serializer', self._serialize_value)\n        return serializer(value)\n\n    def _serialize_value(self, value):\n        if isinstance(value, BaseItem):\n            return self.export_item(value)\n        if isinstance(value, dict):\n            return dict(self._serialize_dict(value))\n        if is_listlike(value):\n            return [self._serialize_value(v) for v in value]\n", "\n    def _serialize_dict(self, value):\n        for key, val in six.iteritems(value):\n            key = to_bytes(key) if self.binary else key\n            yield key, self._serialize_value(val)\n\n    def export_item(self, item):\n        result = dict(self._get_serialized_fields(item))\n        if self.binary:\n            result = dict(self._serialize_dict(result))\n        return result\n"]}