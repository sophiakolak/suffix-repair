{"prefix": "                        FR      GR      IT\n        1980-01-01  4.0405  1.7246  804.74\n        1980-02-01  4.0963  1.7482  810.01\n        1980-03-01  4.3149  1.8519  860.13\n\n        >>> df.pct_change()\n                          FR        GR        IT\n        1980-01-01       NaN       NaN       NaN\n        1980-02-01  0.013810  0.013684  0.006549\n        1980-03-01  0.053365  0.059318  0.061876\n\n        Percentage of change in GOOG and APPL stock volume. Shows computing\n        the percentage change between columns.\n\n        >>> df = pd.DataFrame({\n        ...     '2016': [1769950, 30586265],\n        ...     '2015': [1500923, 40912316],\n        ...     '2014': [1371819, 41403351]},\n        ...     index=['GOOG', 'APPL'])\n        >>> df\n                  2016      2015      2014\n        GOOG   1769950   1500923   1371819\n        APPL  30586265  40912316  41403351\n\n        >>> df.pct_change(axis='columns')\n              2016      2015      2014\n        GOOG   NaN -0.151997 -0.086016\n        APPL   NaN  0.337604  0.012002\n        \"\"\"\n\n    @Appender(_shared_docs[\"pct_change\"] % _shared_doc_kwargs)\n    def pct_change(self, periods=1, fill_method=\"pad\", limit=None, freq=None, **kwargs):\n        # TODO: Not sure if above is correct - need someone to confirm.\n        axis = self._get_axis_number(kwargs.pop(\"axis\", self._stat_axis_name))\n        if fill_method is None:\n            data = self\n        else:\n            data = self.fillna(method=fill_method, limit=limit, axis=axis)\n\n        rs = data.div(data.shift(periods=periods, freq=freq, axis=axis, **kwargs)) - 1\n", "suffix": "        return rs\n\n    def _agg_by_level(self, name, axis=0, level=0, skipna=True, **kwargs):\n        if axis is None:\n            raise ValueError(\"Must specify 'axis' when aggregating by level.\")\n        grouped = self.groupby(level=level, axis=axis, sort=False)\n        if hasattr(grouped, name) and skipna:\n            return getattr(grouped, name)(**kwargs)\n        axis = self._get_axis_number(axis)\n        method = getattr(type(self), name)\n        applyf = lambda x: method(x, axis=axis, skipna=skipna, **kwargs)\n        return grouped.aggregate(applyf)\n\n    @classmethod\n    def _add_numeric_operations(cls):\n        \"\"\"\n        Add the operations to the cls; evaluate the doc strings again\n        \"\"\"\n\n        axis_descr, name, name2 = _doc_parms(cls)\n\n        cls.any = _make_logical_function(\n            cls,\n            \"any\",\n            name,\n            name2,\n            axis_descr,\n            _any_desc,\n            nanops.nanany,\n            _any_see_also,\n            _any_examples,\n            empty_value=False,\n        )\n        cls.all = _make_logical_function(\n            cls,\n            \"all\",\n            name,\n            name2,\n            axis_descr,\n            _all_desc,\n", "long_prefix": ["        0         NaN\n        1    0.011111\n        2   -0.065934\n        dtype: float64\n\n        >>> s.pct_change(periods=2)\n        0         NaN\n        1         NaN\n        2   -0.055556\n        dtype: float64\n\n        See the percentage change in a Series where filling NAs with last\n        valid observation forward to next valid.\n\n        >>> s = pd.Series([90, 91, None, 85])\n        >>> s\n        0    90.0\n        1    91.0\n        2     NaN\n        3    85.0\n        dtype: float64\n\n        >>> s.pct_change(fill_method='ffill')\n        0         NaN\n        1    0.011111\n        2    0.000000\n        3   -0.065934\n        dtype: float64\n\n        **DataFrame**\n\n        Percentage change in French franc, Deutsche Mark, and Italian lira from\n        1980-01-01 to 1980-03-01.\n\n        >>> df = pd.DataFrame({\n        ...     'FR': [4.0405, 4.0963, 4.3149],\n        ...     'GR': [1.7246, 1.7482, 1.8519],\n        ...     'IT': [804.74, 810.01, 860.13]},\n        ...     index=['1980-01-01', '1980-02-01', '1980-03-01'])\n        >>> df\n                        FR      GR      IT\n        1980-01-01  4.0405  1.7246  804.74\n        1980-02-01  4.0963  1.7482  810.01\n        1980-03-01  4.3149  1.8519  860.13\n\n        >>> df.pct_change()\n                          FR        GR        IT\n        1980-01-01       NaN       NaN       NaN\n        1980-02-01  0.013810  0.013684  0.006549\n        1980-03-01  0.053365  0.059318  0.061876\n\n        Percentage of change in GOOG and APPL stock volume. Shows computing\n        the percentage change between columns.\n\n        >>> df = pd.DataFrame({\n        ...     '2016': [1769950, 30586265],\n        ...     '2015': [1500923, 40912316],\n        ...     '2014': [1371819, 41403351]},\n        ...     index=['GOOG', 'APPL'])\n        >>> df\n                  2016      2015      2014\n        GOOG   1769950   1500923   1371819\n        APPL  30586265  40912316  41403351\n\n        >>> df.pct_change(axis='columns')\n              2016      2015      2014\n        GOOG   NaN -0.151997 -0.086016\n        APPL   NaN  0.337604  0.012002\n        \"\"\"\n\n    @Appender(_shared_docs[\"pct_change\"] % _shared_doc_kwargs)\n    def pct_change(self, periods=1, fill_method=\"pad\", limit=None, freq=None, **kwargs):\n        # TODO: Not sure if above is correct - need someone to confirm.\n        axis = self._get_axis_number(kwargs.pop(\"axis\", self._stat_axis_name))\n        if fill_method is None:\n            data = self\n        else:\n            data = self.fillna(method=fill_method, limit=limit, axis=axis)\n\n        rs = data.div(data.shift(periods=periods, freq=freq, axis=axis, **kwargs)) - 1\n", "        return rs\n\n    def _agg_by_level(self, name, axis=0, level=0, skipna=True, **kwargs):\n        if axis is None:\n            raise ValueError(\"Must specify 'axis' when aggregating by level.\")\n        grouped = self.groupby(level=level, axis=axis, sort=False)\n        if hasattr(grouped, name) and skipna:\n            return getattr(grouped, name)(**kwargs)\n        axis = self._get_axis_number(axis)\n        method = getattr(type(self), name)\n        applyf = lambda x: method(x, axis=axis, skipna=skipna, **kwargs)\n        return grouped.aggregate(applyf)\n\n    @classmethod\n    def _add_numeric_operations(cls):\n        \"\"\"\n        Add the operations to the cls; evaluate the doc strings again\n        \"\"\"\n\n        axis_descr, name, name2 = _doc_parms(cls)\n\n        cls.any = _make_logical_function(\n            cls,\n            \"any\",\n            name,\n            name2,\n            axis_descr,\n            _any_desc,\n            nanops.nanany,\n            _any_see_also,\n            _any_examples,\n            empty_value=False,\n        )\n        cls.all = _make_logical_function(\n            cls,\n            \"all\",\n            name,\n            name2,\n            axis_descr,\n            _all_desc,\n"]}