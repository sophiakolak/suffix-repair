{"prefix": "    return signature\n\n\ndef clean_module_name(name):\n    if name.startswith('keras_applications'):\n        name = name.replace('keras_applications', 'keras.applications')\n    if name.startswith('keras_preprocessing'):\n        name = name.replace('keras_preprocessing', 'keras.preprocessing')\n    assert name[:6] == 'keras.', 'Invalid module name: %s' % name\n    return name\n\n\ndef class_to_source_link(cls):\n    module_name = clean_module_name(cls.__module__)\n    path = module_name.replace('.', '/')\n    path += '.py'\n    line = inspect.getsourcelines(cls)[-1]\n    link = ('https://github.com/keras-team/'\n            'keras/blob/master/' + path + '#L' + str(line))\n    return '[[source]](' + link + ')'\n\n\ndef code_snippet(snippet):\n    result = '```python\\n'\n    result += snippet + '\\n'\n    result += '```\\n'\n    return result\n\n\ndef count_leading_spaces(s):\n    ws = re.search(r'\\S', s)\n    if ws:\n        return ws.start()\n    else:\n        return 0\n\n\ndef process_list_block(docstring, starting_point, section_end,\n                       leading_spaces, marker):\n    ending_point = docstring.find('\\n\\n', starting_point)\n", "suffix": "    # Place marker for later reinjection.\n    docstring_slice = docstring[starting_point:section_end].replace(block, marker)\n    docstring = (docstring[:starting_point]\n                 + docstring_slice\n                 + docstring[section_end:])\n    lines = block.split('\\n')\n    # Remove the computed number of leading white spaces from each line.\n    lines = [re.sub('^' + ' ' * leading_spaces, '', line) for line in lines]\n    # Usually lines have at least 4 additional leading spaces.\n    # These have to be removed, but first the list roots have to be detected.\n    top_level_regex = r'^    ([^\\s\\\\\\(]+):(.*)'\n    top_level_replacement = r'- __\\1__:\\2'\n    lines = [re.sub(top_level_regex, top_level_replacement, line) for line in lines]\n    # All the other lines get simply the 4 leading space (if present) removed\n    lines = [re.sub(r'^    ', '', line) for line in lines]\n    # Fix text lines after lists\n    indent = 0\n    text_block = False\n    for i in range(len(lines)):\n        line = lines[i]\n        spaces = re.search(r'\\S', line)\n        if spaces:\n            # If it is a list element\n            if line[spaces.start()] == '-':\n                indent = spaces.start() + 1\n                if text_block:\n                    text_block = False\n                    lines[i] = '\\n' + line\n            elif spaces.start() < indent:\n                text_block = True\n                indent = spaces.start()\n                lines[i] = '\\n' + line\n        else:\n            text_block = False\n            indent = 0\n    block = '\\n'.join(lines)\n    return docstring, block\n\n\ndef process_docstring(docstring):\n", "long_prefix": ["    else:\n        kwargs = []\n    st = '%s.%s(' % (clean_module_name(function.__module__), function.__name__)\n\n    for a in args:\n        st += str(a) + ', '\n    for a, v in kwargs:\n        if isinstance(v, str):\n            v = '\\'' + v + '\\''\n        st += str(a) + '=' + str(v) + ', '\n    if kwargs or args:\n        signature = st[:-2] + ')'\n    else:\n        signature = st + ')'\n    return post_process_signature(signature)\n\n\ndef get_class_signature(cls):\n    try:\n        class_signature = get_function_signature(cls.__init__)\n        class_signature = class_signature.replace('__init__', cls.__name__)\n    except (TypeError, AttributeError):\n        # in case the class inherits from object and does not\n        # define __init__\n        class_signature = \"{clean_module_name}.{cls_name}()\".format(\n            clean_module_name=clean_module_name(cls.__module__),\n            cls_name=cls.__name__\n        )\n    return post_process_signature(class_signature)\n\n\ndef post_process_signature(signature):\n    parts = re.split(r'\\.(?!\\d)', signature)\n    if len(parts) >= 4:\n        if parts[1] == 'layers':\n            signature = 'keras.layers.' + '.'.join(parts[3:])\n        if parts[1] == 'utils':\n            signature = 'keras.utils.' + '.'.join(parts[3:])\n        if parts[1] == 'backend':\n            signature = 'keras.backend.' + '.'.join(parts[3:])\n    return signature\n\n\ndef clean_module_name(name):\n    if name.startswith('keras_applications'):\n        name = name.replace('keras_applications', 'keras.applications')\n    if name.startswith('keras_preprocessing'):\n        name = name.replace('keras_preprocessing', 'keras.preprocessing')\n    assert name[:6] == 'keras.', 'Invalid module name: %s' % name\n    return name\n\n\ndef class_to_source_link(cls):\n    module_name = clean_module_name(cls.__module__)\n    path = module_name.replace('.', '/')\n    path += '.py'\n    line = inspect.getsourcelines(cls)[-1]\n    link = ('https://github.com/keras-team/'\n            'keras/blob/master/' + path + '#L' + str(line))\n    return '[[source]](' + link + ')'\n\n\ndef code_snippet(snippet):\n    result = '```python\\n'\n    result += snippet + '\\n'\n    result += '```\\n'\n    return result\n\n\ndef count_leading_spaces(s):\n    ws = re.search(r'\\S', s)\n    if ws:\n        return ws.start()\n    else:\n        return 0\n\n\ndef process_list_block(docstring, starting_point, section_end,\n                       leading_spaces, marker):\n    ending_point = docstring.find('\\n\\n', starting_point)\n", "    # Place marker for later reinjection.\n    docstring_slice = docstring[starting_point:section_end].replace(block, marker)\n    docstring = (docstring[:starting_point]\n                 + docstring_slice\n                 + docstring[section_end:])\n    lines = block.split('\\n')\n    # Remove the computed number of leading white spaces from each line.\n    lines = [re.sub('^' + ' ' * leading_spaces, '', line) for line in lines]\n    # Usually lines have at least 4 additional leading spaces.\n    # These have to be removed, but first the list roots have to be detected.\n    top_level_regex = r'^    ([^\\s\\\\\\(]+):(.*)'\n    top_level_replacement = r'- __\\1__:\\2'\n    lines = [re.sub(top_level_regex, top_level_replacement, line) for line in lines]\n    # All the other lines get simply the 4 leading space (if present) removed\n    lines = [re.sub(r'^    ', '', line) for line in lines]\n    # Fix text lines after lists\n    indent = 0\n    text_block = False\n    for i in range(len(lines)):\n        line = lines[i]\n        spaces = re.search(r'\\S', line)\n        if spaces:\n            # If it is a list element\n            if line[spaces.start()] == '-':\n                indent = spaces.start() + 1\n                if text_block:\n                    text_block = False\n                    lines[i] = '\\n' + line\n            elif spaces.start() < indent:\n                text_block = True\n                indent = spaces.start()\n                lines[i] = '\\n' + line\n        else:\n            text_block = False\n            indent = 0\n    block = '\\n'.join(lines)\n    return docstring, block\n\n\ndef process_docstring(docstring):\n"]}