{"prefix": "        self.priority = priority\n\n        if callback is not None and not callable(callback):\n            raise TypeError('callback must be a callable, got %s' % type(callback).__name__)\n        if errback is not None and not callable(errback):\n            raise TypeError('errback must be a callable, got %s' % type(errback).__name__)\n        assert callback or not errback, \"Cannot use errback without a callback\"\n        self.callback = callback\n        self.errback = errback\n\n        self.cookies = cookies or {}\n        self.headers = Headers(headers or {}, encoding=encoding)\n        self.dont_filter = dont_filter\n\n        self._meta = dict(meta) if meta else None\n        self._cb_kwargs = dict(cb_kwargs) if cb_kwargs else None\n        self.flags = [] if flags is None else list(flags)\n\n    @property\n    def cb_kwargs(self):\n        if self._cb_kwargs is None:\n            self._cb_kwargs = {}\n        return self._cb_kwargs\n\n    @property\n    def meta(self):\n        if self._meta is None:\n            self._meta = {}\n        return self._meta\n\n    def _get_url(self):\n        return self._url\n\n    def _set_url(self, url):\n        if not isinstance(url, six.string_types):\n            raise TypeError('Request url must be str or unicode, got %s:' % type(url).__name__)\n\n        s = safe_url_string(url, self.encoding)\n        self._url = escape_ajax(s)\n\n", "suffix": "            raise ValueError('Missing scheme in request url: %s' % self._url)\n\n    url = property(_get_url, obsolete_setter(_set_url, 'url'))\n\n    def _get_body(self):\n        return self._body\n\n    def _set_body(self, body):\n        if body is None:\n            self._body = b''\n        else:\n            self._body = to_bytes(body, self.encoding)\n\n    body = property(_get_body, obsolete_setter(_set_body, 'body'))\n\n    @property\n    def encoding(self):\n        return self._encoding\n\n    def __str__(self):\n        return \"<%s %s>\" % (self.method, self.url)\n\n    __repr__ = __str__\n\n    def copy(self):\n        \"\"\"Return a copy of this Request\"\"\"\n        return self.replace()\n\n    def replace(self, *args, **kwargs):\n        \"\"\"Create a new Request with the same attributes except for those\n        given new values.\n        \"\"\"\n        for x in ['url', 'method', 'headers', 'body', 'cookies', 'meta', 'flags',\n                  'encoding', 'priority', 'dont_filter', 'callback', 'errback', 'cb_kwargs']:\n            kwargs.setdefault(x, getattr(self, x))\n        cls = kwargs.pop('cls', self.__class__)\n        return cls(*args, **kwargs)\n\n    @classmethod\n    def from_curl(cls, curl_command, ignore_unknown_options=True, **kwargs):\n", "long_prefix": ["\"\"\"\nThis module implements the Request class which is used to represent HTTP\nrequests in Scrapy.\n\nSee documentation in docs/topics/request-response.rst\n\"\"\"\nimport six\nfrom w3lib.url import safe_url_string\n\nfrom scrapy.http.headers import Headers\nfrom scrapy.utils.python import to_bytes\nfrom scrapy.utils.trackref import object_ref\nfrom scrapy.utils.url import escape_ajax\nfrom scrapy.http.common import obsolete_setter\nfrom scrapy.utils.curl import curl_to_request_kwargs\n\n\nclass Request(object_ref):\n\n    def __init__(self, url, callback=None, method='GET', headers=None, body=None,\n                 cookies=None, meta=None, encoding='utf-8', priority=0,\n                 dont_filter=False, errback=None, flags=None, cb_kwargs=None):\n\n        self._encoding = encoding  # this one has to be set first\n        self.method = str(method).upper()\n        self._set_url(url)\n        self._set_body(body)\n        assert isinstance(priority, int), \"Request priority not an integer: %r\" % priority\n        self.priority = priority\n\n        if callback is not None and not callable(callback):\n            raise TypeError('callback must be a callable, got %s' % type(callback).__name__)\n        if errback is not None and not callable(errback):\n            raise TypeError('errback must be a callable, got %s' % type(errback).__name__)\n        assert callback or not errback, \"Cannot use errback without a callback\"\n        self.callback = callback\n        self.errback = errback\n\n        self.cookies = cookies or {}\n        self.headers = Headers(headers or {}, encoding=encoding)\n        self.dont_filter = dont_filter\n\n        self._meta = dict(meta) if meta else None\n        self._cb_kwargs = dict(cb_kwargs) if cb_kwargs else None\n        self.flags = [] if flags is None else list(flags)\n\n    @property\n    def cb_kwargs(self):\n        if self._cb_kwargs is None:\n            self._cb_kwargs = {}\n        return self._cb_kwargs\n\n    @property\n    def meta(self):\n        if self._meta is None:\n            self._meta = {}\n        return self._meta\n\n    def _get_url(self):\n        return self._url\n\n    def _set_url(self, url):\n        if not isinstance(url, six.string_types):\n            raise TypeError('Request url must be str or unicode, got %s:' % type(url).__name__)\n\n        s = safe_url_string(url, self.encoding)\n        self._url = escape_ajax(s)\n\n", "            raise ValueError('Missing scheme in request url: %s' % self._url)\n\n    url = property(_get_url, obsolete_setter(_set_url, 'url'))\n\n    def _get_body(self):\n        return self._body\n\n    def _set_body(self, body):\n        if body is None:\n            self._body = b''\n        else:\n            self._body = to_bytes(body, self.encoding)\n\n    body = property(_get_body, obsolete_setter(_set_body, 'body'))\n\n    @property\n    def encoding(self):\n        return self._encoding\n\n    def __str__(self):\n        return \"<%s %s>\" % (self.method, self.url)\n\n    __repr__ = __str__\n\n    def copy(self):\n        \"\"\"Return a copy of this Request\"\"\"\n        return self.replace()\n\n    def replace(self, *args, **kwargs):\n        \"\"\"Create a new Request with the same attributes except for those\n        given new values.\n        \"\"\"\n        for x in ['url', 'method', 'headers', 'body', 'cookies', 'meta', 'flags',\n                  'encoding', 'priority', 'dont_filter', 'callback', 'errback', 'cb_kwargs']:\n            kwargs.setdefault(x, getattr(self, x))\n        cls = kwargs.pop('cls', self.__class__)\n        return cls(*args, **kwargs)\n\n    @classmethod\n    def from_curl(cls, curl_command, ignore_unknown_options=True, **kwargs):\n"]}