{"prefix": "    title_bytes = title.encode('utf-8')\n    buf = ctypes.create_string_buffer(len(title_bytes))\n    buf.value = title_bytes\n    try:\n        libc.prctl(15, buf, 0, 0, 0)\n    except AttributeError:\n        return  # Strange libc, just skip this\n\n\ndef remove_start(s, start):\n    return s[len(start):] if s is not None and s.startswith(start) else s\n\n\ndef remove_end(s, end):\n    return s[:-len(end)] if s is not None and s.endswith(end) else s\n\n\ndef remove_quotes(s):\n    if s is None or len(s) < 2:\n        return s\n    for quote in ('\"', \"'\", ):\n        if s[0] == quote and s[-1] == quote:\n            return s[1:-1]\n    return s\n\n\ndef url_basename(url):\n    path = compat_urlparse.urlparse(url).path\n    return path.strip('/').split('/')[-1]\n\n\ndef base_url(url):\n    return re.match(r'https?://[^?#&]+/', url).group()\n\n\ndef urljoin(base, path):\n    if isinstance(path, bytes):\n        path = path.decode('utf-8')\n    if not isinstance(path, compat_str) or not path:\n        return None\n", "suffix": "        return path\n    if isinstance(base, bytes):\n        base = base.decode('utf-8')\n    if not isinstance(base, compat_str) or not re.match(\n            r'^(?:https?:)?//', base):\n        return None\n    return compat_urlparse.urljoin(base, path)\n\n\nclass HEADRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'HEAD'\n\n\nclass PUTRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'PUT'\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr:\n        if v is not None:\n            v = getattr(v, get_attr, None)\n    if v == '':\n        v = None\n    if v is None:\n        return default\n    try:\n        return int(v) * invscale // scale\n    except ValueError:\n        return default\n\n\ndef str_or_none(v, default=None):\n    return default if v is None else compat_str(v)\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if int_str is None:\n", "long_prefix": ["        return month_names.index(name) + 1\n    except ValueError:\n        return None\n\n\ndef month_by_abbreviation(abbrev):\n    \"\"\" Return the number of a month by (locale-independently) English\n        abbreviations \"\"\"\n\n    try:\n        return [s[:3] for s in ENGLISH_MONTH_NAMES].index(abbrev) + 1\n    except ValueError:\n        return None\n\n\ndef fix_xml_ampersands(xml_str):\n    \"\"\"Replace all the '&' by '&amp;' in XML\"\"\"\n    return re.sub(\n        r'&(?!amp;|lt;|gt;|apos;|quot;|#x[0-9a-fA-F]{,4};|#[0-9]{,4};)',\n        '&amp;',\n        xml_str)\n\n\ndef setproctitle(title):\n    assert isinstance(title, compat_str)\n\n    # ctypes in Jython is not complete\n    # http://bugs.jython.org/issue2148\n    if sys.platform.startswith('java'):\n        return\n\n    try:\n        libc = ctypes.cdll.LoadLibrary('libc.so.6')\n    except OSError:\n        return\n    except TypeError:\n        # LoadLibrary in Windows Python 2.7.13 only expects\n        # a bytestring, but since unicode_literals turns\n        # every string into a unicode string, it fails.\n        return\n    title_bytes = title.encode('utf-8')\n    buf = ctypes.create_string_buffer(len(title_bytes))\n    buf.value = title_bytes\n    try:\n        libc.prctl(15, buf, 0, 0, 0)\n    except AttributeError:\n        return  # Strange libc, just skip this\n\n\ndef remove_start(s, start):\n    return s[len(start):] if s is not None and s.startswith(start) else s\n\n\ndef remove_end(s, end):\n    return s[:-len(end)] if s is not None and s.endswith(end) else s\n\n\ndef remove_quotes(s):\n    if s is None or len(s) < 2:\n        return s\n    for quote in ('\"', \"'\", ):\n        if s[0] == quote and s[-1] == quote:\n            return s[1:-1]\n    return s\n\n\ndef url_basename(url):\n    path = compat_urlparse.urlparse(url).path\n    return path.strip('/').split('/')[-1]\n\n\ndef base_url(url):\n    return re.match(r'https?://[^?#&]+/', url).group()\n\n\ndef urljoin(base, path):\n    if isinstance(path, bytes):\n        path = path.decode('utf-8')\n    if not isinstance(path, compat_str) or not path:\n        return None\n", "        return path\n    if isinstance(base, bytes):\n        base = base.decode('utf-8')\n    if not isinstance(base, compat_str) or not re.match(\n            r'^(?:https?:)?//', base):\n        return None\n    return compat_urlparse.urljoin(base, path)\n\n\nclass HEADRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'HEAD'\n\n\nclass PUTRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'PUT'\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr:\n        if v is not None:\n            v = getattr(v, get_attr, None)\n    if v == '':\n        v = None\n    if v is None:\n        return default\n    try:\n        return int(v) * invscale // scale\n    except ValueError:\n        return default\n\n\ndef str_or_none(v, default=None):\n    return default if v is None else compat_str(v)\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if int_str is None:\n"]}