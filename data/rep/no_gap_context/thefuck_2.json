{"prefix": "\n    \"\"\"\n    def _default_settings(fn, command):\n        for k, w in params.items():\n            settings.setdefault(k, w)\n        return fn(command)\n    return decorator(_default_settings)\n\n\ndef get_closest(word, possibilities, cutoff=0.6, fallback_to_first=True):\n    \"\"\"Returns closest match or just first from possibilities.\"\"\"\n    possibilities = list(possibilities)\n    try:\n        return difflib_get_close_matches(word, possibilities, 1, cutoff)[0]\n    except IndexError:\n        if fallback_to_first:\n            return possibilities[0]\n\n\ndef get_close_matches(word, possibilities, n=None, cutoff=0.6):\n    \"\"\"Overrides `difflib.get_close_match` to controle argument `n`.\"\"\"\n    if n is None:\n        n = settings.num_close_matches\n    return difflib_get_close_matches(word, possibilities, n, cutoff)\n\n\n@memoize\ndef get_all_executables():\n    from thefuck.shells import shell\n\n    def _safe(fn, fallback):\n        try:\n            return fn()\n        except OSError:\n            return fallback\n\n    tf_alias = get_alias()\n    tf_entry_points = ['thefuck', 'fuck']\n\n    bins = [exe.name.decode('utf8') if six.PY2 else exe.name\n", "suffix": "            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)\n            and exe.name not in tf_entry_points]\n    aliases = [alias.decode('utf8') if six.PY2 else alias\n               for alias in shell.get_aliases() if alias != tf_alias]\n\n    return bins + aliases\n\n\ndef replace_argument(script, from_, to):\n    \"\"\"Replaces command line argument.\"\"\"\n    replaced_in_the_end = re.sub(u' {}$'.format(re.escape(from_)), u' {}'.format(to),\n                                 script, count=1)\n    if replaced_in_the_end != script:\n        return replaced_in_the_end\n    else:\n        return script.replace(\n            u' {} '.format(from_), u' {} '.format(to), 1)\n\n\n@decorator\ndef eager(fn, *args, **kwargs):\n    return list(fn(*args, **kwargs))\n\n\n@eager\ndef get_all_matched_commands(stderr, separator='Did you mean'):\n    if not isinstance(separator, list):\n        separator = [separator]\n    should_yield = False\n    for line in stderr.split('\\n'):\n        for sep in separator:\n            if sep in line:\n                should_yield = True\n                break\n        else:\n            if should_yield and line:\n                yield line.strip()\n\n\n", "long_prefix": ["\n    return wrapper\n\n\nmemoize.disabled = False\n\n\n@memoize\ndef which(program):\n    \"\"\"Returns `program` path or `None`.\"\"\"\n    try:\n        from shutil import which\n\n        return which(program)\n    except ImportError:\n        def is_exe(fpath):\n            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n        fpath, fname = os.path.split(program)\n        if fpath:\n            if is_exe(program):\n                return program\n        else:\n            for path in os.environ[\"PATH\"].split(os.pathsep):\n                path = path.strip('\"')\n                exe_file = os.path.join(path, program)\n                if is_exe(exe_file):\n                    return exe_file\n\n        return None\n\n\ndef default_settings(params):\n    \"\"\"Adds default values to settings if it not presented.\n\n    Usage:\n\n        @default_settings({'apt': '/usr/bin/apt'})\n        def match(command):\n            print(settings.apt)\n\n    \"\"\"\n    def _default_settings(fn, command):\n        for k, w in params.items():\n            settings.setdefault(k, w)\n        return fn(command)\n    return decorator(_default_settings)\n\n\ndef get_closest(word, possibilities, cutoff=0.6, fallback_to_first=True):\n    \"\"\"Returns closest match or just first from possibilities.\"\"\"\n    possibilities = list(possibilities)\n    try:\n        return difflib_get_close_matches(word, possibilities, 1, cutoff)[0]\n    except IndexError:\n        if fallback_to_first:\n            return possibilities[0]\n\n\ndef get_close_matches(word, possibilities, n=None, cutoff=0.6):\n    \"\"\"Overrides `difflib.get_close_match` to controle argument `n`.\"\"\"\n    if n is None:\n        n = settings.num_close_matches\n    return difflib_get_close_matches(word, possibilities, n, cutoff)\n\n\n@memoize\ndef get_all_executables():\n    from thefuck.shells import shell\n\n    def _safe(fn, fallback):\n        try:\n            return fn()\n        except OSError:\n            return fallback\n\n    tf_alias = get_alias()\n    tf_entry_points = ['thefuck', 'fuck']\n\n    bins = [exe.name.decode('utf8') if six.PY2 else exe.name\n", "            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)\n            and exe.name not in tf_entry_points]\n    aliases = [alias.decode('utf8') if six.PY2 else alias\n               for alias in shell.get_aliases() if alias != tf_alias]\n\n    return bins + aliases\n\n\ndef replace_argument(script, from_, to):\n    \"\"\"Replaces command line argument.\"\"\"\n    replaced_in_the_end = re.sub(u' {}$'.format(re.escape(from_)), u' {}'.format(to),\n                                 script, count=1)\n    if replaced_in_the_end != script:\n        return replaced_in_the_end\n    else:\n        return script.replace(\n            u' {} '.format(from_), u' {} '.format(to), 1)\n\n\n@decorator\ndef eager(fn, *args, **kwargs):\n    return list(fn(*args, **kwargs))\n\n\n@eager\ndef get_all_matched_commands(stderr, separator='Did you mean'):\n    if not isinstance(separator, list):\n        separator = [separator]\n    should_yield = False\n    for line in stderr.split('\\n'):\n        for sep in separator:\n            if sep in line:\n                should_yield = True\n                break\n        else:\n            if should_yield and line:\n                yield line.strip()\n\n\n"]}