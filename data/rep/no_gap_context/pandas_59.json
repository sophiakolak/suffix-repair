{"prefix": "    The below example shows a similar rolling calculation on a\n    DataFrame using the pairwise option.\n\n    >>> matrix = np.array([[51., 35.], [49., 30.], [47., 32.],\\\n    [46., 31.], [50., 36.]])\n    >>> print(np.corrcoef(matrix[:-1,0], matrix[:-1,1]).round(7))\n    [[1.         0.6263001]\n     [0.6263001  1.       ]]\n    >>> print(np.corrcoef(matrix[1:,0], matrix[1:,1]).round(7))\n    [[1.         0.5553681]\n     [0.5553681  1.        ]]\n    >>> df = pd.DataFrame(matrix, columns=['X','Y'])\n    >>> df\n          X     Y\n    0  51.0  35.0\n    1  49.0  30.0\n    2  47.0  32.0\n    3  46.0  31.0\n    4  50.0  36.0\n    >>> df.rolling(4).corr(pairwise=True)\n                X         Y\n    0 X       NaN       NaN\n      Y       NaN       NaN\n    1 X       NaN       NaN\n      Y       NaN       NaN\n    2 X       NaN       NaN\n      Y       NaN       NaN\n    3 X  1.000000  0.626300\n      Y  0.626300  1.000000\n    4 X  1.000000  0.555368\n      Y  0.555368  1.000000\n    \"\"\"\n    )\n\n    def corr(self, other=None, pairwise=None, **kwargs):\n        if other is None:\n            other = self._selected_obj\n            # only default unset\n            pairwise = True if pairwise is None else pairwise\n        other = self._shallow_copy(other)\n", "suffix": "\n        def _get_corr(a, b):\n            a = a.rolling(\n                window=window, min_periods=self.min_periods, center=self.center\n            )\n            b = b.rolling(\n                window=window, min_periods=self.min_periods, center=self.center\n            )\n\n            return a.cov(b, **kwargs) / (a.std(**kwargs) * b.std(**kwargs))\n\n        return _flex_binary_moment(\n            self._selected_obj, other._selected_obj, _get_corr, pairwise=bool(pairwise)\n        )\n\n\nclass Rolling(_Rolling_and_Expanding):\n    @cache_readonly\n    def is_datetimelike(self) -> bool:\n        return isinstance(\n            self._on, (ABCDatetimeIndex, ABCTimedeltaIndex, ABCPeriodIndex)\n        )\n\n    @cache_readonly\n    def _on(self) -> Index:\n        if self.on is None:\n            if self.axis == 0:\n                return self.obj.index\n            else:\n                # i.e. self.axis == 1\n                return self.obj.columns\n        elif isinstance(self.on, Index):\n            return self.on\n        elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\n            return Index(self.obj[self.on])\n        else:\n            raise ValueError(\n                f\"invalid on specified as {self.on}, \"\n                \"must be a column (of DataFrame), an Index or None\"\n            )\n", "long_prefix": ["    When `other` is not specified, the output will be self correlation (e.g.\n    all 1's), except for :class:`~pandas.DataFrame` inputs with `pairwise`\n    set to `True`.\n\n    Function will return ``NaN`` for correlations of equal valued sequences;\n    this is the result of a 0/0 division error.\n\n    When `pairwise` is set to `False`, only matching columns between `self` and\n    `other` will be used.\n\n    When `pairwise` is set to `True`, the output will be a MultiIndex DataFrame\n    with the original index on the first level, and the `other` DataFrame\n    columns on the second level.\n\n    In the case of missing elements, only complete pairwise observations\n    will be used.\n\n    Examples\n    --------\n    The below example shows a rolling calculation with a window size of\n    four matching the equivalent function call using :meth:`numpy.corrcoef`.\n\n    >>> v1 = [3, 3, 3, 5, 8]\n    >>> v2 = [3, 4, 4, 4, 8]\n    >>> # numpy returns a 2X2 array, the correlation coefficient\n    >>> # is the number at entry [0][1]\n    >>> print(f\"{np.corrcoef(v1[:-1], v2[:-1])[0][1]:.6f}\")\n    0.333333\n    >>> print(f\"{np.corrcoef(v1[1:], v2[1:])[0][1]:.6f}\")\n    0.916949\n    >>> s1 = pd.Series(v1)\n    >>> s2 = pd.Series(v2)\n    >>> s1.rolling(4).corr(s2)\n    0         NaN\n    1         NaN\n    2         NaN\n    3    0.333333\n    4    0.916949\n    dtype: float64\n\n    The below example shows a similar rolling calculation on a\n    DataFrame using the pairwise option.\n\n    >>> matrix = np.array([[51., 35.], [49., 30.], [47., 32.],\\\n    [46., 31.], [50., 36.]])\n    >>> print(np.corrcoef(matrix[:-1,0], matrix[:-1,1]).round(7))\n    [[1.         0.6263001]\n     [0.6263001  1.       ]]\n    >>> print(np.corrcoef(matrix[1:,0], matrix[1:,1]).round(7))\n    [[1.         0.5553681]\n     [0.5553681  1.        ]]\n    >>> df = pd.DataFrame(matrix, columns=['X','Y'])\n    >>> df\n          X     Y\n    0  51.0  35.0\n    1  49.0  30.0\n    2  47.0  32.0\n    3  46.0  31.0\n    4  50.0  36.0\n    >>> df.rolling(4).corr(pairwise=True)\n                X         Y\n    0 X       NaN       NaN\n      Y       NaN       NaN\n    1 X       NaN       NaN\n      Y       NaN       NaN\n    2 X       NaN       NaN\n      Y       NaN       NaN\n    3 X  1.000000  0.626300\n      Y  0.626300  1.000000\n    4 X  1.000000  0.555368\n      Y  0.555368  1.000000\n    \"\"\"\n    )\n\n    def corr(self, other=None, pairwise=None, **kwargs):\n        if other is None:\n            other = self._selected_obj\n            # only default unset\n            pairwise = True if pairwise is None else pairwise\n        other = self._shallow_copy(other)\n", "\n        def _get_corr(a, b):\n            a = a.rolling(\n                window=window, min_periods=self.min_periods, center=self.center\n            )\n            b = b.rolling(\n                window=window, min_periods=self.min_periods, center=self.center\n            )\n\n            return a.cov(b, **kwargs) / (a.std(**kwargs) * b.std(**kwargs))\n\n        return _flex_binary_moment(\n            self._selected_obj, other._selected_obj, _get_corr, pairwise=bool(pairwise)\n        )\n\n\nclass Rolling(_Rolling_and_Expanding):\n    @cache_readonly\n    def is_datetimelike(self) -> bool:\n        return isinstance(\n            self._on, (ABCDatetimeIndex, ABCTimedeltaIndex, ABCPeriodIndex)\n        )\n\n    @cache_readonly\n    def _on(self) -> Index:\n        if self.on is None:\n            if self.axis == 0:\n                return self.obj.index\n            else:\n                # i.e. self.axis == 1\n                return self.obj.columns\n        elif isinstance(self.on, Index):\n            return self.on\n        elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\n            return Index(self.obj[self.on])\n        else:\n            raise ValueError(\n                f\"invalid on specified as {self.on}, \"\n                \"must be a column (of DataFrame), an Index or None\"\n            )\n"]}