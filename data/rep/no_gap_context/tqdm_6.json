{"prefix": "        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n        self.postfix = None\n        if postfix:\n            try:\n                self.set_postfix(refresh=False, **postfix)\n            except TypeError:\n                self.postfix = postfix\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:  # mark fixed positions as negative\n            self.pos = -position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            with self._lock:\n                if self.pos:\n                    self.moveto(abs(self.pos))\n                self.sp(self.__repr__(elapsed=0))\n                if self.pos:\n                    self.moveto(-abs(self.pos))\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t\n\n    def __len__(self):\n        return self.total if self.iterable is None else \\\n            (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n             else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n", "suffix": "\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self, elapsed=None):\n        return self.format_meter(\n            self.n, self.total,\n            elapsed if elapsed is not None else self._time() - self.start_t,\n            self.dynamic_ncols(self.fp) if self.dynamic_ncols else self.ncols,\n            self.desc, self.ascii, self.unit,\n            self.unit_scale, 1 / self.avg_time if self.avg_time else None,\n            self.bar_format, self.postfix, self.unit_divisor)\n\n    def __lt__(self, other):\n        return abs(self.pos) < abs(other.pos)\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        return abs(self.pos) == abs(other.pos)\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n", "long_prefix": ["            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc or ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n        self.postfix = None\n        if postfix:\n            try:\n                self.set_postfix(refresh=False, **postfix)\n            except TypeError:\n                self.postfix = postfix\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:  # mark fixed positions as negative\n            self.pos = -position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            with self._lock:\n                if self.pos:\n                    self.moveto(abs(self.pos))\n                self.sp(self.__repr__(elapsed=0))\n                if self.pos:\n                    self.moveto(-abs(self.pos))\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t\n\n    def __len__(self):\n        return self.total if self.iterable is None else \\\n            (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n             else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n", "\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n        return False\n\n    def __del__(self):\n        self.close()\n\n    def __repr__(self, elapsed=None):\n        return self.format_meter(\n            self.n, self.total,\n            elapsed if elapsed is not None else self._time() - self.start_t,\n            self.dynamic_ncols(self.fp) if self.dynamic_ncols else self.ncols,\n            self.desc, self.ascii, self.unit,\n            self.unit_scale, 1 / self.avg_time if self.avg_time else None,\n            self.bar_format, self.postfix, self.unit_divisor)\n\n    def __lt__(self, other):\n        return abs(self.pos) < abs(other.pos)\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        return abs(self.pos) == abs(other.pos)\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __gt__(self, other):\n        return not (self <= other)\n\n    def __ge__(self, other):\n        return not (self < other)\n\n    def __hash__(self):\n        return id(self)\n"]}