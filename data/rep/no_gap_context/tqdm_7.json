{"prefix": "            tmp = fin.read(buf_size)\n\n            # flush at EOF\n            if not tmp:\n                getattr(fout, 'flush', lambda: None)()  # pragma: no cover\n                return\n\n            fp_write(tmp)\n            callback(len(tmp))\n        # return\n\n    buf = ''\n    # n = 0\n    while True:\n        tmp = fin.read(buf_size)\n\n        # flush at EOF\n        if not tmp:\n            if buf:\n                fp_write(buf)\n                callback(1 + buf.count(delim))  # n += 1 + buf.count(delim)\n            getattr(fout, 'flush', lambda: None)()  # pragma: no cover\n            return  # n\n\n        while True:\n            try:\n                i = tmp.index(delim)\n            except ValueError:\n                buf += tmp\n                break\n            else:\n                fp_write(buf + tmp[:i + len(delim)])\n                callback(1)  # n += 1\n                buf = ''\n                tmp = tmp[i + len(delim):]\n\n\n# ((opt, type), ... )\nRE_OPTS = re.compile(r'\\n {8}(\\S+)\\s{2,}:\\s*([^,]+)')\n# better split method assuming no positional args\n", "suffix": "\n# TODO: add custom support for some of the following?\nUNSUPPORTED_OPTS = ('iterable', 'gui', 'out', 'file')\n\n# The 8 leading spaces are required for consistency\nCLI_EXTRA_DOC = r\"\"\"\n        Extra CLI Options\n        -----------------\n        name  : type, optional\n             TODO: find out why this is needed.\n        delim  : chr, optional\n            Delimiting character [default: '\\n']. Use '\\0' for null.\n            N.B.: on Windows systems, Python converts '\\n' to '\\r\\n'.\n        buf_size  : int, optional\n            String buffer size in bytes [default: 256]\n            used when `delim` is specified.\n        bytes  : bool, optional\n            If true, will count bytes, ignore `delim`, and default\n            `unit_scale` to True, `unit_divisor` to 1024, and `unit` to 'B'.\n        log  : str, optional\n            CRITICAL|FATAL|ERROR|WARN(ING)|[default: 'INFO']|DEBUG|NOTSET.\n\"\"\"\n\n\ndef main(fp=sys.stderr):\n    \"\"\"\n    Paramters (internal use only)\n    ---------\n    fp  : file-like object for tqdm\n    \"\"\"\n    try:\n        log = sys.argv.index('--log')\n    except ValueError:\n        logLevel = 'INFO'\n    else:\n        # sys.argv.pop(log)\n        # logLevel = sys.argv.pop(log)\n        logLevel = sys.argv[log + 1]\n    logging.basicConfig(level=getattr(logging, logLevel))\n    log = logging.getLogger(__name__)\n", "long_prefix": ["    if \" or \" in typ:\n        for t in typ.split(\" or \"):\n            try:\n                return cast(val, t)\n            except TqdmTypeError:\n                pass\n        raise TqdmTypeError(val + ' : ' + typ)\n\n    # sys.stderr.write('\\ndebug | `val:type`: `' + val + ':' + typ + '`.\\n')\n    if typ == 'bool':\n        if (val == 'True') or (val == ''):\n            return True\n        elif val == 'False':\n            return False\n        else:\n            raise TqdmTypeError(val + ' : ' + typ)\n    try:\n        return eval(typ + '(\"' + val + '\")')\n    except:\n        if typ == 'chr':\n            return chr(ord(eval('\"' + val + '\"')))\n        else:\n            raise TqdmTypeError(val + ' : ' + typ)\n\n\ndef posix_pipe(fin, fout, delim='\\n', buf_size=256,\n               callback=lambda int: None  # pragma: no cover\n               ):\n    \"\"\"\n    Params\n    ------\n    fin  : file with `read(buf_size : int)` method\n    fout  : file with `write` (and optionally `flush`) methods.\n    callback  : function(int), e.g.: `tqdm.update`\n    \"\"\"\n    fp_write = fout.write\n\n    # tmp = ''\n    if not delim:\n        while True:\n            tmp = fin.read(buf_size)\n\n            # flush at EOF\n            if not tmp:\n                getattr(fout, 'flush', lambda: None)()  # pragma: no cover\n                return\n\n            fp_write(tmp)\n            callback(len(tmp))\n        # return\n\n    buf = ''\n    # n = 0\n    while True:\n        tmp = fin.read(buf_size)\n\n        # flush at EOF\n        if not tmp:\n            if buf:\n                fp_write(buf)\n                callback(1 + buf.count(delim))  # n += 1 + buf.count(delim)\n            getattr(fout, 'flush', lambda: None)()  # pragma: no cover\n            return  # n\n\n        while True:\n            try:\n                i = tmp.index(delim)\n            except ValueError:\n                buf += tmp\n                break\n            else:\n                fp_write(buf + tmp[:i + len(delim)])\n                callback(1)  # n += 1\n                buf = ''\n                tmp = tmp[i + len(delim):]\n\n\n# ((opt, type), ... )\nRE_OPTS = re.compile(r'\\n {8}(\\S+)\\s{2,}:\\s*([^,]+)')\n# better split method assuming no positional args\n", "\n# TODO: add custom support for some of the following?\nUNSUPPORTED_OPTS = ('iterable', 'gui', 'out', 'file')\n\n# The 8 leading spaces are required for consistency\nCLI_EXTRA_DOC = r\"\"\"\n        Extra CLI Options\n        -----------------\n        name  : type, optional\n             TODO: find out why this is needed.\n        delim  : chr, optional\n            Delimiting character [default: '\\n']. Use '\\0' for null.\n            N.B.: on Windows systems, Python converts '\\n' to '\\r\\n'.\n        buf_size  : int, optional\n            String buffer size in bytes [default: 256]\n            used when `delim` is specified.\n        bytes  : bool, optional\n            If true, will count bytes, ignore `delim`, and default\n            `unit_scale` to True, `unit_divisor` to 1024, and `unit` to 'B'.\n        log  : str, optional\n            CRITICAL|FATAL|ERROR|WARN(ING)|[default: 'INFO']|DEBUG|NOTSET.\n\"\"\"\n\n\ndef main(fp=sys.stderr):\n    \"\"\"\n    Paramters (internal use only)\n    ---------\n    fp  : file-like object for tqdm\n    \"\"\"\n    try:\n        log = sys.argv.index('--log')\n    except ValueError:\n        logLevel = 'INFO'\n    else:\n        # sys.argv.pop(log)\n        # logLevel = sys.argv.pop(log)\n        logLevel = sys.argv[log + 1]\n    logging.basicConfig(level=getattr(logging, logLevel))\n    log = logging.getLogger(__name__)\n"]}