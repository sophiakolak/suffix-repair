{"prefix": "    if re.match(r'^(?:[a-zA-Z][a-zA-Z0-9+-.]*:)?//', path):\n        return path\n    if isinstance(base, bytes):\n        base = base.decode('utf-8')\n    if not isinstance(base, compat_str) or not re.match(\n            r'^(?:https?:)?//', base):\n        return None\n    return compat_urlparse.urljoin(base, path)\n\n\nclass HEADRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'HEAD'\n\n\nclass PUTRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'PUT'\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr:\n        if v is not None:\n            v = getattr(v, get_attr, None)\n    if v == '':\n        v = None\n    if v is None:\n        return default\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError):\n        return default\n\n\ndef str_or_none(v, default=None):\n    return default if v is None else compat_str(v)\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n", "suffix": "    int_str = re.sub(r'[,\\.\\+]', '', int_str)\n    return int(int_str)\n\n\ndef float_or_none(v, scale=1, invscale=1, default=None):\n    if v is None:\n        return default\n    try:\n        return float(v) * invscale / scale\n    except (ValueError, TypeError):\n        return default\n\n\ndef bool_or_none(v, default=None):\n    return v if isinstance(v, bool) else default\n\n\ndef strip_or_none(v, default=None):\n    return v.strip() if isinstance(v, compat_str) else default\n\n\ndef url_or_none(url):\n    if not url or not isinstance(url, compat_str):\n        return None\n    url = url.strip()\n    return url if re.match(r'^(?:[a-zA-Z][\\da-zA-Z.+-]*:)?//', url) else None\n\n\ndef parse_duration(s):\n    if not isinstance(s, compat_basestring):\n        return None\n\n    s = s.strip()\n\n    days, hours, mins, secs, ms = [None] * 5\n    m = re.match(r'(?:(?:(?:(?P<days>[0-9]+):)?(?P<hours>[0-9]+):)?(?P<mins>[0-9]+):)?(?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?Z?$', s)\n    if m:\n        days, hours, mins, secs, ms = m.groups()\n    else:\n        m = re.match(\n", "long_prefix": ["    title_bytes = title.encode('utf-8')\n    buf = ctypes.create_string_buffer(len(title_bytes))\n    buf.value = title_bytes\n    try:\n        libc.prctl(15, buf, 0, 0, 0)\n    except AttributeError:\n        return  # Strange libc, just skip this\n\n\ndef remove_start(s, start):\n    return s[len(start):] if s is not None and s.startswith(start) else s\n\n\ndef remove_end(s, end):\n    return s[:-len(end)] if s is not None and s.endswith(end) else s\n\n\ndef remove_quotes(s):\n    if s is None or len(s) < 2:\n        return s\n    for quote in ('\"', \"'\", ):\n        if s[0] == quote and s[-1] == quote:\n            return s[1:-1]\n    return s\n\n\ndef url_basename(url):\n    path = compat_urlparse.urlparse(url).path\n    return path.strip('/').split('/')[-1]\n\n\ndef base_url(url):\n    return re.match(r'https?://[^?#&]+/', url).group()\n\n\ndef urljoin(base, path):\n    if isinstance(path, bytes):\n        path = path.decode('utf-8')\n    if not isinstance(path, compat_str) or not path:\n        return None\n    if re.match(r'^(?:[a-zA-Z][a-zA-Z0-9+-.]*:)?//', path):\n        return path\n    if isinstance(base, bytes):\n        base = base.decode('utf-8')\n    if not isinstance(base, compat_str) or not re.match(\n            r'^(?:https?:)?//', base):\n        return None\n    return compat_urlparse.urljoin(base, path)\n\n\nclass HEADRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'HEAD'\n\n\nclass PUTRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'PUT'\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr:\n        if v is not None:\n            v = getattr(v, get_attr, None)\n    if v == '':\n        v = None\n    if v is None:\n        return default\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError):\n        return default\n\n\ndef str_or_none(v, default=None):\n    return default if v is None else compat_str(v)\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n", "    int_str = re.sub(r'[,\\.\\+]', '', int_str)\n    return int(int_str)\n\n\ndef float_or_none(v, scale=1, invscale=1, default=None):\n    if v is None:\n        return default\n    try:\n        return float(v) * invscale / scale\n    except (ValueError, TypeError):\n        return default\n\n\ndef bool_or_none(v, default=None):\n    return v if isinstance(v, bool) else default\n\n\ndef strip_or_none(v, default=None):\n    return v.strip() if isinstance(v, compat_str) else default\n\n\ndef url_or_none(url):\n    if not url or not isinstance(url, compat_str):\n        return None\n    url = url.strip()\n    return url if re.match(r'^(?:[a-zA-Z][\\da-zA-Z.+-]*:)?//', url) else None\n\n\ndef parse_duration(s):\n    if not isinstance(s, compat_basestring):\n        return None\n\n    s = s.strip()\n\n    days, hours, mins, secs, ms = [None] * 5\n    m = re.match(r'(?:(?:(?:(?P<days>[0-9]+):)?(?P<hours>[0-9]+):)?(?P<mins>[0-9]+):)?(?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?Z?$', s)\n    if m:\n        days, hours, mins, secs, ms = m.groups()\n    else:\n        m = re.match(\n"]}