{"prefix": "        if task.status != PENDING:\n            return False\n        for dep in task.deps:\n            dep_task = self._state.get_task(dep, default=None)\n            if dep_task is None or dep_task.status != DONE:\n                return False\n        return True\n\n    def get_work(self, worker, host=None, assistant=False, **kwargs):\n        # TODO: remove any expired nodes\n\n        # Algo: iterate over all nodes, find the highest priority node no dependencies and available\n        # resources.\n\n        # Resource checking looks both at currently available resources and at which resources would\n        # be available if all running tasks died and we rescheduled all workers greedily. We do both\n        # checks in order to prevent a worker with many low-priority tasks from starving other\n        # workers with higher priority tasks that share the same resources.\n\n        # TODO: remove tasks that can't be done, figure out if the worker has absolutely\n        # nothing it can wait for\n\n        # Return remaining tasks that have no FAILED descendents\n        self.update(worker, {'host': host})\n        if assistant:\n            self.add_worker(worker, [('assistant', assistant)])\n        best_task = None\n        locally_pending_tasks = 0\n        running_tasks = []\n\n        used_resources = self._used_resources()\n        greedy_resources = collections.defaultdict(int)\n        n_unique_pending = 0\n        greedy_workers = dict((worker.id, worker.info.get('workers', 1))\n                              for worker in self._state.get_active_workers())\n\n        tasks = list(self._state.get_pending_tasks())\n        tasks.sort(key=self._rank(), reverse=True)\n\n        for task in tasks:\n", "suffix": "            if task.status == 'RUNNING' and in_workers:\n                # Return a list of currently running tasks to the client,\n                # makes it easier to troubleshoot\n                other_worker = self._state.get_worker(task.worker_running)\n                more_info = {'task_id': task.id, 'worker': str(other_worker)}\n                if other_worker is not None:\n                    more_info.update(other_worker.info)\n                    running_tasks.append(more_info)\n\n            if task.status == PENDING and in_workers:\n                locally_pending_tasks += 1\n                if len(task.workers) == 1 and not assistant:\n                    n_unique_pending += 1\n\n            if task.status == RUNNING and (task.worker_running in greedy_workers):\n                greedy_workers[task.worker_running] -= 1\n                for resource, amount in six.iteritems((task.resources or {})):\n                    greedy_resources[resource] += amount\n\n            if not best_task and self._schedulable(task) and self._has_resources(task.resources, greedy_resources):\n                if in_workers and self._has_resources(task.resources, used_resources):\n                    best_task = task\n                else:\n                    workers = itertools.chain(task.workers, [worker]) if assistant else task.workers\n                    for task_worker in workers:\n                        if greedy_workers.get(task_worker, 0) > 0:\n                            # use up a worker\n                            greedy_workers[task_worker] -= 1\n\n                            # keep track of the resources used in greedy scheduling\n                            for resource, amount in six.iteritems((task.resources or {})):\n                                greedy_resources[resource] += amount\n\n                            break\n\n        reply = {'n_pending_tasks': locally_pending_tasks,\n                 'running_tasks': running_tasks,\n                 'task_id': None,\n                 'n_unique_pending': n_unique_pending}\n\n", "long_prefix": ["    def _has_resources(self, needed_resources, used_resources):\n        if needed_resources is None:\n            return True\n\n        available_resources = self._resources or {}\n        for resource, amount in six.iteritems(needed_resources):\n            if amount + used_resources[resource] > available_resources.get(resource, 1):\n                return False\n        return True\n\n    def _used_resources(self):\n        used_resources = collections.defaultdict(int)\n        if self._resources is not None:\n            for task in self._state.get_active_tasks():\n                if task.status == RUNNING and task.resources:\n                    for resource, amount in six.iteritems(task.resources):\n                        used_resources[resource] += amount\n        return used_resources\n\n    def _rank(self):\n        \"\"\"\n        Return worker's rank function for task scheduling.\n\n        :return:\n        \"\"\"\n        dependents = collections.defaultdict(int)\n\n        def not_done(t):\n            task = self._state.get_task(t, default=None)\n            return task is None or task.status != DONE\n        for task in self._state.get_pending_tasks():\n            if task.status != DONE:\n                deps = list(filter(not_done, task.deps))\n                inverse_num_deps = 1.0 / max(len(deps), 1)\n                for dep in deps:\n                    dependents[dep] += inverse_num_deps\n\n        return lambda task: (task.priority, dependents[task.id], -task.time)\n\n    def _schedulable(self, task):\n        if task.status != PENDING:\n            return False\n        for dep in task.deps:\n            dep_task = self._state.get_task(dep, default=None)\n            if dep_task is None or dep_task.status != DONE:\n                return False\n        return True\n\n    def get_work(self, worker, host=None, assistant=False, **kwargs):\n        # TODO: remove any expired nodes\n\n        # Algo: iterate over all nodes, find the highest priority node no dependencies and available\n        # resources.\n\n        # Resource checking looks both at currently available resources and at which resources would\n        # be available if all running tasks died and we rescheduled all workers greedily. We do both\n        # checks in order to prevent a worker with many low-priority tasks from starving other\n        # workers with higher priority tasks that share the same resources.\n\n        # TODO: remove tasks that can't be done, figure out if the worker has absolutely\n        # nothing it can wait for\n\n        # Return remaining tasks that have no FAILED descendents\n        self.update(worker, {'host': host})\n        if assistant:\n            self.add_worker(worker, [('assistant', assistant)])\n        best_task = None\n        locally_pending_tasks = 0\n        running_tasks = []\n\n        used_resources = self._used_resources()\n        greedy_resources = collections.defaultdict(int)\n        n_unique_pending = 0\n        greedy_workers = dict((worker.id, worker.info.get('workers', 1))\n                              for worker in self._state.get_active_workers())\n\n        tasks = list(self._state.get_pending_tasks())\n        tasks.sort(key=self._rank(), reverse=True)\n\n        for task in tasks:\n", "            if task.status == 'RUNNING' and in_workers:\n                # Return a list of currently running tasks to the client,\n                # makes it easier to troubleshoot\n                other_worker = self._state.get_worker(task.worker_running)\n                more_info = {'task_id': task.id, 'worker': str(other_worker)}\n                if other_worker is not None:\n                    more_info.update(other_worker.info)\n                    running_tasks.append(more_info)\n\n            if task.status == PENDING and in_workers:\n                locally_pending_tasks += 1\n                if len(task.workers) == 1 and not assistant:\n                    n_unique_pending += 1\n\n            if task.status == RUNNING and (task.worker_running in greedy_workers):\n                greedy_workers[task.worker_running] -= 1\n                for resource, amount in six.iteritems((task.resources or {})):\n                    greedy_resources[resource] += amount\n\n            if not best_task and self._schedulable(task) and self._has_resources(task.resources, greedy_resources):\n                if in_workers and self._has_resources(task.resources, used_resources):\n                    best_task = task\n                else:\n                    workers = itertools.chain(task.workers, [worker]) if assistant else task.workers\n                    for task_worker in workers:\n                        if greedy_workers.get(task_worker, 0) > 0:\n                            # use up a worker\n                            greedy_workers[task_worker] -= 1\n\n                            # keep track of the resources used in greedy scheduling\n                            for resource, amount in six.iteritems((task.resources or {})):\n                                greedy_resources[resource] += amount\n\n                            break\n\n        reply = {'n_pending_tasks': locally_pending_tasks,\n                 'running_tasks': running_tasks,\n                 'task_id': None,\n                 'n_unique_pending': n_unique_pending}\n\n"]}