{"prefix": "        log = dump_to_file(\"\".join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\"\n        ) from None\n\n    src_ast_str = \"\\n\".join(_v(src_ast))\n    dst_ast_str = \"\\n\".join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, \"src\", \"dst\"))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, \"source\", \"first pass\"),\n            diff(dst, newdst, \"first pass\", \"second pass\"),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n", "suffix": "    ) as f:\n        for lines in output:\n            f.write(lines)\n            if lines and lines[-1] != \"\\n\":\n                f.write(\"\\n\")\n    return f.name\n\n\ndef diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + \"\\n\" for line in a.split(\"\\n\")]\n    b_lines = [line + \"\\n\" for line in b.split(\"\\n\")]\n    return \"\".join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )\n\n\ndef cancel(tasks: List[asyncio.Task]) -> None:\n    \"\"\"asyncio signal handler that cancels all `tasks` and reports to stderr.\"\"\"\n    err(\"Aborted!\")\n    for task in tasks:\n        task.cancel()\n\n\ndef shutdown(loop: BaseEventLoop) -> None:\n    \"\"\"Cancel all pending tasks on `loop`, wait for them, and close the loop.\"\"\"\n    try:\n        # This part is borrowed from asyncio/runners.py in Python 3.7b2.\n        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n        loop.run_until_complete(\n            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)\n        )\n    finally:\n", "long_prefix": ["    import traceback\n\n    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:\n        \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n        yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n        for field in sorted(node._fields):\n            try:\n                value = getattr(node, field)\n            except AttributeError:\n                continue\n\n            yield f\"{'  ' * (depth+1)}{field}=\"\n\n            if isinstance(value, list):\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        yield from _v(item, depth + 2)\n\n            elif isinstance(value, ast.AST):\n                yield from _v(value, depth + 2)\n\n            else:\n                yield f\"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}\"\n\n        yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"\n\n    try:\n        src_ast = ast.parse(src)\n    except Exception as exc:\n        major, minor = sys.version_info[:2]\n        raise AssertionError(\n            f\"cannot use --safe with this file; failed to parse source file \"\n            f\"with Python {major}.{minor}'s builtin AST. Re-run with --fast \"\n            f\"or stop using deprecated Python 2 syntax. AST error message: {exc}\"\n        )\n\n    try:\n        dst_ast = ast.parse(dst)\n    except Exception as exc:\n        log = dump_to_file(\"\".join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This invalid output might be helpful: {log}\"\n        ) from None\n\n    src_ast_str = \"\\n\".join(_v(src_ast))\n    dst_ast_str = \"\\n\".join(_v(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, \"src\", \"dst\"))\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced code that is not equivalent to \"\n            f\"the source.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef assert_stable(src: str, dst: str, line_length: int) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, line_length=line_length)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, \"source\", \"first pass\"),\n            diff(dst, newdst, \"first pass\", \"second pass\"),\n        )\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced different code on the second pass \"\n            f\"of the formatter.  \"\n            f\"Please report a bug on https://github.com/ambv/black/issues.  \"\n            f\"This diff might be helpful: {log}\"\n        ) from None\n\n\ndef dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(\n", "    ) as f:\n        for lines in output:\n            f.write(lines)\n            if lines and lines[-1] != \"\\n\":\n                f.write(\"\\n\")\n    return f.name\n\n\ndef diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + \"\\n\" for line in a.split(\"\\n\")]\n    b_lines = [line + \"\\n\" for line in b.split(\"\\n\")]\n    return \"\".join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )\n\n\ndef cancel(tasks: List[asyncio.Task]) -> None:\n    \"\"\"asyncio signal handler that cancels all `tasks` and reports to stderr.\"\"\"\n    err(\"Aborted!\")\n    for task in tasks:\n        task.cancel()\n\n\ndef shutdown(loop: BaseEventLoop) -> None:\n    \"\"\"Cancel all pending tasks on `loop`, wait for them, and close the loop.\"\"\"\n    try:\n        # This part is borrowed from asyncio/runners.py in Python 3.7b2.\n        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n        loop.run_until_complete(\n            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)\n        )\n    finally:\n"]}