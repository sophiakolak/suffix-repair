{"prefix": "    def make_current(self):\n        \"\"\"Makes this the `IOLoop` for the current thread.\n\n        An `IOLoop` automatically becomes current for its thread\n        when it is started, but it is sometimes useful to call\n        `make_current` explicitly before starting the `IOLoop`,\n        so that code run at startup time can find the right\n        instance.\n\n        .. versionchanged:: 4.1\n           An `IOLoop` created while there is no current `IOLoop`\n           will automatically become current.\n        \"\"\"\n        IOLoop._current.instance = self\n\n    @staticmethod\n    def clear_current():\n        IOLoop._current.instance = None\n\n    @classmethod\n    def configurable_base(cls):\n        return IOLoop\n\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\"):\n            from tornado.platform.epoll import EPollIOLoop\n            return EPollIOLoop\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n\n    def initialize(self, make_current=None):\n        if make_current is None:\n            if IOLoop.current(instance=False) is None:\n                self.make_current()\n        elif make_current:\n", "suffix": "                raise RuntimeError(\"current IOLoop already exists\")\n            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n           If the `IOLoop` implementation supports non-integer objects\n           for \"file descriptors\", those objects will have their\n           ``close`` method when ``all_fds`` is true.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_handler(self, fd, handler, events):\n        \"\"\"Registers the given handler to receive the given events for ``fd``.\n\n        The ``fd`` argument may either be an integer file descriptor or\n        a file-like object with a ``fileno()`` method (and optionally a\n        ``close()`` method, which may be called when the `IOLoop` is shut\n        down).\n\n        The ``events`` argument is a bitwise or of the constants\n        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.\n", "long_prefix": ["        This is normally not necessary as `instance()` will create\n        an `IOLoop` on demand, but you may want to call `install` to use\n        a custom subclass of `IOLoop`.\n        \"\"\"\n        assert not IOLoop.initialized()\n        IOLoop._instance = self\n\n    @staticmethod\n    def clear_instance():\n        \"\"\"Clear the global `IOLoop` instance.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        if hasattr(IOLoop, \"_instance\"):\n            del IOLoop._instance\n\n    @staticmethod\n    def current(instance=True):\n        \"\"\"Returns the current thread's `IOLoop`.\n\n        If an `IOLoop` is currently running or has been marked as\n        current by `make_current`, returns that instance.  If there is\n        no current `IOLoop`, returns `IOLoop.instance()` (i.e. the\n        main thread's `IOLoop`, creating one if necessary) if ``instance``\n        is true.\n\n        In general you should use `IOLoop.current` as the default when\n        constructing an asynchronous object, and use `IOLoop.instance`\n        when you mean to communicate to the main thread from a different\n        one.\n\n        .. versionchanged:: 4.1\n           Added ``instance`` argument to control the fallback to\n           `IOLoop.instance()`.\n        \"\"\"\n        current = getattr(IOLoop._current, \"instance\", None)\n        if current is None and instance:\n            return IOLoop.instance()\n        return current\n\n    def make_current(self):\n        \"\"\"Makes this the `IOLoop` for the current thread.\n\n        An `IOLoop` automatically becomes current for its thread\n        when it is started, but it is sometimes useful to call\n        `make_current` explicitly before starting the `IOLoop`,\n        so that code run at startup time can find the right\n        instance.\n\n        .. versionchanged:: 4.1\n           An `IOLoop` created while there is no current `IOLoop`\n           will automatically become current.\n        \"\"\"\n        IOLoop._current.instance = self\n\n    @staticmethod\n    def clear_current():\n        IOLoop._current.instance = None\n\n    @classmethod\n    def configurable_base(cls):\n        return IOLoop\n\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\"):\n            from tornado.platform.epoll import EPollIOLoop\n            return EPollIOLoop\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n\n    def initialize(self, make_current=None):\n        if make_current is None:\n            if IOLoop.current(instance=False) is None:\n                self.make_current()\n        elif make_current:\n", "                raise RuntimeError(\"current IOLoop already exists\")\n            self.make_current()\n\n    def close(self, all_fds=False):\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n           If the `IOLoop` implementation supports non-integer objects\n           for \"file descriptors\", those objects will have their\n           ``close`` method when ``all_fds`` is true.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_handler(self, fd, handler, events):\n        \"\"\"Registers the given handler to receive the given events for ``fd``.\n\n        The ``fd`` argument may either be an integer file descriptor or\n        a file-like object with a ``fileno()`` method (and optionally a\n        ``close()`` method, which may be called when the `IOLoop` is shut\n        down).\n\n        The ``events`` argument is a bitwise or of the constants\n        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.\n"]}