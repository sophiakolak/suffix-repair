{"prefix": "        for cell in self.cells[::-1]:\n            if hasattr(cell.state_size, '__len__'):\n                state_size += list(cell.state_size)\n            else:\n                state_size.append(cell.state_size)\n        return tuple(state_size)\n\n    def call(self, inputs, states, **kwargs):\n        # Recover per-cell states.\n        nested_states = []\n        for cell in self.cells[::-1]:\n            if hasattr(cell.state_size, '__len__'):\n                nested_states.append(states[:len(cell.state_size)])\n                states = states[len(cell.state_size):]\n            else:\n                nested_states.append([states[0]])\n                states = states[1:]\n        nested_states = nested_states[::-1]\n\n        # Call the cells in order and store the returned states.\n        new_nested_states = []\n        for cell, states in zip(self.cells, nested_states):\n            inputs, states = cell.call(inputs, states, **kwargs)\n            new_nested_states.append(states)\n\n        # Format the new states as a flat list\n        # in reverse cell order.\n        states = []\n        for cell_states in new_nested_states[::-1]:\n            states += cell_states\n        return inputs, states\n\n    def build(self, input_shape):\n        for cell in self.cells:\n            if isinstance(cell, Layer):\n                cell.build(input_shape)\n            if hasattr(cell.state_size, '__len__'):\n                output_dim = cell.state_size[0]\n            else:\n                output_dim = cell.state_size\n", "suffix": "        self.built = True\n\n    def get_config(self):\n        cells = []\n        for cell in self.cells:\n            cells.append({'class_name': cell.__class__.__name__,\n                          'config': cell.get_config()})\n        config = {'cells': cells}\n        base_config = super(StackedRNNCells, self).get_config()\n        return dict(list(base_config.items()) + list(config.items()))\n\n    @classmethod\n    def from_config(cls, config, custom_objects=None):\n        from . import deserialize as deserialize_layer\n        cells = []\n        for cell_config in config.pop('cells'):\n            cells.append(deserialize_layer(cell_config,\n                                           custom_objects=custom_objects))\n        return cls(cells, **config)\n\n    @property\n    def trainable_weights(self):\n        if not self.trainable:\n            return []\n        weights = []\n        for cell in self.cells:\n            if isinstance(cell, Layer):\n                weights += cell.trainable_weights\n        return weights\n\n    @property\n    def non_trainable_weights(self):\n        weights = []\n        for cell in self.cells:\n            if isinstance(cell, Layer):\n                weights += cell.non_trainable_weights\n        if not self.trainable:\n            trainable_weights = []\n            for cell in self.cells:\n                if isinstance(cell, Layer):\n", "long_prefix": ["\n    # Arguments\n        cells: List of RNN cell instances.\n\n    # Examples\n\n    ```python\n        cells = [\n            keras.layers.LSTMCell(output_dim),\n            keras.layers.LSTMCell(output_dim),\n            keras.layers.LSTMCell(output_dim),\n        ]\n\n        inputs = keras.Input((timesteps, input_dim))\n        x = keras.layers.RNN(cells)(inputs)\n    ```\n    \"\"\"\n\n    def __init__(self, cells, **kwargs):\n        for cell in cells:\n            if not hasattr(cell, 'call'):\n                raise ValueError('All cells must have a `call` method. '\n                                 'received cells:', cells)\n            if not hasattr(cell, 'state_size'):\n                raise ValueError('All cells must have a '\n                                 '`state_size` attribute. '\n                                 'received cells:', cells)\n        self.cells = cells\n        super(StackedRNNCells, self).__init__(**kwargs)\n\n    @property\n    def state_size(self):\n        # States are a flat list\n        # in reverse order of the cell stack.\n        # This allows to preserve the requirement\n        # `stack.state_size[0] == output_dim`.\n        # e.g. states of a 2-layer LSTM would be\n        # `[h2, c2, h1, c1]`\n        # (assuming one LSTM has states [h, c])\n        state_size = []\n        for cell in self.cells[::-1]:\n            if hasattr(cell.state_size, '__len__'):\n                state_size += list(cell.state_size)\n            else:\n                state_size.append(cell.state_size)\n        return tuple(state_size)\n\n    def call(self, inputs, states, **kwargs):\n        # Recover per-cell states.\n        nested_states = []\n        for cell in self.cells[::-1]:\n            if hasattr(cell.state_size, '__len__'):\n                nested_states.append(states[:len(cell.state_size)])\n                states = states[len(cell.state_size):]\n            else:\n                nested_states.append([states[0]])\n                states = states[1:]\n        nested_states = nested_states[::-1]\n\n        # Call the cells in order and store the returned states.\n        new_nested_states = []\n        for cell, states in zip(self.cells, nested_states):\n            inputs, states = cell.call(inputs, states, **kwargs)\n            new_nested_states.append(states)\n\n        # Format the new states as a flat list\n        # in reverse cell order.\n        states = []\n        for cell_states in new_nested_states[::-1]:\n            states += cell_states\n        return inputs, states\n\n    def build(self, input_shape):\n        for cell in self.cells:\n            if isinstance(cell, Layer):\n                cell.build(input_shape)\n            if hasattr(cell.state_size, '__len__'):\n                output_dim = cell.state_size[0]\n            else:\n                output_dim = cell.state_size\n", "        self.built = True\n\n    def get_config(self):\n        cells = []\n        for cell in self.cells:\n            cells.append({'class_name': cell.__class__.__name__,\n                          'config': cell.get_config()})\n        config = {'cells': cells}\n        base_config = super(StackedRNNCells, self).get_config()\n        return dict(list(base_config.items()) + list(config.items()))\n\n    @classmethod\n    def from_config(cls, config, custom_objects=None):\n        from . import deserialize as deserialize_layer\n        cells = []\n        for cell_config in config.pop('cells'):\n            cells.append(deserialize_layer(cell_config,\n                                           custom_objects=custom_objects))\n        return cls(cells, **config)\n\n    @property\n    def trainable_weights(self):\n        if not self.trainable:\n            return []\n        weights = []\n        for cell in self.cells:\n            if isinstance(cell, Layer):\n                weights += cell.trainable_weights\n        return weights\n\n    @property\n    def non_trainable_weights(self):\n        weights = []\n        for cell in self.cells:\n            if isinstance(cell, Layer):\n                weights += cell.non_trainable_weights\n        if not self.trainable:\n            trainable_weights = []\n            for cell in self.cells:\n                if isinstance(cell, Layer):\n"]}