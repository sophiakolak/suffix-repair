{"prefix": "                \"will be removed in a future version.\"\n            ),\n            FutureWarning,\n            stacklevel=2,\n        )\n        self._engine.set_value(\n            com.values_from_object(arr), com.values_from_object(key), value\n        )\n\n    _index_shared_docs[\n        \"get_indexer_non_unique\"\n    ] = \"\"\"\n        Compute indexer and mask for new index given the current index. The\n        indexer should be then used as an input to ndarray.take to align the\n        current data to the new index.\n\n        Parameters\n        ----------\n        target : %(target_klass)s\n\n        Returns\n        -------\n        indexer : ndarray of int\n            Integers from 0 to n - 1 indicating that the index at these\n            positions matches the corresponding target values. Missing values\n            in the target are marked by -1.\n        missing : ndarray of int\n            An indexer into the target of the values not found.\n            These correspond to the -1 in the indexer array.\n        \"\"\"\n\n    @Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\n    def get_indexer_non_unique(self, target):\n        target = ensure_index(target)\n        pself, ptarget = self._maybe_promote(target)\n        if pself is not self or ptarget is not target:\n            return pself.get_indexer_non_unique(ptarget)\n\n        if is_categorical(target):\n            tgt_values = np.asarray(target)\n", "suffix": "            tgt_values = target.asi8\n        else:\n            tgt_values = target._ndarray_values\n\n        indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n        return ensure_platform_int(indexer), missing\n\n    def get_indexer_for(self, target, **kwargs):\n        \"\"\"\n        Guaranteed return of an indexer even when non-unique.\n\n        This dispatches to get_indexer or get_indexer_non_unique\n        as appropriate.\n\n        Returns\n        -------\n        numpy.ndarray\n            List of indices.\n        \"\"\"\n        if self.is_unique:\n            return self.get_indexer(target, **kwargs)\n        indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n        return indexer\n\n    def _maybe_promote(self, other):\n        # A hack, but it works\n\n        if self.inferred_type == \"date\" and isinstance(other, ABCDatetimeIndex):\n            return type(other)(self), other\n        elif self.inferred_type == \"boolean\":\n            if not is_object_dtype(self.dtype):\n                return self.astype(\"object\"), other.astype(\"object\")\n        return self, other\n\n    def groupby(self, values):\n        \"\"\"\n        Group the index labels by a given array of values.\n\n        Parameters\n        ----------\n", "long_prefix": ["        k = com.values_from_object(key)\n\n        k = self._convert_scalar_indexer(k, kind=\"getitem\")\n        try:\n            return self._engine.get_value(s, k, tz=getattr(series.dtype, \"tz\", None))\n        except KeyError as e1:\n            if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n                raise\n\n            try:\n                return libindex.get_value_at(s, key)\n            except IndexError:\n                raise\n            except TypeError:\n                # generator/iterator-like\n                if is_iterator(key):\n                    raise InvalidIndexError(key)\n                else:\n                    raise e1\n            except Exception:\n                raise e1\n        except TypeError:\n            # e.g. \"[False] is an invalid key\"\n            if is_scalar(key):\n                raise IndexError(key)\n            raise InvalidIndexError(key)\n\n    def set_value(self, arr, key, value):\n        \"\"\"\n        Fast lookup of value from 1-dimensional ndarray.\n\n        .. deprecated:: 1.0\n\n        Notes\n        -----\n        Only use this if you know what you're doing.\n        \"\"\"\n        warnings.warn(\n            (\n                \"The 'set_value' method is deprecated, and \"\n                \"will be removed in a future version.\"\n            ),\n            FutureWarning,\n            stacklevel=2,\n        )\n        self._engine.set_value(\n            com.values_from_object(arr), com.values_from_object(key), value\n        )\n\n    _index_shared_docs[\n        \"get_indexer_non_unique\"\n    ] = \"\"\"\n        Compute indexer and mask for new index given the current index. The\n        indexer should be then used as an input to ndarray.take to align the\n        current data to the new index.\n\n        Parameters\n        ----------\n        target : %(target_klass)s\n\n        Returns\n        -------\n        indexer : ndarray of int\n            Integers from 0 to n - 1 indicating that the index at these\n            positions matches the corresponding target values. Missing values\n            in the target are marked by -1.\n        missing : ndarray of int\n            An indexer into the target of the values not found.\n            These correspond to the -1 in the indexer array.\n        \"\"\"\n\n    @Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\n    def get_indexer_non_unique(self, target):\n        target = ensure_index(target)\n        pself, ptarget = self._maybe_promote(target)\n        if pself is not self or ptarget is not target:\n            return pself.get_indexer_non_unique(ptarget)\n\n        if is_categorical(target):\n            tgt_values = np.asarray(target)\n", "            tgt_values = target.asi8\n        else:\n            tgt_values = target._ndarray_values\n\n        indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n        return ensure_platform_int(indexer), missing\n\n    def get_indexer_for(self, target, **kwargs):\n        \"\"\"\n        Guaranteed return of an indexer even when non-unique.\n\n        This dispatches to get_indexer or get_indexer_non_unique\n        as appropriate.\n\n        Returns\n        -------\n        numpy.ndarray\n            List of indices.\n        \"\"\"\n        if self.is_unique:\n            return self.get_indexer(target, **kwargs)\n        indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n        return indexer\n\n    def _maybe_promote(self, other):\n        # A hack, but it works\n\n        if self.inferred_type == \"date\" and isinstance(other, ABCDatetimeIndex):\n            return type(other)(self), other\n        elif self.inferred_type == \"boolean\":\n            if not is_object_dtype(self.dtype):\n                return self.astype(\"object\"), other.astype(\"object\")\n        return self, other\n\n    def groupby(self, values):\n        \"\"\"\n        Group the index labels by a given array of values.\n\n        Parameters\n        ----------\n"]}