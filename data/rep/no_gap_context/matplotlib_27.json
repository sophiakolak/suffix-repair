{"prefix": "        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.ignore_existing_data_limits = True\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        if self.outline is not None:\n            self.outline.remove()\n        self.outline = mpatches.Polygon(\n            xy, edgecolor=mpl.rcParams['axes.edgecolor'],\n            facecolor='none',\n            linewidth=mpl.rcParams['axes.linewidth'],\n            closed=True,\n            zorder=2)\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        if self.patch is not None:\n            self.patch.remove()\n        self.patch = mpatches.Polygon(xy, edgecolor=c,\n                                      facecolor=c,\n                                      linewidth=0.01,\n                                      zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.update_ticks()\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n        self.stale = True\n\n    def set_label(self, label, **kw):\n        \"\"\"Label the long axis of the colorbar.\"\"\"\n", "suffix": "        self._labelkw = kw\n        self._set_label()\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N - 2, N - 1, 2 * N - 1, 2 * N - 2, N + 1, N, 0]\n        x = X.T.reshape(-1)[ii]\n        y = Y.T.reshape(-1)[ii]\n        return (np.column_stack([y, x])\n                if self.orientation == 'horizontal' else\n                np.column_stack([x, y]))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [list(zip(X[i], Y[i])) for i in range(1, N - 1)]\n        else:\n            return [list(zip(Y[i], X[i])) for i in range(1, N - 1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolormesh`;\n        optionally add separators.\n        '''\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n", "long_prefix": ["        Set tick labels.\n\n        Tick labels are updated immediately unless *update_ticks* is *False*,\n        in which case one should call `.update_ticks` explicitly.\n        \"\"\"\n        if isinstance(self.locator, ticker.FixedLocator):\n            self.formatter = ticker.FixedFormatter(ticklabels)\n            if update_ticks:\n                self.update_ticks()\n        else:\n            cbook._warn_external(\"set_ticks() must have been called.\")\n        self.stale = True\n\n    def minorticks_on(self):\n        \"\"\"\n        Turns on the minor ticks on the colorbar without extruding\n        into the \"extend regions\".\n        \"\"\"\n        ax = self.ax\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n\n        if long_axis.get_scale() == 'log':\n            long_axis.set_minor_locator(_ColorbarLogLocator(self, base=10.,\n                                                            subs='auto'))\n            long_axis.set_minor_formatter(ticker.LogFormatterSciNotation())\n        else:\n            long_axis.set_minor_locator(_ColorbarAutoMinorLocator(self))\n\n    def minorticks_off(self):\n        \"\"\"\n        Turns off the minor ticks on the colorbar.\n        \"\"\"\n        ax = self.ax\n        long_axis = ax.yaxis if self.orientation == 'vertical' else ax.xaxis\n\n        long_axis.set_minor_locator(ticker.NullLocator())\n\n    def _config_axes(self, X, Y):\n        '''\n        Make an axes patch and outline.\n        '''\n        ax = self.ax\n        ax.set_frame_on(False)\n        ax.set_navigate(False)\n        xy = self._outline(X, Y)\n        ax.ignore_existing_data_limits = True\n        ax.update_datalim(xy)\n        ax.set_xlim(*ax.dataLim.intervalx)\n        ax.set_ylim(*ax.dataLim.intervaly)\n        if self.outline is not None:\n            self.outline.remove()\n        self.outline = mpatches.Polygon(\n            xy, edgecolor=mpl.rcParams['axes.edgecolor'],\n            facecolor='none',\n            linewidth=mpl.rcParams['axes.linewidth'],\n            closed=True,\n            zorder=2)\n        ax.add_artist(self.outline)\n        self.outline.set_clip_box(None)\n        self.outline.set_clip_path(None)\n        c = mpl.rcParams['axes.facecolor']\n        if self.patch is not None:\n            self.patch.remove()\n        self.patch = mpatches.Polygon(xy, edgecolor=c,\n                                      facecolor=c,\n                                      linewidth=0.01,\n                                      zorder=-1)\n        ax.add_artist(self.patch)\n\n        self.update_ticks()\n\n    def _set_label(self):\n        if self.orientation == 'vertical':\n            self.ax.set_ylabel(self._label, **self._labelkw)\n        else:\n            self.ax.set_xlabel(self._label, **self._labelkw)\n        self.stale = True\n\n    def set_label(self, label, **kw):\n        \"\"\"Label the long axis of the colorbar.\"\"\"\n", "        self._labelkw = kw\n        self._set_label()\n\n    def _outline(self, X, Y):\n        '''\n        Return *x*, *y* arrays of colorbar bounding polygon,\n        taking orientation into account.\n        '''\n        N = X.shape[0]\n        ii = [0, 1, N - 2, N - 1, 2 * N - 1, 2 * N - 2, N + 1, N, 0]\n        x = X.T.reshape(-1)[ii]\n        y = Y.T.reshape(-1)[ii]\n        return (np.column_stack([y, x])\n                if self.orientation == 'horizontal' else\n                np.column_stack([x, y]))\n\n    def _edges(self, X, Y):\n        '''\n        Return the separator line segments; helper for _add_solids.\n        '''\n        N = X.shape[0]\n        # Using the non-array form of these line segments is much\n        # simpler than making them into arrays.\n        if self.orientation == 'vertical':\n            return [list(zip(X[i], Y[i])) for i in range(1, N - 1)]\n        else:\n            return [list(zip(Y[i], X[i])) for i in range(1, N - 1)]\n\n    def _add_solids(self, X, Y, C):\n        '''\n        Draw the colors using :meth:`~matplotlib.axes.Axes.pcolormesh`;\n        optionally add separators.\n        '''\n        if self.orientation == 'vertical':\n            args = (X, Y, C)\n        else:\n            args = (np.transpose(Y), np.transpose(X), np.transpose(C))\n        kw = dict(cmap=self.cmap,\n                  norm=self.norm,\n                  alpha=self.alpha,\n"]}