{"prefix": "import re\nfrom thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('push' in command.script_parts\n", "suffix": "\n\ndef _get_upstream_option_index(command_parts):\n    if '--set-upstream' in command_parts:\n        return command_parts.index('--set-upstream')\n    elif '-u' in command_parts:\n        return command_parts.index('-u')\n    else:\n        return None\n\n\n@git_support\ndef get_new_command(command):\n    # If --set-upstream or -u are passed, remove it and its argument. This is\n    # because the remaining arguments are concatenated onto the command suggested\n    # by git, which includes --set-upstream and its argument\n    command_parts = command.script_parts[:]\n    upstream_option_index = _get_upstream_option_index(command_parts)\n\n    if upstream_option_index is not None:\n        command_parts.pop(upstream_option_index)\n\n        # In case of `git push -u` we don't have next argument:\n        if len(command_parts) > upstream_option_index:\n            command_parts.pop(upstream_option_index)\n    else:\n        # the only non-qualified permitted options are the repository and refspec; git's\n        # suggestion include them, so they won't be lost, but would be duplicated otherwise.\n        push_idx = command_parts.index('push') + 1\n        while len(command_parts) > push_idx and command_parts[len(command_parts) - 1][0] != '-':\n            command_parts.pop(len(command_parts) - 1)\n\n    arguments = re.findall(r'git push (.*)', command.output)[0].replace(\"'\", r\"\\'\").strip()\n    return replace_argument(\" \".join(command_parts), 'push',\n                            'push {}'.format(arguments))\n", "long_prefix": ["import re\nfrom thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('push' in command.script_parts\n", "\n\ndef _get_upstream_option_index(command_parts):\n    if '--set-upstream' in command_parts:\n        return command_parts.index('--set-upstream')\n    elif '-u' in command_parts:\n        return command_parts.index('-u')\n    else:\n        return None\n\n\n@git_support\ndef get_new_command(command):\n    # If --set-upstream or -u are passed, remove it and its argument. This is\n    # because the remaining arguments are concatenated onto the command suggested\n    # by git, which includes --set-upstream and its argument\n    command_parts = command.script_parts[:]\n    upstream_option_index = _get_upstream_option_index(command_parts)\n\n    if upstream_option_index is not None:\n        command_parts.pop(upstream_option_index)\n\n        # In case of `git push -u` we don't have next argument:\n        if len(command_parts) > upstream_option_index:\n            command_parts.pop(upstream_option_index)\n    else:\n        # the only non-qualified permitted options are the repository and refspec; git's\n        # suggestion include them, so they won't be lost, but would be duplicated otherwise.\n        push_idx = command_parts.index('push') + 1\n        while len(command_parts) > push_idx and command_parts[len(command_parts) - 1][0] != '-':\n            command_parts.pop(len(command_parts) - 1)\n\n    arguments = re.findall(r'git push (.*)', command.output)[0].replace(\"'\", r\"\\'\").strip()\n    return replace_argument(\" \".join(command_parts), 'push',\n                            'push {}'.format(arguments))\n"]}