{"prefix": "\n        task = self._state.get_task(task_id, setdefault=_default_task)\n\n        if task is None or (task.status != RUNNING and not worker.enabled):\n            return\n\n        # for setting priority, we'll sometimes create tasks with unset family and params\n        if not task.family:\n            task.family = family\n        if not getattr(task, 'module', None):\n            task.module = module\n        if not task.params:\n            task.params = _get_default(params, {})\n\n        if batch_id is not None:\n            task.batch_id = batch_id\n        if status == RUNNING and not task.worker_running:\n            task.worker_running = worker_id\n            if batch_id:\n                task.resources_running = self._state.get_batch_running_tasks(batch_id)[0].resources_running\n            task.time_running = time.time()\n\n        if tracking_url is not None or task.status != RUNNING:\n            task.tracking_url = tracking_url\n            if task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.tracking_url = tracking_url\n\n        if batchable is not None:\n            task.batchable = batchable\n\n        if task.remove is not None:\n            task.remove = None  # unmark task for removal so it isn't removed after being added\n\n        if expl is not None:\n            task.expl = expl\n            if task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.expl = expl\n\n", "suffix": "            if status == PENDING or status != task.status:\n                # Update the DB only if there was a acctual change, to prevent noise.\n                # We also check for status == PENDING b/c that's the default value\n                # (so checking for status != task.status woule lie)\n                self._update_task_history(task, status)\n            self._state.set_status(task, PENDING if status == SUSPENDED else status, self._config)\n\n        if status == FAILED and self._config.batch_emails:\n            batched_params, _ = self._state.get_batcher(worker_id, family)\n            if batched_params:\n                unbatched_params = {\n                    param: value\n                    for param, value in six.iteritems(task.params)\n                    if param not in batched_params\n                }\n            else:\n                unbatched_params = task.params\n            try:\n                expl_raw = json.loads(expl)\n            except ValueError:\n                expl_raw = expl\n\n            self._email_batcher.add_failure(\n                task.pretty_id, task.family, unbatched_params, expl_raw, owners)\n            if task.status == DISABLED:\n                self._email_batcher.add_disable(\n                    task.pretty_id, task.family, unbatched_params, owners)\n\n        if deps is not None:\n            task.deps = set(deps)\n\n        if new_deps is not None:\n            task.deps.update(new_deps)\n\n        if resources is not None:\n            task.resources = resources\n\n        if worker.enabled and not assistant:\n            task.stakeholders.add(worker_id)\n\n", "long_prefix": ["\n    @rpc_method()\n    def forgive_failures(self, task_id=None):\n        status = PENDING\n        task = self._state.get_task(task_id)\n        if task is None:\n            return {\"task_id\": task_id, \"status\": None}\n\n        # we forgive only failures\n        if task.status == FAILED:\n            # forgive but do not forget\n            self._update_task_history(task, status)\n            self._state.set_status(task, status, self._config)\n        return {\"task_id\": task_id, \"status\": task.status}\n\n    @rpc_method()\n    def add_task(self, task_id=None, status=PENDING, runnable=True,\n                 deps=None, new_deps=None, expl=None, resources=None,\n                 priority=0, family='', module=None, params=None,\n                 assistant=False, tracking_url=None, worker=None, batchable=None,\n                 batch_id=None, retry_policy_dict={}, owners=None, **kwargs):\n        \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n        assert worker is not None\n        worker_id = worker\n        worker = self._update_worker(worker_id)\n        retry_policy = self._generate_retry_policy(retry_policy_dict)\n\n        if worker.enabled:\n            _default_task = self._make_task(\n                task_id=task_id, status=PENDING, deps=deps, resources=resources,\n                priority=priority, family=family, module=module, params=params,\n            )\n        else:\n            _default_task = None\n\n        task = self._state.get_task(task_id, setdefault=_default_task)\n\n        if task is None or (task.status != RUNNING and not worker.enabled):\n            return\n\n        # for setting priority, we'll sometimes create tasks with unset family and params\n        if not task.family:\n            task.family = family\n        if not getattr(task, 'module', None):\n            task.module = module\n        if not task.params:\n            task.params = _get_default(params, {})\n\n        if batch_id is not None:\n            task.batch_id = batch_id\n        if status == RUNNING and not task.worker_running:\n            task.worker_running = worker_id\n            if batch_id:\n                task.resources_running = self._state.get_batch_running_tasks(batch_id)[0].resources_running\n            task.time_running = time.time()\n\n        if tracking_url is not None or task.status != RUNNING:\n            task.tracking_url = tracking_url\n            if task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.tracking_url = tracking_url\n\n        if batchable is not None:\n            task.batchable = batchable\n\n        if task.remove is not None:\n            task.remove = None  # unmark task for removal so it isn't removed after being added\n\n        if expl is not None:\n            task.expl = expl\n            if task.batch_id is not None:\n                for batch_task in self._state.get_batch_running_tasks(task.batch_id):\n                    batch_task.expl = expl\n\n", "            if status == PENDING or status != task.status:\n                # Update the DB only if there was a acctual change, to prevent noise.\n                # We also check for status == PENDING b/c that's the default value\n                # (so checking for status != task.status woule lie)\n                self._update_task_history(task, status)\n            self._state.set_status(task, PENDING if status == SUSPENDED else status, self._config)\n\n        if status == FAILED and self._config.batch_emails:\n            batched_params, _ = self._state.get_batcher(worker_id, family)\n            if batched_params:\n                unbatched_params = {\n                    param: value\n                    for param, value in six.iteritems(task.params)\n                    if param not in batched_params\n                }\n            else:\n                unbatched_params = task.params\n            try:\n                expl_raw = json.loads(expl)\n            except ValueError:\n                expl_raw = expl\n\n            self._email_batcher.add_failure(\n                task.pretty_id, task.family, unbatched_params, expl_raw, owners)\n            if task.status == DISABLED:\n                self._email_batcher.add_disable(\n                    task.pretty_id, task.family, unbatched_params, owners)\n\n        if deps is not None:\n            task.deps = set(deps)\n\n        if new_deps is not None:\n            task.deps.update(new_deps)\n\n        if resources is not None:\n            task.resources = resources\n\n        if worker.enabled and not assistant:\n            task.stakeholders.add(worker_id)\n\n"]}