{"prefix": "        return self._get_with(key)\n\n    def _get_with(self, key):\n        # other: fancy integer or otherwise\n        if isinstance(key, slice):\n            return self._slice(key)\n        elif isinstance(key, ABCDataFrame):\n            raise TypeError(\n                \"Indexing a Series with DataFrame is not \"\n                \"supported, use the appropriate DataFrame column\"\n            )\n        elif isinstance(key, tuple):\n            try:\n                return self._get_values_tuple(key)\n            except ValueError:\n                # if we don't have a MultiIndex, we may still be able to handle\n                #  a 1-tuple.  see test_1tuple_without_multiindex\n                if len(key) == 1:\n                    key = key[0]\n                    if isinstance(key, slice):\n                        return self._get_values(key)\n                raise\n\n        if not isinstance(key, (list, np.ndarray, Series, Index)):\n            key = list(key)\n\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n\n        # Note: The key_type == \"boolean\" case should be caught by the\n        #  com.is_bool_indexer check in __getitem__\n        if key_type == \"integer\":\n            if self.index.is_integer() or self.index.is_floating():\n                return self.loc[key]\n            elif isinstance(self.index, IntervalIndex):\n                indexer = self.index.get_indexer_for(key)\n                return self.iloc[indexer]\n            else:\n", "suffix": "\n        if isinstance(key, (list, tuple)):\n            # TODO: de-dup with tuple case handled above?\n            # handle the dup indexing case GH#4246\n            if len(key) == 1 and isinstance(key[0], slice):\n                # [slice(0, 5, None)] will break if you convert to ndarray,\n                # e.g. as requested by np.median\n                # FIXME: hack\n                return self._get_values(key)\n\n            return self.loc[key]\n\n        return self.reindex(key)\n\n    def _get_values_tuple(self, key):\n        # mpl hackaround\n        if com.any_none(*key):\n            # suppress warning from slicing the index with a 2d indexer.\n            # eventually we'll want Series itself to warn.\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\n                    \"ignore\", \"Support for multi-dim\", DeprecationWarning\n                )\n                return self._get_values(key)\n\n        if not isinstance(self.index, MultiIndex):\n            raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n        # If key is contained, would have returned by now\n        indexer, new_index = self.index.get_loc_level(key)\n        return self._constructor(self._values[indexer], index=new_index).__finalize__(\n            self\n        )\n\n    def _get_values(self, indexer):\n        try:\n            return self._constructor(\n                self._data.get_slice(indexer), fastpath=True\n            ).__finalize__(self)\n        except ValueError:\n", "long_prefix": ["\n    def _slice(self, slobj: slice, axis: int = 0, kind: str = \"getitem\") -> \"Series\":\n        assert kind in [\"getitem\", \"iloc\"]\n        slobj = self.index._convert_slice_indexer(slobj, kind=kind)\n        return self._get_values(slobj)\n\n    def __getitem__(self, key):\n        key = com.apply_if_callable(key, self)\n\n        if key is Ellipsis:\n            return self\n\n        key_is_scalar = is_scalar(key)\n        if key_is_scalar:\n            key = self.index._convert_scalar_indexer(key, kind=\"getitem\")\n\n        if key_is_scalar or isinstance(self.index, MultiIndex):\n            # Otherwise index.get_value will raise InvalidIndexError\n            try:\n                result = self.index.get_value(self, key)\n\n                return result\n            except InvalidIndexError:\n                pass\n            except (KeyError, ValueError):\n                if isinstance(key, tuple) and isinstance(self.index, MultiIndex):\n                    # kludge\n                    pass\n                else:\n                    raise\n\n        if not key_is_scalar:\n            # avoid expensive checks if we know we have a scalar\n            if is_iterator(key):\n                key = list(key)\n\n            if com.is_bool_indexer(key):\n                key = check_bool_indexer(self.index, key)\n                return self._get_values(key)\n\n        return self._get_with(key)\n\n    def _get_with(self, key):\n        # other: fancy integer or otherwise\n        if isinstance(key, slice):\n            return self._slice(key)\n        elif isinstance(key, ABCDataFrame):\n            raise TypeError(\n                \"Indexing a Series with DataFrame is not \"\n                \"supported, use the appropriate DataFrame column\"\n            )\n        elif isinstance(key, tuple):\n            try:\n                return self._get_values_tuple(key)\n            except ValueError:\n                # if we don't have a MultiIndex, we may still be able to handle\n                #  a 1-tuple.  see test_1tuple_without_multiindex\n                if len(key) == 1:\n                    key = key[0]\n                    if isinstance(key, slice):\n                        return self._get_values(key)\n                raise\n\n        if not isinstance(key, (list, np.ndarray, Series, Index)):\n            key = list(key)\n\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n\n        # Note: The key_type == \"boolean\" case should be caught by the\n        #  com.is_bool_indexer check in __getitem__\n        if key_type == \"integer\":\n            if self.index.is_integer() or self.index.is_floating():\n                return self.loc[key]\n            elif isinstance(self.index, IntervalIndex):\n                indexer = self.index.get_indexer_for(key)\n                return self.iloc[indexer]\n            else:\n", "\n        if isinstance(key, (list, tuple)):\n            # TODO: de-dup with tuple case handled above?\n            # handle the dup indexing case GH#4246\n            if len(key) == 1 and isinstance(key[0], slice):\n                # [slice(0, 5, None)] will break if you convert to ndarray,\n                # e.g. as requested by np.median\n                # FIXME: hack\n                return self._get_values(key)\n\n            return self.loc[key]\n\n        return self.reindex(key)\n\n    def _get_values_tuple(self, key):\n        # mpl hackaround\n        if com.any_none(*key):\n            # suppress warning from slicing the index with a 2d indexer.\n            # eventually we'll want Series itself to warn.\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\n                    \"ignore\", \"Support for multi-dim\", DeprecationWarning\n                )\n                return self._get_values(key)\n\n        if not isinstance(self.index, MultiIndex):\n            raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n        # If key is contained, would have returned by now\n        indexer, new_index = self.index.get_loc_level(key)\n        return self._constructor(self._values[indexer], index=new_index).__finalize__(\n            self\n        )\n\n    def _get_values(self, indexer):\n        try:\n            return self._constructor(\n                self._data.get_slice(indexer), fastpath=True\n            ).__finalize__(self)\n        except ValueError:\n"]}