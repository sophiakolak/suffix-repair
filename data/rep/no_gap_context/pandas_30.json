{"prefix": "            try:\n                data = data.astype(\"int64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n        return data, result\n\n    def _try_convert_to_date(self, data):\n        \"\"\"\n        Try to parse a ndarray like into a date column.\n\n        Try to coerce object in epoch/iso formats and integer/float in epoch\n        formats. Return a boolean if parsing was successful.\n        \"\"\"\n        # no conversion on empty\n        if not len(data):\n            return data, False\n\n        new_data = data\n        if new_data.dtype == \"object\":\n            try:\n                new_data = data.astype(\"int64\")\n            except (TypeError, ValueError, OverflowError):\n                pass\n\n        # ignore numbers that are out of range\n        if issubclass(new_data.dtype.type, np.number):\n            in_range = (\n                isna(new_data._values)\n                | (new_data > self.min_stamp)\n                | (new_data._values == iNaT)\n            )\n            if not in_range.all():\n                return data, False\n\n        date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n        for date_unit in date_units:\n            try:\n                new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\n", "suffix": "                continue\n            return new_data, True\n        return data, False\n\n    def _try_convert_dates(self):\n        raise AbstractMethodError(self)\n\n\nclass SeriesParser(Parser):\n    _default_orient = \"index\"\n    _split_keys = (\"name\", \"index\", \"data\")\n\n    def _parse_no_numpy(self):\n        data = loads(self.json, precise_float=self.precise_float)\n\n        if self.orient == \"split\":\n            decoded = {str(k): v for k, v in data.items()}\n            self.check_keys_split(decoded)\n            self.obj = create_series_with_explicit_dtype(**decoded)\n        else:\n            self.obj = create_series_with_explicit_dtype(data, dtype_if_empty=object)\n\n    def _parse_numpy(self):\n        load_kwargs = {\n            \"dtype\": None,\n            \"numpy\": True,\n            \"precise_float\": self.precise_float,\n        }\n        if self.orient in [\"columns\", \"index\"]:\n            load_kwargs[\"labelled\"] = True\n        loads_ = functools.partial(loads, **load_kwargs)\n        data = loads_(self.json)\n\n        if self.orient == \"split\":\n            decoded = {str(k): v for k, v in data.items()}\n            self.check_keys_split(decoded)\n            self.obj = create_series_with_explicit_dtype(**decoded)\n        elif self.orient in [\"columns\", \"index\"]:\n            self.obj = create_series_with_explicit_dtype(*data, dtype_if_empty=object)\n        else:\n", "long_prefix": ["                return new_data, True\n\n        result = False\n\n        if data.dtype == \"object\":\n\n            # try float\n            try:\n                data = data.astype(\"float64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n        if data.dtype.kind == \"f\":\n\n            if data.dtype != \"float64\":\n\n                # coerce floats to 64\n                try:\n                    data = data.astype(\"float64\")\n                    result = True\n                except (TypeError, ValueError):\n                    pass\n\n        # don't coerce 0-len data\n        if len(data) and (data.dtype == \"float\" or data.dtype == \"object\"):\n\n            # coerce ints if we can\n            try:\n                new_data = data.astype(\"int64\")\n                if (new_data == data).all():\n                    data = new_data\n                    result = True\n            except (TypeError, ValueError, OverflowError):\n                pass\n\n        # coerce ints to 64\n        if data.dtype == \"int\":\n\n            # coerce floats to 64\n            try:\n                data = data.astype(\"int64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n        return data, result\n\n    def _try_convert_to_date(self, data):\n        \"\"\"\n        Try to parse a ndarray like into a date column.\n\n        Try to coerce object in epoch/iso formats and integer/float in epoch\n        formats. Return a boolean if parsing was successful.\n        \"\"\"\n        # no conversion on empty\n        if not len(data):\n            return data, False\n\n        new_data = data\n        if new_data.dtype == \"object\":\n            try:\n                new_data = data.astype(\"int64\")\n            except (TypeError, ValueError, OverflowError):\n                pass\n\n        # ignore numbers that are out of range\n        if issubclass(new_data.dtype.type, np.number):\n            in_range = (\n                isna(new_data._values)\n                | (new_data > self.min_stamp)\n                | (new_data._values == iNaT)\n            )\n            if not in_range.all():\n                return data, False\n\n        date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n        for date_unit in date_units:\n            try:\n                new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\n", "                continue\n            return new_data, True\n        return data, False\n\n    def _try_convert_dates(self):\n        raise AbstractMethodError(self)\n\n\nclass SeriesParser(Parser):\n    _default_orient = \"index\"\n    _split_keys = (\"name\", \"index\", \"data\")\n\n    def _parse_no_numpy(self):\n        data = loads(self.json, precise_float=self.precise_float)\n\n        if self.orient == \"split\":\n            decoded = {str(k): v for k, v in data.items()}\n            self.check_keys_split(decoded)\n            self.obj = create_series_with_explicit_dtype(**decoded)\n        else:\n            self.obj = create_series_with_explicit_dtype(data, dtype_if_empty=object)\n\n    def _parse_numpy(self):\n        load_kwargs = {\n            \"dtype\": None,\n            \"numpy\": True,\n            \"precise_float\": self.precise_float,\n        }\n        if self.orient in [\"columns\", \"index\"]:\n            load_kwargs[\"labelled\"] = True\n        loads_ = functools.partial(loads, **load_kwargs)\n        data = loads_(self.json)\n\n        if self.orient == \"split\":\n            decoded = {str(k): v for k, v in data.items()}\n            self.check_keys_split(decoded)\n            self.obj = create_series_with_explicit_dtype(**decoded)\n        elif self.orient in [\"columns\", \"index\"]:\n            self.obj = create_series_with_explicit_dtype(*data, dtype_if_empty=object)\n        else:\n"]}