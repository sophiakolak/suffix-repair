{"prefix": "    def table_schema(self, table, database='default'):\n        \"\"\"\n        Returns list of [(name, type)] for each column in database.table.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def table_exists(self, table, database='default', partition=None):\n        \"\"\"\n        Returns true if db.table (or db.table.partition) exists. partition is a dict of partition key to\n        value.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def partition_spec(self, partition):\n        \"\"\" Turn a dict into a string partition specification \"\"\"\n        pass\n\n\nclass HiveCommandClient(HiveClient):\n    \"\"\"\n    Uses `hive` invocations to find information.\n    \"\"\"\n\n    def table_location(self, table, database='default', partition=None):\n        cmd = \"use {0}; describe formatted {1}\".format(database, table)\n        if partition is not None:\n            cmd += \" PARTITION ({0})\".format(self.partition_spec(partition))\n\n        stdout = run_hive_cmd(cmd)\n\n        for line in stdout.split(\"\\n\"):\n            if \"Location:\" in line:\n                return line.split(\"\\t\")[1]\n\n    def table_exists(self, table, database='default', partition=None):\n        if partition is None:\n            stdout = run_hive_cmd('use {0}; show tables like \"{1}\";'.format(database, table))\n\n", "suffix": "        else:\n            stdout = run_hive_cmd(\"\"\"use %s; show partitions %s partition\n                                (%s)\"\"\" % (database, table, self.partition_spec(partition)))\n\n            if stdout:\n                return True\n            else:\n                return False\n\n    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table))\n        if not describe or \"does not exist\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]\n\n    def partition_spec(self, partition):\n        \"\"\"\n        Turns a dict into the a Hive partition specification string.\n        \"\"\"\n        return ','.join([\"{0}='{1}'\".format(k, v) for (k, v) in\n                         sorted(six.iteritems(partition), key=operator.itemgetter(0))])\n\n\nclass ApacheHiveCommandClient(HiveCommandClient):\n    \"\"\"\n    A subclass for the HiveCommandClient to (in some cases) ignore the return code from\n    the hive command so that we can just parse the output.\n    \"\"\"\n\n    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table), False)\n        if not describe or \"Table not found\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]\n\n\nclass MetastoreClient(HiveClient):\n\n    def table_location(self, table, database='default', partition=None):\n        with HiveThriftContext() as client:\n", "long_prefix": ["    (which are done using DESCRIBE do not exit with a return code of 0\n    so we need an option to ignore the return code and just return stdout for parsing\n    \"\"\"\n    cmd = [load_hive_cmd()] + args\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    if check_return_code and p.returncode != 0:\n        raise HiveCommandError(\"Hive command: {0} failed with error code: {1}\".format(\" \".join(cmd), p.returncode),\n                               stdout, stderr)\n    return stdout\n\n\ndef run_hive_cmd(hivecmd, check_return_code=True):\n    \"\"\"\n    Runs the given hive query and returns stdout.\n    \"\"\"\n    return run_hive(['-e', hivecmd], check_return_code)\n\n\ndef run_hive_script(script):\n    \"\"\"\n    Runs the contents of the given script in hive and returns stdout.\n    \"\"\"\n    if not os.path.isfile(script):\n        raise RuntimeError(\"Hive script: {0} does not exist.\".format(script))\n    return run_hive(['-f', script])\n\n\n@six.add_metaclass(abc.ABCMeta)\nclass HiveClient(object):  # interface\n\n    @abc.abstractmethod\n    def table_location(self, table, database='default', partition=None):\n        \"\"\"\n        Returns location of db.table (or db.table.partition). partition is a dict of partition key to\n        value.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def table_schema(self, table, database='default'):\n        \"\"\"\n        Returns list of [(name, type)] for each column in database.table.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def table_exists(self, table, database='default', partition=None):\n        \"\"\"\n        Returns true if db.table (or db.table.partition) exists. partition is a dict of partition key to\n        value.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def partition_spec(self, partition):\n        \"\"\" Turn a dict into a string partition specification \"\"\"\n        pass\n\n\nclass HiveCommandClient(HiveClient):\n    \"\"\"\n    Uses `hive` invocations to find information.\n    \"\"\"\n\n    def table_location(self, table, database='default', partition=None):\n        cmd = \"use {0}; describe formatted {1}\".format(database, table)\n        if partition is not None:\n            cmd += \" PARTITION ({0})\".format(self.partition_spec(partition))\n\n        stdout = run_hive_cmd(cmd)\n\n        for line in stdout.split(\"\\n\"):\n            if \"Location:\" in line:\n                return line.split(\"\\t\")[1]\n\n    def table_exists(self, table, database='default', partition=None):\n        if partition is None:\n            stdout = run_hive_cmd('use {0}; show tables like \"{1}\";'.format(database, table))\n\n", "        else:\n            stdout = run_hive_cmd(\"\"\"use %s; show partitions %s partition\n                                (%s)\"\"\" % (database, table, self.partition_spec(partition)))\n\n            if stdout:\n                return True\n            else:\n                return False\n\n    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table))\n        if not describe or \"does not exist\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]\n\n    def partition_spec(self, partition):\n        \"\"\"\n        Turns a dict into the a Hive partition specification string.\n        \"\"\"\n        return ','.join([\"{0}='{1}'\".format(k, v) for (k, v) in\n                         sorted(six.iteritems(partition), key=operator.itemgetter(0))])\n\n\nclass ApacheHiveCommandClient(HiveCommandClient):\n    \"\"\"\n    A subclass for the HiveCommandClient to (in some cases) ignore the return code from\n    the hive command so that we can just parse the output.\n    \"\"\"\n\n    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table), False)\n        if not describe or \"Table not found\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]\n\n\nclass MetastoreClient(HiveClient):\n\n    def table_location(self, table, database='default', partition=None):\n        with HiveThriftContext() as client:\n"]}