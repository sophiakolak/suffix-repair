{"prefix": "\n    def create_table(self, connection):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types (optionally)\n        specified in columns.\n\n        If overridden, use the provided connection object for\n        setting up the table in order to create the table and\n        insert data using the same transaction.\n        \"\"\"\n        if len(self.columns[0]) == 1:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented \"\n                                      \"for %r and columns types not \"\n                                      \"specified\" % self.table)\n        elif len(self.columns[0]) == 2:\n            # if columns is specified as (name, type) tuples\n            coldefs = ','.join(\n                '{name} {type}'.format(\n                    name=name,\n                    type=type) for name, type in self.columns\n            )\n            query = (\"CREATE TABLE \"\n                     \"{table} ({coldefs}) \"\n                     \"{table_attributes}\").format(\n                table=self.table,\n                coldefs=coldefs,\n                table_attributes=self.table_attributes())\n            connection.cursor().execute(query)\n\n    def run(self):\n        \"\"\"\n        If the target table doesn't exist, self.create_table\n        will be called to attempt to create the table.\n        \"\"\"\n        if not (self.table):\n            raise Exception(\"table need to be specified\")\n\n", "suffix": "        connection = self.output().connect()\n        if not self.does_table_exist(connection):\n            # try creating table\n            logger.info(\"Creating table %s\", self.table)\n            connection.reset()\n            self.create_table(connection)\n        elif self.do_truncate_table():\n            logger.info(\"Truncating table %s\", self.table)\n            self.truncate_table(connection)\n\n        logger.info(\"Inserting file: %s\", path)\n        cursor = connection.cursor()\n        self.init_copy(connection)\n        self.copy(cursor, path)\n        self.output().touch(connection)\n        connection.commit()\n\n        # commit and clean up\n        connection.close()\n\n    def copy(self, cursor, f):\n        \"\"\"\n        Defines copying from s3 into redshift.\n        \"\"\"\n\n        cursor.execute(\"\"\"\n         COPY %s from '%s'\n         CREDENTIALS 'aws_access_key_id=%s;aws_secret_access_key=%s'\n         delimiter '%s'\n         %s\n         ;\"\"\" % (self.table, f, self.aws_access_key_id,\n                 self.aws_secret_access_key, self.column_separator,\n                 self.copy_options))\n\n    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n", "long_prefix": ["    @abc.abstractproperty\n    def aws_secret_access_key(self):\n        \"\"\"\n        Override to return the secret access key.\n        \"\"\"\n        return None\n\n    @abc.abstractproperty\n    def copy_options(self):\n        \"\"\"\n        Add extra copy options, for example:\n\n        * TIMEFORMAT 'auto'\n        * IGNOREHEADER 1\n        * TRUNCATECOLUMNS\n        * IGNOREBLANKLINES\n        \"\"\"\n        return ''\n\n    def table_attributes(self):\n        '''Add extra table attributes, for example:\n        DISTSTYLE KEY\n        DISTKEY (MY_FIELD)\n        SORTKEY (MY_FIELD_2, MY_FIELD_3)\n        '''\n        return ''\n\n    def do_truncate_table(self):\n        \"\"\"\n        Return True if table should be truncated before copying new data in.\n        \"\"\"\n        return False\n\n    def truncate_table(self, connection):\n        query = \"truncate %s\" % self.table\n        cursor = connection.cursor()\n        try:\n            cursor.execute(query)\n        finally:\n            cursor.close()\n\n    def create_table(self, connection):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types (optionally)\n        specified in columns.\n\n        If overridden, use the provided connection object for\n        setting up the table in order to create the table and\n        insert data using the same transaction.\n        \"\"\"\n        if len(self.columns[0]) == 1:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented \"\n                                      \"for %r and columns types not \"\n                                      \"specified\" % self.table)\n        elif len(self.columns[0]) == 2:\n            # if columns is specified as (name, type) tuples\n            coldefs = ','.join(\n                '{name} {type}'.format(\n                    name=name,\n                    type=type) for name, type in self.columns\n            )\n            query = (\"CREATE TABLE \"\n                     \"{table} ({coldefs}) \"\n                     \"{table_attributes}\").format(\n                table=self.table,\n                coldefs=coldefs,\n                table_attributes=self.table_attributes())\n            connection.cursor().execute(query)\n\n    def run(self):\n        \"\"\"\n        If the target table doesn't exist, self.create_table\n        will be called to attempt to create the table.\n        \"\"\"\n        if not (self.table):\n            raise Exception(\"table need to be specified\")\n\n", "        connection = self.output().connect()\n        if not self.does_table_exist(connection):\n            # try creating table\n            logger.info(\"Creating table %s\", self.table)\n            connection.reset()\n            self.create_table(connection)\n        elif self.do_truncate_table():\n            logger.info(\"Truncating table %s\", self.table)\n            self.truncate_table(connection)\n\n        logger.info(\"Inserting file: %s\", path)\n        cursor = connection.cursor()\n        self.init_copy(connection)\n        self.copy(cursor, path)\n        self.output().touch(connection)\n        connection.commit()\n\n        # commit and clean up\n        connection.close()\n\n    def copy(self, cursor, f):\n        \"\"\"\n        Defines copying from s3 into redshift.\n        \"\"\"\n\n        cursor.execute(\"\"\"\n         COPY %s from '%s'\n         CREDENTIALS 'aws_access_key_id=%s;aws_secret_access_key=%s'\n         delimiter '%s'\n         %s\n         ;\"\"\" % (self.table, f, self.aws_access_key_id,\n                 self.aws_secret_access_key, self.column_separator,\n                 self.copy_options))\n\n    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n"]}