{"prefix": "                        return data.astype(dtype), True\n                    except (TypeError, ValueError):\n                        return data, False\n\n        if convert_dates:\n            new_data, result = self._try_convert_to_date(data)\n            if result:\n                return new_data, True\n\n        result = False\n\n        if data.dtype == \"object\":\n\n            # try float\n            try:\n                data = data.astype(\"float64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n        if data.dtype.kind == \"f\":\n\n            if data.dtype != \"float64\":\n\n                # coerce floats to 64\n                try:\n                    data = data.astype(\"float64\")\n                    result = True\n                except (TypeError, ValueError):\n                    pass\n\n        # don't coerce 0-len data\n        if len(data) and (data.dtype == \"float\" or data.dtype == \"object\"):\n\n            # coerce ints if we can\n            try:\n                new_data = data.astype(\"int64\")\n                if (new_data == data).all():\n                    data = new_data\n                    result = True\n", "suffix": "                pass\n\n        # coerce ints to 64\n        if data.dtype == \"int\":\n\n            # coerce floats to 64\n            try:\n                data = data.astype(\"int64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n        return data, result\n\n    def _try_convert_to_date(self, data):\n        \"\"\"\n        Try to parse a ndarray like into a date column.\n\n        Try to coerce object in epoch/iso formats and integer/float in epoch\n        formats. Return a boolean if parsing was successful.\n        \"\"\"\n\n        # no conversion on empty\n        if not len(data):\n            return data, False\n\n        new_data = data\n        if new_data.dtype == \"object\":\n            try:\n                new_data = data.astype(\"int64\")\n            except (TypeError, ValueError, OverflowError):\n                pass\n\n        # ignore numbers that are out of range\n        if issubclass(new_data.dtype.type, np.number):\n            in_range = (\n                isna(new_data.values)\n                | (new_data > self.min_stamp)\n                | (new_data.values == iNaT)\n            )\n", "long_prefix": ["        if self.obj is None:\n            return None\n        if self.convert_axes:\n            self._convert_axes()\n        self._try_convert_types()\n        return self.obj\n\n    def _convert_axes(self):\n        \"\"\"\n        Try to convert axes.\n        \"\"\"\n        for axis in self.obj._AXIS_NUMBERS.keys():\n            new_axis, result = self._try_convert_data(\n                axis, self.obj._get_axis(axis), use_dtypes=False, convert_dates=True\n            )\n            if result:\n                setattr(self.obj, axis, new_axis)\n\n    def _try_convert_types(self):\n        raise AbstractMethodError(self)\n\n    def _try_convert_data(self, name, data, use_dtypes=True, convert_dates=True):\n        \"\"\"\n        Try to parse a ndarray like into a column by inferring dtype.\n        \"\"\"\n\n        # don't try to coerce, unless a force conversion\n        if use_dtypes:\n            if not self.dtype:\n                return data, False\n            elif self.dtype is True:\n                pass\n            else:\n                # dtype to force\n                dtype = (\n                    self.dtype.get(name) if isinstance(self.dtype, dict) else self.dtype\n                )\n                if dtype is not None:\n                    try:\n                        dtype = np.dtype(dtype)\n                        return data.astype(dtype), True\n                    except (TypeError, ValueError):\n                        return data, False\n\n        if convert_dates:\n            new_data, result = self._try_convert_to_date(data)\n            if result:\n                return new_data, True\n\n        result = False\n\n        if data.dtype == \"object\":\n\n            # try float\n            try:\n                data = data.astype(\"float64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n        if data.dtype.kind == \"f\":\n\n            if data.dtype != \"float64\":\n\n                # coerce floats to 64\n                try:\n                    data = data.astype(\"float64\")\n                    result = True\n                except (TypeError, ValueError):\n                    pass\n\n        # don't coerce 0-len data\n        if len(data) and (data.dtype == \"float\" or data.dtype == \"object\"):\n\n            # coerce ints if we can\n            try:\n                new_data = data.astype(\"int64\")\n                if (new_data == data).all():\n                    data = new_data\n                    result = True\n", "                pass\n\n        # coerce ints to 64\n        if data.dtype == \"int\":\n\n            # coerce floats to 64\n            try:\n                data = data.astype(\"int64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n        return data, result\n\n    def _try_convert_to_date(self, data):\n        \"\"\"\n        Try to parse a ndarray like into a date column.\n\n        Try to coerce object in epoch/iso formats and integer/float in epoch\n        formats. Return a boolean if parsing was successful.\n        \"\"\"\n\n        # no conversion on empty\n        if not len(data):\n            return data, False\n\n        new_data = data\n        if new_data.dtype == \"object\":\n            try:\n                new_data = data.astype(\"int64\")\n            except (TypeError, ValueError, OverflowError):\n                pass\n\n        # ignore numbers that are out of range\n        if issubclass(new_data.dtype.type, np.number):\n            in_range = (\n                isna(new_data.values)\n                | (new_data > self.min_stamp)\n                | (new_data.values == iNaT)\n            )\n"]}