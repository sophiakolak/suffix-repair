{"prefix": "            elif task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                formatted.append(src)\n                report.done(src, Changed.YES if task.result() else Changed.NO)\n\n    if cancelled:\n        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)\n    if write_back != WriteBack.DIFF and formatted:\n        write_cache(cache, formatted)\n\n\ndef format_file_in_place(\n    src: Path,\n    line_length: int,\n    fast: bool,\n    write_back: WriteBack = WriteBack.NO,\n    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    try:\n        dst_contents = format_file_contents(\n            src_contents, line_length=line_length, fast=fast\n        )\n    except NothingChanged:\n        return False\n\n    if write_back == write_back.YES:\n        with open(src, \"w\", encoding=src_buffer.encoding) as f:\n            f.write(dst_contents)\n    elif write_back == write_back.DIFF:\n", "suffix": "        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)\n        if lock:\n            lock.acquire()\n        try:\n            sys.stdout.write(diff_contents)\n        finally:\n            if lock:\n                lock.release()\n    return True\n\n\ndef format_stdin_to_stdout(\n    line_length: int, fast: bool, write_back: WriteBack = WriteBack.NO\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` arguments are passed to :func:`format_file_contents`.\n    \"\"\"\n    src = sys.stdin.read()\n    dst = src\n    try:\n        dst = format_file_contents(src, line_length=line_length, fast=fast)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        if write_back == WriteBack.YES:\n            sys.stdout.write(dst)\n        elif write_back == WriteBack.DIFF:\n            src_name = \"<stdin>  (original)\"\n            dst_name = \"<stdin>  (formatted)\"\n            sys.stdout.write(diff(src, dst, src_name, dst_name))\n\n\ndef format_file_contents(\n    src_contents: str, line_length: int, fast: bool\n) -> FileContent:\n", "long_prefix": ["\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `line_length`, `write_back`, and `fast` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    cache: Cache = {}\n    if write_back != WriteBack.DIFF:\n        cache = read_cache()\n        sources, cached = filter_cached(cache, sources)\n        for src in cached:\n            report.done(src, Changed.CACHED)\n    cancelled = []\n    formatted = []\n    if sources:\n        lock = None\n        if write_back == WriteBack.DIFF:\n            # For diff output, we need locks to ensure we don't interleave output\n            # from different processes.\n            manager = Manager()\n            lock = manager.Lock()\n        tasks = {\n            src: loop.run_in_executor(\n                executor, format_file_in_place, src, line_length, fast, write_back, lock\n            )\n            for src in sources\n        }\n        _task_values = list(tasks.values())\n        try:\n            loop.add_signal_handler(signal.SIGINT, cancel, _task_values)\n            loop.add_signal_handler(signal.SIGTERM, cancel, _task_values)\n        except NotImplementedError:\n            # There are no good alternatives for these on Windows\n            pass\n        await asyncio.wait(_task_values)\n        for src, task in tasks.items():\n            if not task.done():\n                report.failed(src, \"timed out, cancelling\")\n                task.cancel()\n                cancelled.append(task)\n            elif task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                formatted.append(src)\n                report.done(src, Changed.YES if task.result() else Changed.NO)\n\n    if cancelled:\n        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)\n    if write_back != WriteBack.DIFF and formatted:\n        write_cache(cache, formatted)\n\n\ndef format_file_in_place(\n    src: Path,\n    line_length: int,\n    fast: bool,\n    write_back: WriteBack = WriteBack.NO,\n    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n\n    with tokenize.open(src) as src_buffer:\n        src_contents = src_buffer.read()\n    try:\n        dst_contents = format_file_contents(\n            src_contents, line_length=line_length, fast=fast\n        )\n    except NothingChanged:\n        return False\n\n    if write_back == write_back.YES:\n        with open(src, \"w\", encoding=src_buffer.encoding) as f:\n            f.write(dst_contents)\n    elif write_back == write_back.DIFF:\n", "        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)\n        if lock:\n            lock.acquire()\n        try:\n            sys.stdout.write(diff_contents)\n        finally:\n            if lock:\n                lock.release()\n    return True\n\n\ndef format_stdin_to_stdout(\n    line_length: int, fast: bool, write_back: WriteBack = WriteBack.NO\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is True, write reformatted code back to stdout.\n    `line_length` and `fast` arguments are passed to :func:`format_file_contents`.\n    \"\"\"\n    src = sys.stdin.read()\n    dst = src\n    try:\n        dst = format_file_contents(src, line_length=line_length, fast=fast)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        if write_back == WriteBack.YES:\n            sys.stdout.write(dst)\n        elif write_back == WriteBack.DIFF:\n            src_name = \"<stdin>  (original)\"\n            dst_name = \"<stdin>  (formatted)\"\n            sys.stdout.write(diff(src, dst, src_name, dst_name))\n\n\ndef format_file_contents(\n    src_contents: str, line_length: int, fast: bool\n) -> FileContent:\n"]}