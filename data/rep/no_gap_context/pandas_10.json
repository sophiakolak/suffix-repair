{"prefix": "\n    def iget(self, col):\n\n        if self.ndim == 2 and isinstance(col, tuple):\n            # TODO(EA2D): unnecessary with 2D EAs\n            col, loc = col\n            if not com.is_null_slice(col) and col != 0:\n                raise IndexError(f\"{self} only contains one item\")\n            elif isinstance(col, slice):\n                if col != slice(None):\n                    raise NotImplementedError(col)\n                return self.values[[loc]]\n            return self.values[loc]\n        else:\n            if col != 0:\n                raise IndexError(f\"{self} only contains one item\")\n            return self.values\n\n    def should_store(self, value: ArrayLike) -> bool:\n        \"\"\"\n        Can we set the given array-like value inplace?\n        \"\"\"\n        return isinstance(value, self._holder)\n\n    def set(self, locs, values):\n        assert locs.tolist() == [0]\n        self.values[:] = values\n\n    def putmask(\n        self, mask, new, inplace: bool = False, axis: int = 0, transpose: bool = False,\n    ) -> List[\"Block\"]:\n        \"\"\"\n        See Block.putmask.__doc__\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n        mask = _extract_bool_array(mask)\n\n        new_values = self.values if inplace else self.values.copy()\n\n", "suffix": "            new = new[mask]\n\n        mask = _safe_reshape(mask, new_values.shape)\n\n        new_values[mask] = new\n        return [self.make_block(values=new_values)]\n\n    def _maybe_coerce_values(self, values):\n        \"\"\"\n        Unbox to an extension array.\n\n        This will unbox an ExtensionArray stored in an Index or Series.\n        ExtensionArrays pass through. No dtype coercion is done.\n\n        Parameters\n        ----------\n        values : Index, Series, ExtensionArray\n\n        Returns\n        -------\n        ExtensionArray\n        \"\"\"\n        return extract_array(values)\n\n    @property\n    def _holder(self):\n        # For extension blocks, the holder is values-dependent.\n        return type(self.values)\n\n    @property\n    def fill_value(self):\n        # Used in reindex_indexer\n        return self.values.dtype.na_value\n\n    @property\n    def _can_hold_na(self):\n        # The default ExtensionArray._can_hold_na is True\n        return self._holder._can_hold_na\n\n    @property\n", "long_prefix": ["\n    _can_consolidate = False\n    _verify_integrity = False\n    _validate_ndim = False\n    is_extension = True\n\n    def __init__(self, values, placement, ndim=None):\n        \"\"\"\n        Initialize a non-consolidatable block.\n\n        'ndim' may be inferred from 'placement'.\n\n        This will call continue to call __init__ for the other base\n        classes mixed in with this Mixin.\n        \"\"\"\n        values = self._maybe_coerce_values(values)\n\n        # Placement must be converted to BlockPlacement so that we can check\n        # its length\n        if not isinstance(placement, libinternals.BlockPlacement):\n            placement = libinternals.BlockPlacement(placement)\n\n        # Maybe infer ndim from placement\n        if ndim is None:\n            if len(placement) != 1:\n                ndim = 1\n            else:\n                ndim = 2\n        super().__init__(values, placement, ndim=ndim)\n\n        if self.ndim == 2 and len(self.mgr_locs) != 1:\n            # TODO(EA2D): check unnecessary with 2D EAs\n            raise AssertionError(\"block.size != values.size\")\n\n    @property\n    def shape(self):\n        # TODO(EA2D): override unnecessary with 2D EAs\n        if self.ndim == 1:\n            return ((len(self.values)),)\n        return (len(self.mgr_locs), len(self.values))\n\n    def iget(self, col):\n\n        if self.ndim == 2 and isinstance(col, tuple):\n            # TODO(EA2D): unnecessary with 2D EAs\n            col, loc = col\n            if not com.is_null_slice(col) and col != 0:\n                raise IndexError(f\"{self} only contains one item\")\n            elif isinstance(col, slice):\n                if col != slice(None):\n                    raise NotImplementedError(col)\n                return self.values[[loc]]\n            return self.values[loc]\n        else:\n            if col != 0:\n                raise IndexError(f\"{self} only contains one item\")\n            return self.values\n\n    def should_store(self, value: ArrayLike) -> bool:\n        \"\"\"\n        Can we set the given array-like value inplace?\n        \"\"\"\n        return isinstance(value, self._holder)\n\n    def set(self, locs, values):\n        assert locs.tolist() == [0]\n        self.values[:] = values\n\n    def putmask(\n        self, mask, new, inplace: bool = False, axis: int = 0, transpose: bool = False,\n    ) -> List[\"Block\"]:\n        \"\"\"\n        See Block.putmask.__doc__\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n        mask = _extract_bool_array(mask)\n\n        new_values = self.values if inplace else self.values.copy()\n\n", "            new = new[mask]\n\n        mask = _safe_reshape(mask, new_values.shape)\n\n        new_values[mask] = new\n        return [self.make_block(values=new_values)]\n\n    def _maybe_coerce_values(self, values):\n        \"\"\"\n        Unbox to an extension array.\n\n        This will unbox an ExtensionArray stored in an Index or Series.\n        ExtensionArrays pass through. No dtype coercion is done.\n\n        Parameters\n        ----------\n        values : Index, Series, ExtensionArray\n\n        Returns\n        -------\n        ExtensionArray\n        \"\"\"\n        return extract_array(values)\n\n    @property\n    def _holder(self):\n        # For extension blocks, the holder is values-dependent.\n        return type(self.values)\n\n    @property\n    def fill_value(self):\n        # Used in reindex_indexer\n        return self.values.dtype.na_value\n\n    @property\n    def _can_hold_na(self):\n        # The default ExtensionArray._can_hold_na is True\n        return self._holder._can_hold_na\n\n    @property\n"]}