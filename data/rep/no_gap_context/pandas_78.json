{"prefix": "                    # column-by-column reduction, where we have mixed type.\n                    # So let's just do what we can\n                    from pandas.core.apply import frame_apply\n\n                    opa = frame_apply(\n                        self, func=f, result_type=\"expand\", ignore_failures=True\n                    )\n                    result = opa.get_result()\n                    if result.ndim == self.ndim:\n                        result = result.iloc[0]\n                    return result\n\n                # TODO: why doesnt axis matter here?\n                data = _get_data(axis_matters=False)\n                with np.errstate(all=\"ignore\"):\n                    result = f(data.values)\n                labels = data._get_agg_axis(axis)\n        else:\n            if numeric_only:\n                data = _get_data(axis_matters=True)\n\n                values = data.values\n                labels = data._get_agg_axis(axis)\n            else:\n                values = self.values\n            result = f(values)\n\n        if hasattr(result, \"dtype\") and is_object_dtype(result.dtype):\n            try:\n                if filter_type is None or filter_type == \"numeric\":\n                    result = result.astype(np.float64)\n                elif filter_type == \"bool\" and notna(result).all():\n                    result = result.astype(np.bool_)\n            except (ValueError, TypeError):\n\n                # try to coerce to the original dtypes item by item if we can\n                if axis == 0:\n                    result = coerce_to_dtypes(result, self.dtypes)\n\n        if constructor is not None:\n", "suffix": "        return result\n\n    def nunique(self, axis=0, dropna=True) -> Series:\n        \"\"\"\n        Count distinct observations over requested axis.\n\n        Return Series with number of distinct observations. Can ignore NaN\n        values.\n\n        Parameters\n        ----------\n        axis : {0 or 'index', 1 or 'columns'}, default 0\n            The axis to use. 0 or 'index' for row-wise, 1 or 'columns' for\n            column-wise.\n        dropna : bool, default True\n            Don't include NaN in the counts.\n\n        Returns\n        -------\n        Series\n\n        See Also\n        --------\n        Series.nunique: Method nunique for Series.\n        DataFrame.count: Count non-NA cells for each column or row.\n\n        Examples\n        --------\n        >>> df = pd.DataFrame({'A': [1, 2, 3], 'B': [1, 1, 1]})\n        >>> df.nunique()\n        A    3\n        B    1\n        dtype: int64\n\n        >>> df.nunique(axis=1)\n        0    1\n        1    2\n        2    2\n        dtype: int64\n        \"\"\"\n", "long_prefix": ["            df = self\n            if numeric_only is True:\n                df = _get_data(axis_matters=True)\n            if axis == 1:\n                df = df.T\n                axis = 0\n\n            out_dtype = \"bool\" if filter_type == \"bool\" else None\n\n            # After possibly _get_data and transposing, we are now in the\n            #  simple case where we can use BlockManager._reduce\n            res = df._data.reduce(op, axis=1, skipna=skipna, **kwds)\n            assert isinstance(res, dict)\n            if len(res):\n                assert len(res) == max(list(res.keys())) + 1, res.keys()\n            out = df._constructor_sliced(res, index=range(len(res)), dtype=out_dtype)\n            out.index = df.columns\n            return out\n\n        if numeric_only is None:\n            values = self.values\n            try:\n                result = f(values)\n\n                if filter_type == \"bool\" and is_object_dtype(values) and axis is None:\n                    # work around https://github.com/numpy/numpy/issues/10489\n                    # TODO: combine with hasattr(result, 'dtype') further down\n                    # hard since we don't have `values` down there.\n                    result = np.bool_(result)\n            except TypeError:\n                # e.g. in nanops trying to convert strs to float\n\n                # try by-column first\n                if filter_type is None and axis == 0:\n                    # this can end up with a non-reduction\n                    # but not always. if the types are mixed\n                    # with datelike then need to make sure a series\n\n                    # we only end up here if we have not specified\n                    # numeric_only and yet we have tried a\n                    # column-by-column reduction, where we have mixed type.\n                    # So let's just do what we can\n                    from pandas.core.apply import frame_apply\n\n                    opa = frame_apply(\n                        self, func=f, result_type=\"expand\", ignore_failures=True\n                    )\n                    result = opa.get_result()\n                    if result.ndim == self.ndim:\n                        result = result.iloc[0]\n                    return result\n\n                # TODO: why doesnt axis matter here?\n                data = _get_data(axis_matters=False)\n                with np.errstate(all=\"ignore\"):\n                    result = f(data.values)\n                labels = data._get_agg_axis(axis)\n        else:\n            if numeric_only:\n                data = _get_data(axis_matters=True)\n\n                values = data.values\n                labels = data._get_agg_axis(axis)\n            else:\n                values = self.values\n            result = f(values)\n\n        if hasattr(result, \"dtype\") and is_object_dtype(result.dtype):\n            try:\n                if filter_type is None or filter_type == \"numeric\":\n                    result = result.astype(np.float64)\n                elif filter_type == \"bool\" and notna(result).all():\n                    result = result.astype(np.bool_)\n            except (ValueError, TypeError):\n\n                # try to coerce to the original dtypes item by item if we can\n                if axis == 0:\n                    result = coerce_to_dtypes(result, self.dtypes)\n\n        if constructor is not None:\n", "        return result\n\n    def nunique(self, axis=0, dropna=True) -> Series:\n        \"\"\"\n        Count distinct observations over requested axis.\n\n        Return Series with number of distinct observations. Can ignore NaN\n        values.\n\n        Parameters\n        ----------\n        axis : {0 or 'index', 1 or 'columns'}, default 0\n            The axis to use. 0 or 'index' for row-wise, 1 or 'columns' for\n            column-wise.\n        dropna : bool, default True\n            Don't include NaN in the counts.\n\n        Returns\n        -------\n        Series\n\n        See Also\n        --------\n        Series.nunique: Method nunique for Series.\n        DataFrame.count: Count non-NA cells for each column or row.\n\n        Examples\n        --------\n        >>> df = pd.DataFrame({'A': [1, 2, 3], 'B': [1, 1, 1]})\n        >>> df.nunique()\n        A    3\n        B    1\n        dtype: int64\n\n        >>> df.nunique(axis=1)\n        0    1\n        1    2\n        2    2\n        dtype: int64\n        \"\"\"\n"]}