{"rank": 1, "bleu_score": 5.966672584960326e-155, "candidate": "        return rs\n    def _agg_by_level(self, name, axis=0, level=0, skipna=True, **kwargs):\n        grouped = self.groupby(level=level, axis=axis)\n        if hasattr(grouped, name) and skipna:\n            return getattr(grouped, name)(**kwargs)\n"}
{"rank": 2, "bleu_score": 6.146891333754782e-155, "candidate": "        return rs\n    @Substitution(**_shared_doc_kwargs)\n    @Appender(_shared_docs[\"pct_change\"] % _shared_doc_kwargs)\n    def pct_change(self, periods=1, fill_method=\"pad\", limit=None, freq=None, **kwargs):\n        axis = self._get_axis_number(kwargs.pop(\"axis\", self._stat_\n"}
{"rank": 3, "bleu_score": 5.690777443921606e-155, "candidate": "        return self._constructor(rs).__finalize__(self)\n    def cumprod(self, axis=None, skipna=True, *args, **kwargs):\n        \"\"\"\n        Return cumulative product over requested axis.\n        Parameters\n"}
{"rank": 4, "bleu_score": 0.19176714782109988, "candidate": "        if freq is not None:\n            return rs.shift(periods=1, freq=-freq, axis=axis)\n        else:\n            return rs\n    def _flex_comp_method(self, other, func, level=None, fill_value=None, axis=0):\n"}
{"rank": 5, "bleu_score": 0.0801092250235701, "candidate": "        rs = rs.iloc[1:]\n        if axis == 1:\n            rs.columns = self.columns\n        return rs\n    def shift(self, periods=1, freq=None, axis=0, fill_value=None):\n"}
{"rank": 6, "bleu_score": 0.19438820599223577, "candidate": "        if freq is None:\n            mask = isna(rs.iloc[0])\n            if mask.any():\n                rs.iloc[0][mask] = 0\n        return self._constructor(rs, **self._construct_axes_dict())\n"}
{"rank": 7, "bleu_score": 0.22891319235921206, "candidate": "        if freq is not None:\n            rs = rs.shift(periods=1, freq=freq, axis=axis)\n        return rs\n    def pipe(self, func, *args, **kwargs):\n        \"\"\"\n"}
{"rank": 8, "bleu_score": 0.05137623327375897, "candidate": "        if freq:\n            return rs.shift(freq=freq, periods=-periods, axis=axis)\n        else:\n            return rs\n    # ----------------------------------------------------------------------\n"}
{"rank": 9, "bleu_score": 0.13206763594884355, "candidate": "        if freq is None:\n            mask = notna(self.shift(periods=periods, axis=axis, **kwargs))\n        else:\n            mask = notna(data.shift(periods=periods, freq=freq, axis=axis, **kwargs))\n        return rs.where(mask)\n"}
{"rank": 10, "bleu_score": 4.857907800307607e-155, "candidate": "        return self._constructor(rs).__finalize__(self)\n    # ----------------------------------------------------------------------\n    # Cumulative Methods\n    @Substitution(name=\"DataFrame\", func_name=\"cumsum\")\n    @Appender(_doc_template)\n"}
{"rank": 11, "bleu_score": 3.088838184567378e-155, "candidate": "        return rs\n    @Appender(\n        _shared_docs[\"count\"]\n        % dict(\n            axis=_shared_doc_kwargs[\"axis\"],\n"}
{"rank": 12, "bleu_score": 0.21311708993315065, "candidate": "        if freq is not None:\n            rs = rs.shift(-periods, freq=freq, axis=axis, **kwargs)\n        return rs\n    @Substitution(\n        shortname=\"expanding\",\n"}
{"rank": 13, "bleu_score": 0.06185895741317418, "candidate": "        rs = rs.replace([np.inf, -np.inf], np.nan)\n        return rs.__finalize__(self)\n    def cummax(self, axis=None, *args, **kwargs):\n        nv.validate_cummax(args, kwargs)\n        nv.validate_min_periods(kwargs.pop(\"min_periods\", 1))\n"}
{"rank": 14, "bleu_score": 0.301552073047178, "candidate": "        if freq is None:\n            # Pad periods when freq is not specified\n            rs = rs.fillna(0)\n        return rs\n    def shift(self, periods=1, freq=None, axis=0, fill_value=None):\n"}
{"rank": 15, "bleu_score": 0.23619808869381972, "candidate": "        if freq is not None:\n            # GH 31264\n            rs.index = rs.index._with_freq(None)\n        return rs\n    def cumprod(self, axis=0, skipna=True, *args, **kwargs):\n"}
{"rank": 16, "bleu_score": 0.13630566742684472, "candidate": "        if freq is not None and not is_timedelta64_dtype(rs):\n            rs.index = shifts(rs.index, freq)\n        return rs\n    # ----------------------------------------------------------------------\n    # Function application\n"}
{"rank": 17, "bleu_score": 0.04485613040162566, "candidate": "        rs = rs.fillna(value=np.nan)  # GH 11343\n        return rs\n    # ----------------------------------------------------------------------\n    # Rolling moments, window functions\n    def _create_window(self, window, min_periods=None, center=False, win_type=None, axis=0, closed=None):\n"}
{"rank": 18, "bleu_score": 0.04828045495852678, "candidate": "        rs = rs.fillna(0)\n        return self._apply_cleanup_fill(rs, fill_method, limit, axis=axis)\n    # ----------------------------------------------------------------------\n    # Rolling Methods\n    def _create_window(self, window, axis=0):\n"}
{"rank": 19, "bleu_score": 0.058255172803546314, "candidate": "        if freq and not periods:\n            return rs\n        return rs.divide(periods)\n    # ----------------------------------------------------------------------\n    # Mapping Methods\n"}
{"rank": 20, "bleu_score": 0.1946247360403807, "candidate": "        if freq is not None:\n            index = self._get_axis(axis)\n            if isinstance(index, (PeriodIndex, DatetimeIndex)):\n                if periods > 0:\n                    first_unused = min(self.shape[axis] - periods, len(index))\n"}
